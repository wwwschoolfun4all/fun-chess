<!doctype html>
<html lang="en" class="h-full">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fun Chess Multiplayer V7.6.1</title>
  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://accounts.google.com/gsi/client"></script>
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-analytics-compat.js"></script>
  <style>
    body {
      box-sizing: border-box;
      background: #1e293b;
      margin: 0;
      padding: 0;
    }
    
    * {
      box-sizing: border-box;
    }
    
    .piece {
      transition: transform 0.2s ease;
      cursor: grab;
    }
    
    .piece:hover {
      transform: scale(1.1);
    }
    
    .piece.dragging {
      cursor: grabbing;
      opacity: 0.5;
    }
    
    .white-piece {
      text-shadow: 0 0 8px rgba(255, 255, 255, 0.9), 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    .black-piece {
      text-shadow: 0 0 8px rgba(0, 0, 0, 0.9), 0 2px 4px rgba(0, 0, 0, 0.5);
      filter: brightness(0.4);
    }
    
    .square {
      transition: background-color 0.2s ease;
    }
    
    .square.highlight {
      box-shadow: inset 0 0 0 4px rgba(255, 215, 0, 0.8);
    }
    
    .square.selected {
      box-shadow: inset 0 0 0 4px rgba(74, 222, 128, 0.8);
    }
    
    .capture-animation {
      animation: captureShake 0.4s ease;
    }
    
    @keyframes captureShake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }
    
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); }
      20%, 40%, 60%, 80% { transform: translateX(2px); }
    }
    
    @keyframes gravityFall {
      0% { transform: translateY(0); }
      50% { transform: translateY(20px); }
      100% { transform: translateY(0); }
    }
    
    @keyframes tornadoSpin {
      0% { transform: rotate(0deg) scale(1); opacity: 1; }
      50% { transform: rotate(180deg) scale(0.8); opacity: 0.5; }
      100% { transform: rotate(360deg) scale(0); opacity: 0; }
    }
    
    .piece-moving {
      animation: pieceMove 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      z-index: 100;
    }
    
    @keyframes pieceMove {
      0% { transform: scale(1) translateY(0); }
      50% { transform: scale(1.3) translateY(-20px); }
      100% { transform: scale(1) translateY(0); }
    }
    
    .piece-captured {
      animation: pieceCaptured 0.6s ease-out forwards;
    }
    
    @keyframes pieceCaptured {
      0% { 
        transform: scale(1) rotate(0deg);
        opacity: 1;
      }
      50% {
        transform: scale(1.5) rotate(180deg);
        opacity: 0.5;
      }
      100% { 
        transform: scale(0) rotate(360deg);
        opacity: 0;
      }
    }
    
    .piece-appear {
      animation: pieceAppear 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    @keyframes pieceAppear {
      0% { 
        transform: scale(0) rotate(-180deg);
        opacity: 0;
      }
      100% { 
        transform: scale(1) rotate(0deg);
        opacity: 1;
      }
    }
    
    .square-flash {
      animation: squareFlash 0.5s ease;
    }
    
    @keyframes squareFlash {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    
    .king-in-check {
      animation: checkPulse 1s ease-in-out infinite;
      box-shadow: inset 0 0 0 5px rgba(239, 68, 68, 0.8) !important;
    }
    
    @keyframes checkPulse {
      0%, 100% { 
        box-shadow: inset 0 0 0 5px rgba(239, 68, 68, 0.8);
      }
      50% { 
        box-shadow: inset 0 0 0 5px rgba(239, 68, 68, 1), 
                    0 0 20px rgba(239, 68, 68, 0.6);
      }
    }
    
    .piece-wiggle {
      animation: wiggle 0.3s ease-in-out;
    }
    
    @keyframes wiggle {
      0%, 100% { transform: rotate(0deg); }
      25% { transform: rotate(-10deg) scale(1.1); }
      75% { transform: rotate(10deg) scale(1.1); }
    }
    
    .sparkle {
      position: absolute;
      pointer-events: none;
      font-size: 24px;
      animation: sparkleFloat 1s ease-out forwards;
    }
    
    @keyframes sparkleFloat {
      0% { 
        opacity: 1;
        transform: translateY(0) scale(0);
      }
      50% {
        transform: translateY(-30px) scale(1.2);
      }
      100% { 
        opacity: 0;
        transform: translateY(-60px) scale(0.8);
      }
    }
    
    @keyframes lightningFlash {
      0% { 
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.5);
      }
      50% { 
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.5);
      }
      100% { 
        opacity: 0;
        transform: translate(-50%, -50%) scale(2);
      }
    }
    
    @keyframes lightningBolt {
      0% { 
        opacity: 0;
        transform: scaleY(0);
      }
      20% { 
        opacity: 1;
        transform: scaleY(1);
      }
      80% { 
        opacity: 1;
        transform: scaleY(1);
      }
      100% { 
        opacity: 0;
        transform: scaleY(0.8);
      }
    }
    
    @keyframes lightningSpark {
      0% { 
        opacity: 0;
        transform: translate(-50%, -50%) scale(0);
      }
      50% { 
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.5);
      }
      100% { 
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.5);
      }
    }
    
    @keyframes screenFlash {
      0% { 
        opacity: 0;
      }
      50% { 
        opacity: 1;
      }
      100% { 
        opacity: 0;
      }
    }
    
    .confetti {
      position: absolute;
      pointer-events: none;
      font-size: 20px;
      animation: confettiFall 2s ease-out forwards;
    }
    
    @keyframes confettiFall {
      0% { 
        opacity: 1;
        transform: translateY(-20px) rotate(0deg);
      }
      100% { 
        opacity: 0;
        transform: translateY(200px) rotate(720deg);
      }
    }
    
    /* Custom confetti animations for different effects */
    .confetti-rainbow,
    .confetti-fire,
    .confetti-stars,
    .confetti-lightning,
    .confetti-sparkles,
    .confetti-hearts,
    .confetti-snow,
    .confetti-confetti,
    .confetti-matrix,
    .confetti-neon,
    .confetti-bubble,
    .confetti-smoke,
    .confetti-crystal,
    .confetti-earthquake,
    .confetti-ghost,
    .confetti-laser,
    .confetti-flower,
    .confetti-wave,
    .confetti-pixel,
    .confetti-aurora,
    .confetti-tornado,
    .confetti-magic,
    .confetti-retro,
    .confetti-disco,
    .confetti-zen,
    .confetti-carnival,
    .confetti-cyber,
    .confetti-nature,
    .confetti-space,
    .confetti-golden,
    .confetti-shadow,
    .confetti-ice,
    .confetti-storm,
    .confetti-candy,
    .confetti-royal,
    .confetti-minimal,
    .confetti-chaos {
      position: absolute;
      pointer-events: none;
      font-size: 20px;
      animation: confettiFall 2s ease-out forwards;
    }
    
    /* Special animations for specific effects */
    .confetti-earthquake {
      animation: earthquakeConfetti 2s ease-out forwards;
    }
    
    @keyframes earthquakeConfetti {
      0% { 
        opacity: 1;
        transform: translateY(-20px) rotate(0deg) translateX(0);
      }
      25% {
        transform: translateY(50px) rotate(180deg) translateX(10px);
      }
      50% {
        transform: translateY(100px) rotate(360deg) translateX(-10px);
      }
      75% {
        transform: translateY(150px) rotate(540deg) translateX(5px);
      }
      100% { 
        opacity: 0;
        transform: translateY(200px) rotate(720deg) translateX(0);
      }
    }
    
    .confetti-bubble {
      animation: bubbleFloat 3s ease-out forwards;
    }
    
    @keyframes bubbleFloat {
      0% { 
        opacity: 0.8;
        transform: translateY(0) scale(0.5);
      }
      50% {
        opacity: 1;
        transform: translateY(-100px) scale(1.2);
      }
      100% { 
        opacity: 0;
        transform: translateY(-200px) scale(0.8);
      }
    }
    
    .confetti-smoke {
      animation: smokeRise 2.5s ease-out forwards;
    }
    
    @keyframes smokeRise {
      0% { 
        opacity: 0.6;
        transform: translateY(0) scale(1);
      }
      100% { 
        opacity: 0;
        transform: translateY(-150px) scale(2);
      }
    }
    
    .confetti-crystal {
      animation: crystalSparkle 2.5s ease-out forwards;
    }
    
    @keyframes crystalSparkle {
      0% { 
        opacity: 0;
        transform: translateY(-20px) rotate(0deg) scale(0);
      }
      25% {
        opacity: 1;
        transform: translateY(20px) rotate(180deg) scale(1.5);
      }
      50% {
        opacity: 0.8;
        transform: translateY(60px) rotate(360deg) scale(1);
      }
      100% { 
        opacity: 0;
        transform: translateY(200px) rotate(720deg) scale(0.5);
      }
    }
    
    .confetti-ghost {
      animation: ghostFloat 3s ease-out forwards;
    }
    
    @keyframes ghostFloat {
      0% { 
        opacity: 0.3;
        transform: translateY(-20px) translateX(0);
      }
      25% {
        transform: translateY(30px) translateX(20px);
      }
      50% {
        transform: translateY(80px) translateX(-20px);
      }
      75% {
        transform: translateY(130px) translateX(10px);
      }
      100% { 
        opacity: 0;
        transform: translateY(200px) translateX(0);
      }
    }
    
    .confetti-laser {
      animation: laserBeam 1.5s ease-out forwards;
    }
    
    @keyframes laserBeam {
      0% { 
        opacity: 1;
        transform: translateY(-100px) scaleY(0);
      }
      20% {
        opacity: 1;
        transform: translateY(-50px) scaleY(1);
      }
      80% {
        opacity: 1;
        transform: translateY(150px) scaleY(1);
      }
      100% { 
        opacity: 0;
        transform: translateY(250px) scaleY(0.5);
      }
    }
    
    .confetti-flower {
      animation: flowerFall 3s ease-out forwards;
    }
    
    @keyframes flowerFall {
      0% { 
        opacity: 1;
        transform: translateY(-20px) rotate(0deg) scale(1);
      }
      100% { 
        opacity: 0;
        transform: translateY(200px) rotate(360deg) scale(0.8);
      }
    }
    
    .confetti-wave {
      animation: waveMotion 2.5s ease-out forwards;
    }
    
    @keyframes waveMotion {
      0% { 
        opacity: 1;
        transform: translateY(-20px) translateX(0);
      }
      25% {
        transform: translateY(20px) translateX(30px);
      }
      50% {
        transform: translateY(80px) translateX(-30px);
      }
      75% {
        transform: translateY(140px) translateX(15px);
      }
      100% { 
        opacity: 0;
        transform: translateY(200px) translateX(0);
      }
    }
    
    .confetti-pixel {
      animation: pixelDrop 2s ease-out forwards;
    }
    
    @keyframes pixelDrop {
      0% { 
        opacity: 1;
        transform: translateY(-20px);
      }
      100% { 
        opacity: 0;
        transform: translateY(200px);
      }
    }
    
    .confetti-aurora {
      animation: auroraWave 4s ease-out forwards;
    }
    
    @keyframes auroraWave {
      0% { 
        opacity: 0;
        transform: translateY(-20px) translateX(-50px) rotate(0deg);
      }
      25% {
        opacity: 0.8;
        transform: translateY(50px) translateX(0) rotate(90deg);
      }
      50% {
        opacity: 1;
        transform: translateY(120px) translateX(50px) rotate(180deg);
      }
      75% {
        opacity: 0.6;
        transform: translateY(170px) translateX(0) rotate(270deg);
      }
      100% { 
        opacity: 0;
        transform: translateY(200px) translateX(-50px) rotate(360deg);
      }
    }
    
    .confetti-tornado {
      animation: tornadoSpin 2s ease-out forwards;
    }
    
    @keyframes tornadoSpin {
      0% { 
        opacity: 1;
        transform: translateY(-20px) rotate(0deg) translateX(0);
      }
      100% { 
        opacity: 0;
        transform: translateY(200px) rotate(1440deg) translateX(100px);
      }
    }
    
    .confetti-magic {
      animation: magicSparkle 2.5s ease-out forwards;
    }
    
    @keyframes magicSparkle {
      0% { 
        opacity: 0;
        transform: translateY(-20px) scale(0) rotate(0deg);
      }
      25% {
        opacity: 1;
        transform: translateY(30px) scale(1.5) rotate(180deg);
      }
      50% {
        opacity: 0.5;
        transform: translateY(100px) scale(0.8) rotate(360deg);
      }
      75% {
        opacity: 1;
        transform: translateY(150px) scale(1.2) rotate(540deg);
      }
      100% { 
        opacity: 0;
        transform: translateY(200px) scale(0.5) rotate(720deg);
      }
    }
    
    .confetti-retro {
      animation: retroBounce 2s ease-out forwards;
    }
    
    @keyframes retroBounce {
      0% { 
        opacity: 1;
        transform: translateY(-20px);
      }
      25% {
        transform: translateY(0);
      }
      50% {
        transform: translateY(-50px);
      }
      75% {
        transform: translateY(50px);
      }
      100% { 
        opacity: 0;
        transform: translateY(200px);
      }
    }
    
    .confetti-disco {
      animation: discoFever 2s ease-out forwards;
    }
    
    @keyframes discoFever {
      0% { 
        opacity: 1;
        transform: translateY(-20px) rotate(0deg) scale(1);
      }
      25% {
        transform: translateY(30px) rotate(90deg) scale(1.3);
      }
      50% {
        transform: translateY(80px) rotate(180deg) scale(0.8);
      }
      75% {
        transform: translateY(130px) rotate(270deg) scale(1.2);
      }
      100% { 
        opacity: 0;
        transform: translateY(200px) rotate(360deg) scale(0.5);
      }
    }
    
    .confetti-zen {
      animation: zenFall 3s ease-out forwards;
    }
    
    @keyframes zenFall {
      0% { 
        opacity: 0.6;
        transform: translateY(-20px);
      }
      100% { 
        opacity: 0;
        transform: translateY(200px);
      }
    }
    
    .confetti-carnival {
      animation: carnivalBounce 2.5s ease-out forwards;
    }
    
    @keyframes carnivalBounce {
      0% { 
        opacity: 1;
        transform: translateY(-20px) scale(1);
      }
      25% {
        transform: translateY(20px) scale(1.5);
      }
      50% {
        transform: translateY(60px) scale(0.8);
      }
      75% {
        transform: translateY(120px) scale(1.3);
      }
      100% { 
        opacity: 0;
        transform: translateY(200px) scale(0.5);
      }
    }
    
    .confetti-cyber {
      animation: cyberGlitch 2s ease-out forwards;
    }
    
    @keyframes cyberGlitch {
      0% { 
        opacity: 1;
        transform: translateY(-20px) translateX(0);
      }
      20% {
        transform: translateY(10px) translateX(5px);
      }
      40% {
        transform: translateY(50px) translateX(-3px);
      }
      60% {
        transform: translateY(100px) translateX(7px);
      }
      80% {
        transform: translateY(150px) translateX(-2px);
      }
      100% { 
        opacity: 0;
        transform: translateY(200px) translateX(0);
      }
    }
    
    .confetti-nature {
      animation: natureFall 3s ease-out forwards;
    }
    
    @keyframes natureFall {
      0% { 
        opacity: 1;
        transform: translateY(-20px) rotate(0deg);
      }
      100% { 
        opacity: 0;
        transform: translateY(200px) rotate(180deg);
      }
    }
    
    .confetti-space {
      animation: spaceFloat 3s ease-out forwards;
    }
    
    @keyframes spaceFloat {
      0% { 
        opacity: 0;
        transform: translateY(-20px) scale(0);
      }
      25% {
        opacity: 1;
        transform: translateY(50px) scale(1.2);
      }
      75% {
        opacity: 1;
        transform: translateY(150px) scale(1);
      }
      100% { 
        opacity: 0;
        transform: translateY(250px) scale(0.3);
      }
    }
    
    .confetti-golden {
      animation: goldenShower 2.5s ease-out forwards;
    }
    
    @keyframes goldenShower {
      0% { 
        opacity: 1;
        transform: translateY(-20px) scale(1) rotate(0deg);
      }
      100% { 
        opacity: 0;
        transform: translateY(200px) scale(0.8) rotate(360deg);
      }
    }
    
    .celebration-text {
      animation: celebrationBounce 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    @keyframes celebrationBounce {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.3); }
    }
    
    .coin-float {
      position: absolute;
      pointer-events: none;
      font-size: 32px;
      animation: coinFloat 1.5s ease-out forwards;
      z-index: 1000;
    }
    
    @keyframes coinFloat {
      0% { 
        opacity: 1;
        transform: translateY(0) scale(0);
      }
      50% {
        transform: translateY(-80px) scale(1.2);
      }
      100% { 
        opacity: 0;
        transform: translateY(-120px) scale(0.8);
      }
    }
    
    .coin-pulse {
      animation: coinPulse 0.5s ease;
    }
    
    @keyframes coinPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.3); }
    }
    
    .shake-animation {
      animation: shake 0.5s ease;
    }
    
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-10px); }
      75% { transform: translateX(10px); }
    }
    
    .frozen-square {
      animation: frozenPulse 1s ease-in-out infinite;
      box-shadow: inset 0 0 0 4px rgba(96, 165, 250, 0.8) !important;
    }
    
    @keyframes frozenPulse {
      0%, 100% { 
        box-shadow: inset 0 0 0 4px rgba(96, 165, 250, 0.8);
      }
      50% { 
        box-shadow: inset 0 0 0 4px rgba(96, 165, 250, 1), 
                    0 0 20px rgba(96, 165, 250, 0.6);
      }
    }
    
    .teleport-mode {
      box-shadow: inset 0 0 0 4px rgba(168, 85, 247, 0.8) !important;
      animation: teleportPulse 0.8s ease-in-out infinite;
    }
    
    @keyframes teleportPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    
    .lightning-target {
      box-shadow: inset 0 0 0 4px rgba(251, 191, 36, 0.8) !important;
      animation: lightningPulse 0.6s ease-in-out infinite;
    }
    
    @keyframes lightningPulse {
      0%, 100% { 
        box-shadow: inset 0 0 0 4px rgba(251, 191, 36, 0.8);
        transform: scale(1);
      }
      50% { 
        box-shadow: inset 0 0 0 4px rgba(251, 191, 36, 1), 
                    0 0 20px rgba(251, 191, 36, 0.6);
        transform: scale(1.05);
      }
    }
    
    .powerup-btn {
      padding: 8px 12px;
      border-radius: 8px;
      font-weight: 600;
      border: none;
      font-size: 12px;
      cursor: not-allowed;
      transition: all 0.2s;
      background: #3b82f6;
      color: #ffffff;
      opacity: 0.5;
    }
    
    .powerup-btn.available {
      opacity: 1;
      cursor: pointer;
    }
    
    .powerup-btn.available:hover {
      background: #2563eb;
    }
    
    button {
      transition: all 0.2s;
    }
    
    button:hover:not(:disabled) {
      transform: translateY(-1px);
      filter: brightness(1.1);
    }
    
    button:active:not(:disabled) {
      transform: translateY(0);
    }
    
    /* Button color hover effects */
    button[style*="background: #3b82f6"]:hover {
      background: #2563eb !important;
    }
    
    button[style*="background: #9333ea"]:hover {
      background: #7e22ce !important;
    }
    
    button[style*="background: #10b981"]:hover {
      background: #059669 !important;
    }
    
    button[style*="background: #4b5563"]:hover {
      background: #374151 !important;
    }
    
    button[style*="background: #6b7280"]:hover {
      background: #4b5563 !important;
    }
    
    .connection-status {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-left: 8px;
      animation: pulse 2s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
  </style>
  <script>
    // Notification system for sandboxed environments (replaces alert/confirm)
    function showGameMessage(message, type = 'info') {
      // Create notification element
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: ${type === 'error' ? '#ef4444' : type === 'success' ? '#10b981' : '#3b82f6'};
        color: white;
        padding: 20px 30px;
        border-radius: 12px;
        font-weight: bold;
        font-size: 16px;
        z-index: 10000;
        box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        max-width: 400px;
        text-align: center;
        animation: modalSlideIn 0.3s ease;
      `;
      notification.textContent = message;
      
      // Add close button
      const closeBtn = document.createElement('button');
      closeBtn.textContent = 'OK';
      closeBtn.style.cssText = `
        margin-top: 15px;
        padding: 8px 20px;
        background: rgba(255,255,255,0.2);
        border: 1px solid rgba(255,255,255,0.3);
        border-radius: 6px;
        color: white;
        cursor: pointer;
        font-weight: bold;
      `;
      closeBtn.onclick = () => document.body.removeChild(notification);
      notification.appendChild(closeBtn);
      
      // Add to page
      document.body.appendChild(notification);
      
      // Auto-remove after 5 seconds
      setTimeout(() => {
        if (notification.parentNode) {
          document.body.removeChild(notification);
        }
      }, 5000);
    }
    
    // Safe alert replacement
    function safeAlert(message) {
      showGameMessage(message, 'info');
    }
    
    // Safe confirm replacement
    function safeConfirm(message, callback) {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #f59e0b;
        color: white;
        padding: 20px 30px;
        border-radius: 12px;
        font-weight: bold;
        font-size: 16px;
        z-index: 10000;
        box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        max-width: 400px;
        text-align: center;
        animation: modalSlideIn 0.3s ease;
      `;
      
      const messageDiv = document.createElement('div');
      messageDiv.textContent = message;
      messageDiv.style.marginBottom = '15px';
      notification.appendChild(messageDiv);
      
      const buttonContainer = document.createElement('div');
      buttonContainer.style.display = 'flex';
      buttonContainer.style.gap = '10px';
      buttonContainer.style.justifyContent = 'center';
      
      const yesBtn = document.createElement('button');
      yesBtn.textContent = 'Yes';
      yesBtn.style.cssText = `
        padding: 8px 20px;
        background: rgba(255,255,255,0.2);
        border: 1px solid rgba(255,255,255,0.3);
        border-radius: 6px;
        color: white;
        cursor: pointer;
        font-weight: bold;
      `;
      yesBtn.onclick = () => {
        document.body.removeChild(notification);
        if (callback) callback(true);
      };
      
      const noBtn = document.createElement('button');
      noBtn.textContent = 'No';
      noBtn.style.cssText = yesBtn.style.cssText;
      noBtn.onclick = () => {
        document.body.removeChild(notification);
        if (callback) callback(false);
      };
      
      buttonContainer.appendChild(yesBtn);
      buttonContainer.appendChild(noBtn);
      notification.appendChild(buttonContainer);
      
      document.body.appendChild(notification);
    }
    
  </script>
  <style>
    @keyframes modalSlideIn {
      from {
        opacity: 0;
        transform: translate(-50%, -60%);
      }
      to {
        opacity: 1;
        transform: translate(-50%, -50%);
      }
    }
    
    .splash-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      animation: splashFadeOut 0.8s ease 3.5s forwards;
    }
    
    @keyframes splashFadeOut {
      0% { opacity: 1; }
      100% { opacity: 0; pointer-events: none; }
    }
    
    .splash-logo {
      font-size: 120px;
      animation: logoFloat 2s ease-in-out infinite;
      margin-bottom: 20px;
    }
    
    @keyframes logoFloat {
      0%, 100% { transform: translateY(0px) rotate(0deg); }
      50% { transform: translateY(-20px) rotate(5deg); }
    }
    
    .splash-title {
      font-size: 64px;
      font-weight: bold;
      color: #ffffff;
      margin-bottom: 10px;
      animation: titleSlideIn 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      text-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }
    
    @keyframes titleSlideIn {
      0% { 
        opacity: 0;
        transform: translateY(-50px);
      }
      100% { 
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .splash-subtitle {
      font-size: 24px;
      color: rgba(255,255,255,0.9);
      margin-bottom: 40px;
      animation: subtitleFadeIn 1s ease 0.5s backwards;
    }
    
    @keyframes subtitleFadeIn {
      0% { opacity: 0; }
      100% { opacity: 1; }
    }
    
    .splash-made-by {
      font-size: 20px;
      color: rgba(255,255,255,0.8);
      margin-top: 40px;
      animation: madeByPulse 2s ease-in-out infinite;
    }
    
    @keyframes madeByPulse {
      0%, 100% { transform: scale(1); opacity: 0.8; }
      50% { transform: scale(1.1); opacity: 1; }
    }
    
    .loading-dots {
      display: flex;
      gap: 10px;
      margin-top: 30px;
    }
    
    .loading-dot {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #ffffff;
      animation: dotBounce 1.4s ease-in-out infinite;
    }
    
    .loading-dot:nth-child(1) {
      animation-delay: 0s;
    }
    
    .loading-dot:nth-child(2) {
      animation-delay: 0.2s;
    }
    
    .loading-dot:nth-child(3) {
      animation-delay: 0.4s;
    }
    
    @keyframes dotBounce {
      0%, 80%, 100% { 
        transform: translateY(0);
        opacity: 0.5;
      }
      40% { 
        transform: translateY(-20px);
        opacity: 1;
      }
    }
    
    .home-screen {
      animation: homeScreenFadeIn 0.8s ease 3.8s backwards;
    }
    
    @keyframes homeScreenFadeIn {
      0% { 
        opacity: 0;
        transform: scale(0.95);
      }
      100% { 
        opacity: 1;
        transform: scale(1);
      }
    }
    
    .chess-pieces-orbit {
      position: absolute;
      width: 300px;
      height: 300px;
      animation: rotate 20s linear infinite;
    }
    
    @keyframes rotate {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .orbit-piece {
      position: absolute;
      font-size: 40px;
      animation: orbitFloat 3s ease-in-out infinite;
    }
    
    .orbit-piece:nth-child(1) {
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      animation-delay: 0s;
    }
    
    .orbit-piece:nth-child(2) {
      top: 50%;
      right: 0;
      transform: translateY(-50%);
      animation-delay: 0.5s;
    }
    
    .orbit-piece:nth-child(3) {
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      animation-delay: 1s;
    }
    
    .orbit-piece:nth-child(4) {
      top: 50%;
      left: 0;
      transform: translateY(-50%);
      animation-delay: 1.5s;
    }
    
    @keyframes orbitFloat {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.3); }
    }
    
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-10px); }
      75% { transform: translateX(10px); }
    }

  </style>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-database-compat.js"></script>
 </head>
 <body class="h-full m-0 p-0" style="background: #1e293b;">
  <!-- Splash Screen -->
  <div class="splash-screen">
   <div class="chess-pieces-orbit">
    <div class="orbit-piece">‚ôî</div>
    <div class="orbit-piece">‚ôï</div>
    <div class="orbit-piece">‚ôñ</div>
    <div class="orbit-piece">‚ôò</div>
   </div>
   <div class="splash-logo">‚ôüÔ∏è</div>
   <div class="splash-title">Fun Chess</div>
   <div class="splash-subtitle">Multiplayer Edition üéÆ</div>
   <div class="loading-dots">
    <div class="loading-dot"></div>
    <div class="loading-dot"></div>
    <div class="loading-dot"></div>
   </div>
   <div class="splash-made-by">‚ú® Made by schoolfun4all ‚ú®</div>
  </div>
  
  <!-- Welcome Screen -->
  <div id="welcome-screen" class="fixed inset-0 flex items-center justify-center z-50" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
    <div class="text-center">
      <div class="mb-8">
        <div class="text-8xl mb-4 animate-bounce">‚ôüÔ∏è</div>
        <h1 class="text-6xl font-bold text-white mb-4">Fun Chess</h1>
        <p class="text-2xl text-white/80 mb-8">Multiplayer Edition üéÆ</p>
      </div>
      <button id="start-btn" class="px-12 py-6 bg-white text-purple-700 rounded-full text-2xl font-bold hover:scale-110 transition-transform shadow-2xl">
        üöÄ Start Game
      </button>
      <div class="mt-8 text-white/60">
        <p>‚ú® Made by schoolfun4all ‚ú®</p>
        <p class="text-xs mt-2">üêõ Report glitches: <a href="mailto:www.schoolfun4all@gmail.com" style="color: #60a5fa;">www.schoolfun4all@gmail.com</a></p>
      </div>
    </div>
  </div>
  
  <div id="app-wrapper" class="h-full w-full overflow-auto home-screen" style="display: none;">
   <main class="min-h-full flex flex-col items-center justify-center p-8">
    <div class="w-full max-w-3xl">
     <div class="flex justify-between items-center mb-6">
      <h1 id="game-title" class="text-center font-bold flex-1" style="color: #f1f5f9;">Fun Chess üéâ</h1>
      <div class="flex gap-2">
       <button id="fullscreen-btn" class="px-4 py-2 rounded-lg font-semibold transition-colors text-sm" style="background: #10b981; color: #ffffff;"> üñ•Ô∏è Fullscreen</button>
       <button id="help-btn" class="px-4 py-2 rounded-lg font-semibold transition-colors text-sm" style="background: #3b82f6; color: #ffffff;"> ‚ùì Help </button>
       <button id="admin-btn" class="px-4 py-2 rounded-lg font-semibold transition-colors text-sm" style="background: #4b5563; color: #ffffff;"> üîê Admin </button>
      </div>
     </div>
     <!-- Multiplayer status bar -->
     <div id="multiplayer-status" style="display: none; background: rgba(139, 92, 246, 0.2); padding: 12px; border-radius: 8px; margin-bottom: 16px; text-align: center;">
      <div style="font-weight: bold; margin-bottom: 4px;">
       <span id="room-code-display"></span>
       <span id="connection-indicator" class="connection-status" style="background: #10b981;"></span>
      </div>
      <div style="font-size: 14px; opacity: 0.9;">
       <span id="player-role"></span> ‚Ä¢ <span id="opponent-status"></span>
      </div>
     </div>
     <!-- Mode selection (shown initially) -->
     <div id="mode-selection" class="flex gap-4 justify-center mb-6">
      <button id="local-mode-btn" class="px-8 py-4 rounded-xl font-bold text-lg transition-colors" style="background: #3b82f6; color: #ffffff;"> üè† Local Game </button>
      <button id="ai-mode-btn" class="px-8 py-4 rounded-xl font-bold text-lg transition-colors" style="background: #10b981; color: #ffffff;"> ü§ñ AI Game </button>
      <button id="online-mode-btn" class="px-8 py-4 rounded-xl font-bold text-lg transition-colors" style="background: #9333ea; color: #ffffff;"> üåê Online Game </button>
     </div>
     <!-- Online game options (hidden initially) -->
     <div id="online-options" style="display: none;" class="flex gap-4 justify-center mb-6">
      <button id="host-game-btn" class="px-6 py-3 rounded-lg font-semibold transition-colors" style="background: #10b981; color: #ffffff;"> üéÆ Host Game </button>
      <button id="join-game-btn" class="px-6 py-3 rounded-lg font-semibold transition-colors" style="background: #3b82f6; color: #ffffff;"> üîó Join Game </button>
      <button id="public-lobby-btn" class="px-6 py-3 rounded-lg font-semibold transition-colors" style="background: #f59e0b; color: #ffffff;"> üåç Public Lobby </button>
      <button id="back-to-mode-btn" class="px-6 py-3 rounded-lg font-semibold transition-colors" style="background: #4b5563; color: #ffffff;"> ‚¨ÖÔ∏è Back </button>
     </div>
     <!-- Game area (hidden until mode selected) -->
     <div id="game-area" style="display: none;">
      <!-- Power-ups toggle -->
      <div class="flex justify-center gap-2 mb-2">
       <button id="toggle-powerups-btn" class="px-4 py-2 rounded-lg font-semibold transition-colors" style="background: #ef4444; color: #ffffff;"> ‚öîÔ∏è Hide Power-ups </button>
      </div>
      <!-- Power-ups section -->
      <div id="powerups-section" class="flex justify-center gap-2 mb-4 flex-wrap">
       <button id="undo-btn" class="powerup-btn"> ‚è™ (<span id="undo-count">0</span>) </button>
       <button id="hint-btn" class="powerup-btn"> üí° (<span id="hint-count">0</span>) </button>
       <button id="shield-btn" class="powerup-btn"> üõ° (<span id="shield-count">0</span>) </button>
       <button id="double-coins-btn" class="powerup-btn"> üí∞ (<span id="double-coins-count">0</span>) </button>
       <button id="freeze-btn" class="powerup-btn"> ‚ùÑ (<span id="freeze-count">0</span>) </button>
       <button id="knight-boost-btn" class="powerup-btn"> üê¥ (<span id="knight-boost-count">0</span>) </button>
       <button id="vision-btn" class="powerup-btn"> üëÅ (<span id="vision-count">0</span>) </button>
       <button id="swap-btn" class="powerup-btn"> üîÑ (<span id="swap-count">0</span>) </button>
       <button id="bomb-btn" class="powerup-btn"> üí£ (<span id="bomb-count">0</span>) </button>
       <button id="time-warp-btn" class="powerup-btn"> ‚è± (<span id="time-warp-count">0</span>) </button>
       
       <!-- NEW POWER-UP BUTTONS -->
       <button id="lightning-btn" class="powerup-btn"> ‚ö° (<span id="lightning-count">0</span>) </button>
       <button id="heal-btn" class="powerup-btn"> üíö (<span id="heal-count">0</span>) </button>
       <button id="clone-btn" class="powerup-btn"> üë• (<span id="clone-count">0</span>) </button>
       <button id="magnet-btn" class="powerup-btn"> üß≤ (<span id="magnet-count">0</span>) </button>
       <button id="poison-btn" class="powerup-btn"> ‚ò†Ô∏è (<span id="poison-count">0</span>) </button>
       <button id="shield-wall-btn" class="powerup-btn"> üè∞ (<span id="shield-wall-count">0</span>) </button>
       <button id="speed-boost-btn" class="powerup-btn"> üöÄ (<span id="speed-boost-count">0</span>) </button>
       <button id="invisibility-btn" class="powerup-btn"> üëª (<span id="invisibility-count">0</span>) </button>
       <button id="earthquake-btn" class="powerup-btn"> üåã (<span id="earthquake-count">0</span>) </button>
       <button id="blizzard-btn" class="powerup-btn"> üå®Ô∏è (<span id="blizzard-count">0</span>) </button>
       <button id="laser-btn" class="powerup-btn"> üî¥ (<span id="laser-count">0</span>) </button>
       <button id="mirror-btn" class="powerup-btn"> ü™û (<span id="mirror-count">0</span>) </button>
       <button id="tornado-btn" class="powerup-btn"> üå™Ô∏è (<span id="tornado-count">0</span>) </button>
       <button id="gravity-btn" class="powerup-btn"> üåç (<span id="gravity-count">0</span>) </button>
       <button id="phoenix-btn" class="powerup-btn"> üî• (<span id="phoenix-count">0</span>) </button>
       <button id="time-freeze-btn" class="powerup-btn"> ‚è∞ (<span id="time-freeze-count">0</span>) </button>
       <button id="coin-rain-btn" class="powerup-btn"> ü™ô (<span id="coin-rain-count">0</span>) </button>
       <button id="power-steal-btn" class="powerup-btn"> üé≠ (<span id="power-steal-count">0</span>) </button>
       <button id="mega-bomb-btn" class="powerup-btn"> üí• (<span id="mega-bomb-count">0</span>) </button>
       <button id="royal-guard-btn" class="powerup-btn"> ‚öîÔ∏è (<span id="royal-guard-count">0</span>) </button>
       <button id="lucky-charm-btn" class="powerup-btn"> üçÄ (<span id="lucky-charm-count">0</span>) </button>
       <button id="chaos-btn" class="powerup-btn"> üé≤ (<span id="chaos-count">0</span>) </button>
      </div>
      <div class="flex justify-between items-center mb-4 px-4">
       <div id="current-player" class="text-xl font-semibold"></div>
       <div class="flex items-center gap-4">
        <div id="coin-display" class="text-xl font-bold flex items-center gap-2" style="color: #f1f5f9;">
         <span>ü™ô</span>
         <span id="coin-count">0</span>
        </div>
        <button id="shop-btn" class="px-6 py-2 rounded-lg font-semibold transition-colors" style="background: #9333ea; color: #ffffff;">üõí Shop</button>
        <button id="reset-btn" class="px-6 py-2 rounded-lg font-semibold transition-colors" style="background: #3b82f6; color: #ffffff;">New Game</button>
        <button id="back-home-btn" class="px-6 py-2 rounded-lg font-semibold transition-colors" style="background: #6b7280; color: #ffffff;">üè† Home</button>
        <button id="end-game-btn" class="px-6 py-2 rounded-lg font-semibold transition-colors" style="background: #ef4444; color: #ffffff; display: none;">üî¥ End Game</button>
       </div>
      </div>
      <div class="flex justify-between items-center mb-4 px-4 text-lg" style="color: #f1f5f9;">
       <div id="white-captures" style="color: #f1f5f9;"></div>
       <div id="black-captures" style="color: #f1f5f9;"></div>
      </div>
      <div class="inline-block">
       <div class="flex">
        <div class="w-8"></div>
        <div id="top-labels" class="grid grid-cols-8 text-center font-semibold"></div>
        <div class="w-8"></div>
       </div>
       <div class="flex">
        <div id="left-labels" class="grid grid-rows-8 text-center font-semibold w-8" style="color: #f1f5f9;"></div>
        <div id="board" class="grid grid-cols-8 shadow-2xl"></div>
        <div id="right-labels" class="grid grid-rows-8 text-center font-semibold w-8" style="color: #f1f5f9;"></div>
       </div>
       <div class="flex">
        <div class="w-8"></div>
        <div id="bottom-labels" class="grid grid-cols-8 text-center font-semibold" style="color: #f1f5f9;"></div>
        <div class="w-8"></div>
       </div>
      </div>
      <div id="game-status" class="text-center mt-6 text-xl font-bold"></div>
      
      <!-- Timer and Chat Section -->
      <div id="online-features" style="display: none; margin-top: 20px;">
       <!-- Timer Display -->
       <div id="timer-section" style="background: rgba(255,255,255,0.1); padding: 16px; border-radius: 12px; margin-bottom: 16px;">
        <div style="display: flex; justify-content: space-between; align-items: center;">
         <div style="display: flex; gap: 20px;">
          <div style="text-align: center;">
           <div style="font-size: 12px; color: #94a3b8; margin-bottom: 4px;">‚ö™ White</div>
           <div id="white-timer" style="font-size: 24px; font-weight: bold; color: #f1f5f9; font-family: monospace;">10:00</div>
          </div>
          <div style="text-align: center;">
           <div style="font-size: 12px; color: #94a3b8; margin-bottom: 4px;">‚ö´ Black</div>
           <div id="black-timer" style="font-size: 24px; font-weight: bold; color: #f1f5f9; font-family: monospace;">10:00</div>
          </div>
         </div>
         <div style="display: flex; gap: 8px;">
          <button id="start-timer-btn" style="padding: 8px 16px; border-radius: 6px; background: #10b981; color: white; font-weight: bold; cursor: pointer; border: none; font-size: 14px;">‚ñ∂Ô∏è Start</button>
          <button id="pause-timer-btn" style="padding: 8px 16px; border-radius: 6px; background: #f59e0b; color: white; font-weight: bold; cursor: pointer; border: none; font-size: 14px; display: none;">‚è∏Ô∏è Pause</button>
          <button id="reset-timer-btn" style="padding: 8px 16px; border-radius: 6px; background: #ef4444; color: white; font-weight: bold; cursor: pointer; border: none; font-size: 14px;">üîÑ Reset</button>
         </div>
        </div>
       </div>
       
       <!-- Chat Section (Online Only) -->
       <div id="chat-section" style="display: none; background: rgba(255,255,255,0.1); padding: 16px; border-radius: 12px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
         <h3 style="font-size: 18px; font-weight: bold; color: #f1f5f9;">üí¨ Chat</h3>
         <button id="toggle-chat-btn" style="padding: 6px 12px; border-radius: 6px; background: #6b7280; color: white; font-weight: bold; cursor: pointer; border: none; font-size: 12px;">üìê</button>
        </div>
        <div id="chat-container" style="height: 200px; overflow-y: auto; background: rgba(0,0,0,0.3); padding: 12px; border-radius: 8px; margin-bottom: 12px;">
         <div id="chat-messages" style="font-size: 14px; color: #cbd5e1;">
          <div style="color: #64748b; font-style: italic;">Chat messages will appear here...</div>
         </div>
        </div>
        <div style="display: flex; gap: 8px;">
         <input type="text" id="chat-input" placeholder="Type a message..." style="flex: 1; padding: 8px 12px; border-radius: 6px; border: 2px solid #475569; background: #334155; color: #f1f5f9; font-size: 14px;" maxlength="200">
         <button id="send-chat-btn" style="padding: 8px 16px; border-radius: 6px; background: #3b82f6; color: white; font-weight: bold; cursor: pointer; border: none; font-size: 14px;">Send</button>
        </div>
       </div>
      </div>
     </div>
    </div>
   </main>
   
   <!-- Host Game Modal -->
   <div id="host-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 2000;">
    <div style="max-width: 500px; margin: 100px auto; background: #1e293b; border-radius: 16px; padding: 32px;">
     <h2 style="font-size: 28px; font-weight: bold; color: #f1f5f9; margin-bottom: 24px; text-align: center;">üéÆ Host New Game</h2>
     <div style="background: rgba(139, 92, 246, 0.2); padding: 20px; border-radius: 12px; margin-bottom: 24px; text-align: center;">
      <div style="font-size: 14px; color: #cbd5e1; margin-bottom: 8px;">Your Game Code:</div>
      <div id="generated-code" style="font-size: 36px; font-weight: bold; color: #f1f5f9; letter-spacing: 4px; font-family: monospace;"></div>
      <div style="font-size: 14px; color: #cbd5e1; margin-top: 8px;">Share this code with your opponent!</div>
     </div>
     <div style="margin-bottom: 24px;">
      <label style="display: block; margin-bottom: 8px; color: #f1f5f9; font-weight: 600;">Your Name:</label>
      <input type="text" id="host-name" placeholder="Enter your name" style="width: 100%; padding: 12px; border-radius: 8px; border: 2px solid #475569; background: #334155; color: #f1f5f9; font-size: 16px;">
     </div>
     <div style="margin-bottom: 24px;">
      <label style="display: block; margin-bottom: 8px; color: #f1f5f9; font-weight: 600;">Play as:</label>
      <div style="display: flex; gap: 12px;">
       <button id="host-white-btn" class="color-choice-btn" style="flex: 1; padding: 12px; border-radius: 8px; background: #f1f5f9; color: #1e293b; font-weight: bold; cursor: pointer; border: 3px solid #8b5cf6;"> ‚ö™ White </button>
       <button id="host-black-btn" class="color-choice-btn" style="flex: 1; padding: 12px; border-radius: 8px; background: #334155; color: #f1f5f9; font-weight: bold; cursor: pointer; border: 3px solid transparent;"> ‚ö´ Black </button>
      </div>
     </div>
     <div style="margin-bottom: 24px;">
      <label style="display: flex; align-items: center; gap: 12px; color: #f1f5f9; font-weight: 600; cursor: pointer;">
       <input type="checkbox" id="disable-powerups-checkbox" style="width: 20px; height: 20px; cursor: pointer;">
       <span>‚öîÔ∏è Disable Power-ups (Classic Chess Mode)</span>
      </label>
      <div style="font-size: 14px; color: #94a3b8; margin-top: 8px; margin-left: 32px;">When enabled, no power-ups will be available in this game room</div>
     </div>
     <div id="host-loading" style="display: none; text-align: center; padding: 20px; color: #cbd5e1;">
      <div style="font-size: 32px; margin-bottom: 12px;">‚è≥</div>
      <div>Waiting for opponent to join...</div>
     </div>
     <div style="display: flex; gap: 12px;">
      <button id="create-room-btn" style="flex: 1; padding: 12px; border-radius: 8px; background: #9333ea; color: #ffffff; font-weight: bold; cursor: pointer; border: none; font-size: 16px;"> Create Room </button>
      <button id="cancel-host-btn" style="flex: 1; padding: 12px; border-radius: 8px; background: #4b5563; color: #ffffff; font-weight: bold; cursor: pointer; border: none; font-size: 16px;"> Cancel </button>
     </div>
    </div>
   </div>
   
   <!-- Join Game Modal -->
   <div id="join-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 2000;">
    <div style="max-width: 500px; margin: 100px auto; background: #1e293b; border-radius: 16px; padding: 32px;">
     <h2 style="font-size: 28px; font-weight: bold; color: #f1f5f9; margin-bottom: 24px; text-align: center;">üîó Join Game</h2>
     <div style="margin-bottom: 24px;">
      <label style="display: block; margin-bottom: 8px; color: #f1f5f9; font-weight: 600;">Your Name:</label>
      <input type="text" id="join-name" placeholder="Enter your name" style="width: 100%; padding: 12px; border-radius: 8px; border: 2px solid #475569; background: #334155; color: #f1f5f9; font-size: 16px;">
     </div>
     <div style="margin-bottom: 24px;">
      <label style="display: block; margin-bottom: 8px; color: #f1f5f9; font-weight: 600;">Game Code:</label>
      <input type="text" id="join-code" placeholder="CHESS-XXXX" style="width: 100%; padding: 12px; border-radius: 8px; border: 2px solid #475569; background: #334155; color: #f1f5f9; font-size: 20px; text-align: center; letter-spacing: 2px; text-transform: uppercase; font-family: monospace;">
     </div>
     <div id="join-error" style="display: none; padding: 12px; background: rgba(239, 68, 68, 0.2); border-radius: 8px; color: #fca5a5; text-align: center; margin-bottom: 16px;">Room not found. Please check the code.</div>
     <div id="join-loading" style="display: none; text-align: center; padding: 20px; color: #cbd5e1; margin-bottom: 16px;">
      <div style="font-size: 32px; margin-bottom: 12px;">‚è≥</div>
      <div>Joining game...</div>
     </div>
     <div style="display: flex; gap: 12px;">
      <button id="join-room-btn" style="flex: 1; padding: 12px; border-radius: 8px; background: #10b981; color: #ffffff; font-weight: bold; cursor: pointer; border: none; font-size: 16px;"> Join Room </button>
      <button id="cancel-join-btn" style="flex: 1; padding: 12px; border-radius: 8px; background: #4b5563; color: #ffffff; font-weight: bold; cursor: pointer; border: none; font-size: 16px;"> Cancel </button>
     </div>
    </div>
   </div>
   
   <!-- Public Lobby Modal -->
    <div id="public-lobby-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 2000; justify-content: center; align-items: center;">
      <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; border-radius: 20px; text-align: center; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 20px 40px rgba(0,0,0,0.3);">
        <h2 style="color: white; margin-bottom: 20px; font-size: 28px;">üåç Global Public Lobby</h2>
        <p style="color: rgba(255,255,255,0.9); margin-bottom: 20px; font-size: 14px;">Join games from anywhere in the world! üåê</p>
        
        <!-- Create Game Section -->
        <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 15px; margin-bottom: 20px;">
          <h3 style="color: white; margin-bottom: 15px;">Create New Game</h3>
          
          <div style="margin-bottom: 15px;">
            <label style="color: white; display: block; margin-bottom: 8px;">Your Name:</label>
            <input type="text" id="public-player-name" placeholder="Enter your name" style="width: 100%; padding: 10px; border-radius: 8px; border: none; background: rgba(255,255,255,0.9);">
          </div>
          
          <div style="margin-bottom: 15px;">
            <label style="color: white; display: block; margin-bottom: 8px;">Game Name:</label>
            <input type="text" id="public-game-name" placeholder="My Chess Game" style="width: 100%; padding: 10px; border-radius: 8px; border: none; background: rgba(255,255,255,0.9);">
          </div>
          
          <div style="margin-bottom: 15px;">
            <label style="color: white; display: block; margin-bottom: 8px;">Power-ups:</label>
            <div style="display: flex; gap: 10px; justify-content: center;">
              <button id="create-powerups-on-btn" style="padding: 10px 20px; border-radius: 8px; border: none; background: #10b981; color: white; font-weight: bold; cursor: pointer;">‚ö° With Power-ups</button>
              <button id="create-powerups-off-btn" style="padding: 10px 20px; border-radius: 8px; border: none; background: #ef4444; color: white; font-weight: bold; cursor: pointer;">‚ôüÔ∏è Classic Chess</button>
            </div>
          </div>
          
          <button id="create-public-game-btn" style="width: 100%; padding: 12px; border-radius: 8px; border: none; background: #3b82f6; color: white; font-weight: bold; cursor: pointer; font-size: 16px;">üéÆ Create Public Game</button>
        </div>
        
        <!-- Join Game Section -->
        <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 15px;">
          <h3 style="color: white; margin-bottom: 15px;">Join Global Game</h3>
          
          <div style="margin-bottom: 15px;">
            <label style="color: white; display: block; margin-bottom: 8px;">Your Name:</label>
            <input type="text" id="join-player-name" placeholder="Enter your name" style="width: 100%; padding: 10px; border-radius: 8px; border: none; background: rgba(255,255,255,0.9);">
          </div>
          
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h3 style="color: white; margin-bottom: 0;">Available Games üåê</h3>
            <div style="display: flex; align-items: center; gap: 8px;">
              <div style="width: 8px; height: 8px; background: #10b981; border-radius: 50%; animation: pulse 2s infinite;"></div>
              <span style="color: rgba(255,255,255,0.8); font-size: 12px;">Live</span>
            </div>
          </div>
          <div id="public-games-list" style="max-height: 300px; overflow-y: auto; margin-bottom: 15px;">
            <p style="color: rgba(255,255,255,0.7);">Loading global games...</p>
          </div>
          <button id="refresh-games-btn" style="width: 100%; padding: 10px; border-radius: 8px; border: none; background: #6b7280; color: white; font-weight: bold; cursor: pointer;">üîÑ Refresh Games</button>
        </div>
        
        <div style="margin-top: 20px;">
          <button id="close-public-lobby-btn" style="padding: 10px 30px; border-radius: 8px; border: none; background: rgba(255,255,255,0.2); color: white; font-weight: bold; cursor: pointer;">‚ùå Close</button>
        </div>
      </div>
    </div>

    <!-- AI Difficulty Modal -->
   <div id="ai-difficulty-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 2000;">
    <div style="max-width: 500px; margin: 100px auto; background: #1e293b; border-radius: 16px; padding: 32px;">
     <h2 style="font-size: 28px; font-weight: bold; color: #f1f5f9; margin-bottom: 24px; text-align: center;">ü§ñ Choose AI Difficulty</h2>
     <div style="margin-bottom: 24px;">
      <div style="display: flex; flex-direction: column; gap: 12px;">
       <button id="ai-easy-btn" class="ai-difficulty-btn" style="padding: 16px; border-radius: 8px; background: #22c55e; color: white; font-weight: bold; cursor: pointer; border: none; font-size: 16px; text-align: left;">
        üü¢ Easy - Beginner friendly
       </button>
       <button id="ai-medium-btn" class="ai-difficulty-btn" style="padding: 16px; border-radius: 8px; background: #f59e0b; color: white; font-weight: bold; cursor: pointer; border: none; font-size: 16px; text-align: left;">
        üü° Medium - Balanced challenge
       </button>
       <button id="ai-hard-btn" class="ai-difficulty-btn" style="padding: 16px; border-radius: 8px; background: #ef4444; color: white; font-weight: bold; cursor: pointer; border: none; font-size: 16px; text-align: left;">
        üî¥ Hard - Expert level
       </button>
      </div>
     </div>
     <div style="display: flex; gap: 12px;">
      <button id="cancel-ai-btn" style="flex: 1; padding: 12px; border-radius: 8px; background: #4b5563; color: #ffffff; font-weight: bold; cursor: pointer; border: none; font-size: 16px;"> Cancel </button>
     </div>
    </div>
   </div>
   
   <!-- Help Modal -->
   <div id="help-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 2000; overflow-y: auto;">
    <div style="max-width: 700px; margin: 50px auto; background: #1e293b; border-radius: 16px; padding: 32px;">
     <!-- Sticky Header -->
     <div style="position: sticky; top: -32px; background: #1e293b; padding: 32px; margin: -32px -32px 24px -32px; border-radius: 16px 16px 0 0; z-index: 10; backdrop-filter: blur(10px);">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
       <h2 style="font-size: 32px; font-weight: bold; color: #f1f5f9;">‚ùì Help & Skin Key</h2>
       <button id="close-help" style="font-size: 32px; background: none; border: none; cursor: pointer; color: #f1f5f9;">√ó</button>
      </div>
     </div>
     
     <!-- Content Area -->
     <div id="help-content">
      <!-- Skin Key Section -->
      <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 12px; margin-bottom: 24px; backdrop-filter: blur(10px);">
       <h3 style="font-size: 24px; font-weight: bold; color: #f1f5f9; margin-bottom: 16px;">üé® Skin Key</h3>
       <div id="skin-key-display" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 16px;"></div>
      </div>
      <!-- How to Play Section -->
      <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 12px; margin-bottom: 24px; backdrop-filter: blur(10px);">
       <h3 style="font-size: 24px; font-weight: bold; color: #f1f5f9; margin-bottom: 16px;">‚ôü How to Play</h3>
       <div style="color: #cbd5e1; font-size: 16px; line-height: 1.8;">
        <p style="margin-bottom: 12px;"><strong style="color: #f1f5f9;">Basic Rules:</strong> Click a piece to select it, then click a highlighted square to move. Capture enemy pieces to earn coins!</p>
        <p style="margin-bottom: 12px;"><strong style="color: #f1f5f9;">Multiplayer:</strong> Host a game and share the code, or join with a friend's code. Take turns making moves!</p>
        <p style="margin-bottom: 12px;"><strong style="color: #f1f5f9;">Piece Movement:</strong></p>
        <ul style="list-style: disc; margin-left: 24px; margin-bottom: 12px;">
         <li><strong>King (‚ôî):</strong> Moves one square in any direction</li>
         <li><strong>Queen (‚ôï):</strong> Moves any distance in any direction</li>
         <li><strong>Rook (‚ôñ):</strong> Moves any distance horizontally or vertically</li>
         <li><strong>Bishop (‚ôó):</strong> Moves any distance diagonally</li>
         <li><strong>Knight (‚ôò):</strong> Moves in an L-shape (2+1 squares)</li>
         <li><strong>Pawn (‚ôô):</strong> Moves forward one square, captures diagonally</li>
        </ul>
        <p style="margin-bottom: 12px;"><strong style="color: #f1f5f9;">Earning Coins:</strong></p>
        <ul style="list-style: disc; margin-left: 24px; margin-bottom: 12px;">
         <li>Each move: ü™ô 1 coin</li>
         <li>Capture Pawn: ü™ô 5 coins</li>
         <li>Capture Knight/Bishop: ü™ô 12 coins</li>
         <li>Capture Rook: ü™ô 15 coins</li>
         <li>Capture Queen: ü™ô 20 coins</li>
         <li>Capture King: ü™ô 50 coins (Win!)</li>
        </ul>
       </div>
      </div>
      <!-- Power-ups Guide Section -->
      <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 12px; margin-bottom: 24px; backdrop-filter: blur(10px);">
       <h3 style="font-size: 24px; font-weight: bold; color: #f1f5f9; margin-bottom: 16px;">‚ö° Power-ups Guide</h3>
       <div id="powerups-guide" style="display: grid; gap: 12px; color: #cbd5e1; font-size: 14px;"></div>
      </div>
      <!-- Combos Guide Section -->
      <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 12px; backdrop-filter: blur(10px);">
       <h3 style="font-size: 24px; font-weight: bold; color: #f1f5f9; margin-bottom: 16px;">üî• Power-up Combos</h3>
       <div style="color: #cbd5e1; font-size: 16px; line-height: 1.8;">
        <p style="margin-bottom: 16px;"><strong style="color: #f1f5f9;">üéØ How to Create Combos:</strong> Use two power-ups within 5 seconds of each other to activate special combo effects!</p>
        
        <div style="display: grid; gap: 16px; margin-bottom: 16px;">
         <div style="background: rgba(59, 130, 246, 0.2); padding: 16px; border-radius: 8px; border-left: 4px solid #3b82f6;">
          <div style="font-size: 18px; font-weight: bold; color: #3b82f6; margin-bottom: 8px;">üõ°Ô∏èüí£ Bomb Shield</div>
          <div style="font-size: 14px; margin-bottom: 4px;"><strong>Combo:</strong> Shield + Bomb</div>
          <div style="font-size: 14px; opacity: 0.9;">Bomb explodes but you're protected from the damage!</div>
         </div>
         
         <div style="background: rgba(14, 165, 233, 0.2); padding: 16px; border-radius: 8px; border-left: 4px solid #0ea5e9;">
          <div style="font-size: 18px; font-weight: bold; color: #0ea5e9; margin-bottom: 8px;">‚ö°‚ùÑÔ∏è Electric Freeze</div>
          <div style="font-size: 14px; margin-bottom: 4px;"><strong>Combo:</strong> Lightning + Freeze</div>
          <div style="font-size: 14px; opacity: 0.9;">Lightning strikes frozen enemies for double damage!</div>
         </div>
         
         <div style="background: rgba(239, 68, 68, 0.2); padding: 16px; border-radius: 8px; border-left: 4px solid #ef4444;">
          <div style="font-size: 18px; font-weight: bold; color: #ef4444; margin-bottom: 8px;">üî¥üå™Ô∏è Laser Tornado</div>
          <div style="font-size: 14px; margin-bottom: 4px;"><strong>Combo:</strong> Laser + Tornado</div>
          <div style="font-size: 14px; opacity: 0.9;">Spinning laser beam destroys everything in its path!</div>
         </div>
         
         <div style="background: rgba(245, 158, 11, 0.2); padding: 16px; border-radius: 8px; border-left: 4px solid #f59e0b;">
          <div style="font-size: 18px; font-weight: bold; color: #f59e0b; margin-bottom: 8px;">üí•‚ö° Nuclear Strike</div>
          <div style="font-size: 14px; margin-bottom: 4px;"><strong>Combo:</strong> Mega Bomb + Lightning</div>
          <div style="font-size: 14px; opacity: 0.9;">Massive explosion with electrical storm!</div>
         </div>
         
         <div style="background: rgba(168, 85, 247, 0.2); padding: 16px; border-radius: 8px; border-left: 4px solid #a855f7;">
          <div style="font-size: 18px; font-weight: bold; color: #a855f7; margin-bottom: 8px;">üå™Ô∏èüõ°Ô∏è Tornado Shield</div>
          <div style="font-size: 14px; margin-bottom: 4px;"><strong>Combo:</strong> Tornado + Shield</div>
          <div style="font-size: 14px; opacity: 0.9;">Tornado surrounds you with protective winds!</div>
         </div>
         
         <div style="background: rgba(34, 197, 94, 0.2); padding: 16px; border-radius: 8px; border-left: 4px solid #22c55e;">
          <div style="font-size: 18px; font-weight: bold; color: #22c55e; margin-bottom: 8px;">üí∞üîÑ Coin Swap</div>
          <div style="font-size: 14px; margin-bottom: 4px;"><strong>Combo:</strong> Double Coins + Piece Swap</div>
          <div style="font-size: 14px; opacity: 0.9;">Swap positions with bonus coins!</div>
         </div>
         
         <div style="background: rgba(251, 191, 36, 0.2); padding: 16px; border-radius: 8px; border-left: 4px solid #fbbf24;">
          <div style="font-size: 18px; font-weight: bold; color: #fbbf24; margin-bottom: 8px;">‚ö°üî• Power Surge</div>
          <div style="font-size: 14px; margin-bottom: 4px;"><strong>Combo:</strong> Lightning + Phoenix</div>
          <div style="font-size: 14px; opacity: 0.9;">Electrical power surge for 2 turns!</div>
         </div>
         
         <div style="background: rgba(236, 72, 153, 0.2); padding: 16px; border-radius: 8px; border-left: 4px solid #ec4899;">
          <div style="font-size: 18px; font-weight: bold; color: #ec4899; margin-bottom: 8px;">‚ùÑÔ∏è‚è±Ô∏è Time Freeze</div>
          <div style="font-size: 14px; margin-bottom: 4px;"><strong>Combo:</strong> Freeze + Time Warp</div>
          <div style="font-size: 14px; opacity: 0.9;">Freeze time itself for 2 extra turns!</div>
         </div>
         
         <div style="background: rgba(20, 184, 166, 0.2); padding: 16px; border-radius: 8px; border-left: 4px solid #14b8a6;">
          <div style="font-size: 18px; font-weight: bold; color: #14b8a6; margin-bottom: 8px;">üè∞‚öîÔ∏è Fortress</div>
          <div style="font-size: 14px; margin-bottom: 4px;"><strong>Combo:</strong> Shield Wall + Royal Guard</div>
          <div style="font-size: 14px; opacity: 0.9;">Ultimate defense for 3 turns!</div>
         </div>
        </div>
        
        <p style="margin-top: 16px; font-size: 14px; opacity: 0.8;"><strong>üí° Pro Tip:</strong> Experiment with different power-up combinations to discover hidden synergies!</p>
       </div>
      </div>
     </div>
    </div>
   </div>
   
   <!-- Admin Login Modal -->
   <div id="admin-login-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 2000; overflow-y: auto;">
    <div style="max-width: 400px; margin: 100px auto; background: #1e293b; border-radius: 16px; padding: 32px;">
     <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
      <h2 style="font-size: 28px; font-weight: bold; color: #f1f5f9;">üîê Admin Login</h2>
      <button id="close-admin-login" style="font-size: 32px; background: none; border: none; cursor: pointer; color: #f1f5f9;">√ó</button>
     </div>
     <form id="admin-login-form" style="display: flex; flex-direction: column; gap: 16px;">
      <div>
       <label for="admin-password" style="display: block; margin-bottom: 8px; color: #f1f5f9; font-weight: 600;">Password:</label>
       <input type="password" id="admin-password" style="width: 100%; padding: 12px; border-radius: 8px; border: 2px solid #475569; background: #334155; color: #f1f5f9; font-size: 16px;" placeholder="Enter admin password">
      </div>
      <div id="login-error" style="display: none; padding: 12px; background: rgba(239, 68, 68, 0.2); border-radius: 8px; color: #fca5a5; text-align: center;">Incorrect password. Please try again.</div>
      <button type="submit" style="width: 100%; padding: 12px; border-radius: 8px; background: #9333ea; color: #ffffff; font-weight: bold; cursor: pointer; border: none; font-size: 16px;"> Login </button>
     </form>
    </div>
   </div>
   
   <!-- Quick Setup Modal -->
   <div id="quick-setup-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 3000;">
    <div style="max-width: 500px; margin: 100px auto; background: #1e293b; border-radius: 16px; padding: 32px;">
     <h2 style="font-size: 28px; font-weight: bold; color: #f1f5f9; margin-bottom: 24px; text-align: center;">üöÄ Quick Setup</h2>
     <div style="background: rgba(139, 92, 246, 0.2); padding: 20px; border-radius: 12px; margin-bottom: 24px;">
      <div style="font-size: 16px; color: #f1f5f9; margin-bottom: 12px;">üéÆ Play Online Multiplayer</div>
      <div style="font-size: 14px; color: #cbd5e1; margin-bottom: 16px;">Choose how you want to save your online games:</div>
      
      <div style="display: grid; gap: 12px;">
       <button id="use-firebase-btn" style="padding: 16px; border-radius: 8px; background: #10b981; color: #ffffff; font-weight: bold; cursor: pointer; border: none; text-align: left;">
        <div style="font-size: 16px; margin-bottom: 4px;">üî• Use Firebase (Recommended)</div>
        <div style="font-size: 12px; opacity: 0.9;">Free ‚Ä¢ Real-time sync ‚Ä¢ Reliable & Fast</div>
       </button>
      </div>
     </div>
     
     <div style="text-align: center;">
      <button id="skip-setup-btn" style="padding: 12px 24px; border-radius: 8px; background: #6b7280; color: #ffffff; font-weight: bold; cursor: pointer; border: none;">
       Play Offline Only
      </button>
     </div>
    </div>
   </div>
      <!-- Guest Joined Modal -->
    <div id="guest-joined-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 3000; justify-content: center; align-items: center;">
      <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 40px; border-radius: 20px; text-align: center; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5); max-width: 500px; width: 90%; border: 3px solid #8b5cf6;">
        <div style="font-size: 60px; margin-bottom: 20px;">üéÆ</div>
        <h2 style="color: white; margin: 0 0 20px 0; font-size: 32px; text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);">Player Joined!</h2>
        <p id="guest-joined-message" style="color: #e0e7ff; font-size: 20px; margin: 0 0 30px 0; line-height: 1.5;"></p>
        <div style="display: flex; gap: 15px; justify-content: center;">
          <button onclick="closeGuestJoinedModal()" style="background: #10b981; color: white; border: none; padding: 15px 30px; border-radius: 10px; font-size: 18px; font-weight: bold; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4);">
            Start Game! üöÄ
          </button>
        </div>
        <div style="margin-top: 20px; color: #e0e7ff; font-size: 14px; opacity: 0.8;">
          Get ready to play! Your opponent has joined the game.
        </div>
      </div>
    </div>
    
    <!-- Admin Panel Modal -->
   <div id="admin-panel-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 2000; overflow-y: auto;">
    <div style="max-width: 900px; margin: 50px auto; background: #1e293b; border-radius: 16px; padding: 32px; max-height: 90vh; overflow-y: auto;">
     <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
      <h2 style="font-size: 32px; font-weight: bold; color: #f1f5f9;">‚öôÔ∏è Admin Panel</h2>
      <button id="close-admin-panel" style="font-size: 32px; background: none; border: none; cursor: pointer; color: #f1f5f9;">√ó</button>
     </div>
     <div style="display: grid; gap: 24px;">
      <!-- Online Storage Configuration -->
      <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 12px; backdrop-filter: blur(10px);">
       <h3 style="font-size: 20px; font-weight: bold; color: #f1f5f9; margin-bottom: 16px;">üåê Online Storage Configuration</h3>
       <div style="display: grid; gap: 16px;">
        <div>
         <label for="storage-provider" style="display: block; margin-bottom: 8px; color: #f1f5f9; font-weight: 600;">Storage Provider:</label>
         <select id="storage-provider" style="width: 100%; padding: 12px; border-radius: 8px; border: 2px solid #475569; background: #334155; color: #f1f5f9; font-size: 16px;">
          <option value="firebase">üî• Firebase (Best - Real-time & Reliable)</option>
          <option value="jsonbin">üü¢ JSONBin.io (Free & Unlimited)</option>
          <option value="googlesheets">üîµ Google Sheets (Has Quota Limits)</option>
         </select>
        </div>
        
        <!-- Firebase Configuration -->
        <div id="firebase-config" style="display: grid; gap: 16px;">
         <div>
          <label for="admin-firebase-api-key" style="display: block; margin-bottom: 8px; color: #f1f5f9; font-weight: 600;">Firebase API Key:</label>
          <input type="text" id="admin-firebase-api-key" placeholder="Enter Firebase API key" value="AIzaSyDxajp6LvXTbYZn6RW0k7nx3z0Ua4MjK7o" style="width: 100%; padding: 12px; border-radius: 8px; border: 2px solid #475569; background: #334155; color: #f1f5f9; font-size: 16px;">
          <div style="font-size: 12px; color: #94a3b8; margin-top: 4px;">Get your API key from Firebase Console ‚Üí Project Settings</div>
         </div>
         <div>
          <label for="admin-firebase-database-url" style="display: block; margin-bottom: 8px; color: #f1f5f9; font-weight: 600;">Firebase Database URL:</label>
          <input type="text" id="admin-firebase-database-url" placeholder="Enter Firebase Database URL" value="https://my-chess-game-105dd-default-rtdb.firebaseio.com/" style="width: 100%; padding: 12px; border-radius: 8px; border: 2px solid #475569; background: #334155; color: #f1f5f9; font-size: 16px;">
          <div style="font-size: 12px; color: #94a3b8; margin-top: 4px;">Format: https://your-project-default-rtdb.firebaseio.com/</div>
         </div>
        </div>
        
        <!-- JSONBin Configuration -->
        <div id="jsonbin-config" style="display: none; gap: 16px;">
         <div>
          <label for="admin-jsonbin-key" style="display: block; margin-bottom: 8px; color: #f1f5f9; font-weight: 600;">JSONBin API Key:</label>
          <input type="text" id="admin-jsonbin-key" placeholder="Enter JSONBin API key" style="width: 100%; padding: 12px; border-radius: 8px; border: 2px solid #475569; background: #334155; color: #f1f5f9; font-size: 16px;">
          <div style="font-size: 12px; color: #94a3b8; margin-top: 4px;">Get your free API key from https://jsonbin.io</div>
         </div>
        </div>
        
        <!-- Google Sheets Configuration -->
        <div id="googlesheets-config" style="display: none; gap: 16px;">
         <div>
          <label for="admin-spreadsheet-id" style="display: block; margin-bottom: 8px; color: #f1f5f9; font-weight: 600;">Spreadsheet ID:</label>
          <input type="text" id="admin-spreadsheet-id" placeholder="Enter spreadsheet ID" style="width: 100%; padding: 12px; border-radius: 8px; border: 2px solid #475569; background: #334155; color: #f1f5f9; font-size: 16px;">
         </div>
         <div>
          <label for="admin-api-key" style="display: block; margin-bottom: 8px; color: #f1f5f9; font-weight: 600;">Google API Key:</label>
          <input type="text" id="admin-api-key" placeholder="Enter Google API key" style="width: 100%; padding: 12px; border-radius: 8px; border: 2px solid #475569; background: #334155; color: #f1f5f9; font-size: 16px;">
         </div>
        </div>
        
        <div style="display: flex; gap: 12px;">
         <button id="admin-save-config-btn" style="flex: 1; padding: 12px; border-radius: 8px; background: #10b981; color: #ffffff; font-weight: bold; cursor: pointer; border: none;"> Save Configuration </button>
         <button id="admin-setup-instructions-btn" style="flex: 1; padding: 12px; border-radius: 8px; background: #3b82f6; color: #ffffff; font-weight: bold; cursor: pointer; border: none;"> Setup Instructions </button>
        </div>
        <div id="admin-config-status" style="padding: 12px; border-radius: 8px; text-align: center; font-size: 14px;"></div>
       </div>
      </div>
      <!-- Active Games Monitor -->
      <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 12px; backdrop-filter: blur(10px);">
       <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
        <h3 style="font-size: 20px; font-weight: bold; color: #f1f5f9;">üéÆ Active Games Monitor</h3>
        <button id="refresh-games-btn" style="padding: 8px 16px; border-radius: 8px; background: #3b82f6; color: #ffffff; font-weight: bold; cursor: pointer; border: none;"> üîÑ Refresh </button>
       </div>
       <div id="active-games-list" style="max-height: 300px; overflow-y: auto;">
        <div style="text-align: center; color: #94a3b8; padding: 20px;">No active games</div>
       </div>
      </div>
      <!-- Public Games Management -->
      <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 12px; backdrop-filter: blur(10px);">
       <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
        <h3 style="font-size: 20px; font-weight: bold; color: #f1f5f9;">üåç Public Games Management</h3>
        <button id="admin-refresh-public-games-btn" style="padding: 8px 16px; border-radius: 8px; background: #f59e0b; color: #ffffff; font-weight: bold; cursor: pointer; border: none;"> üîÑ Refresh </button>
       </div>
       <div id="admin-public-games-list" style="max-height: 300px; overflow-y: auto;">
        <div style="text-align: center; color: #94a3b8; padding: 20px;">No public games available</div>
       </div>
       <div style="margin-top: 16px; display: flex; gap: 12px;">
        <button id="admin-close-all-games-btn" style="flex: 1; padding: 10px; border-radius: 8px; background: #ef4444; color: #ffffff; font-weight: bold; cursor: pointer; border: none;"> ‚ùå Close All Games</button>
        <button id="admin-clear-empty-games-btn" style="flex: 1; padding: 10px; border-radius: 8px; background: #f59e0b; color: #ffffff; font-weight: bold; cursor: pointer; border: none;"> üßπ Clear Empty Games</button>
       </div>
      </div>
      <!-- Game Updates Section -->
      <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 12px; backdrop-filter: blur(10px);">
       <h3 style="font-size: 20px; font-weight: bold; color: #f1f5f9; margin-bottom: 16px;">üîÑ Game Updates</h3>
       <div style="display: flex; gap: 12px; align-items: center; margin-bottom: 12px;">
        <input type="text" id="update-version" value="V7.4.1" placeholder="New version (e.g., V7.4.1)" style="flex: 1; padding: 10px; border-radius: 8px; border: 2px solid #475569; background: #334155; color: #f1f5f9; font-size: 16px;">
        <button id="update-all-games-btn" style="padding: 10px 20px; border-radius: 8px; background: #8b5cf6; color: #ffffff; font-weight: bold; cursor: pointer; border: none;"> üîÑ Update All Games</button>
       </div>
       <div style="display: flex; gap: 12px; align-items: center; margin-bottom: 12px;">
        <span style="flex: 1; padding: 10px; border-radius: 8px; background: #334155; color: #f1f5f9; font-size: 14px;">Current: <span id="current-version-display">V7.5.7</span></span>
        <button id="update-server-btn" style="padding: 10px 20px; border-radius: 8px; background: #10b981; color: #ffffff; font-weight: bold; cursor: pointer; border: none;"> üöÄ Update Server</button>
       </div>
       <div id="update-status" style="padding: 8px; border-radius: 6px; font-size: 12px; color: #94a3b8; text-align: center;">Enter version number and click to update all connected games</div>
      </div>
      <!-- Coins Section -->
      <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 12px; backdrop-filter: blur(10px);">
       <h3 style="font-size: 20px; font-weight: bold; color: #f1f5f9; margin-bottom: 16px;">üí∞ Coin Management</h3>
       <div style="display: flex; gap: 12px; align-items: center; margin-bottom: 12px;">
        <input type="number" id="coin-amount" value="100" min="1" style="flex: 1; padding: 10px; border-radius: 8px; border: 2px solid #475569; background: #334155; color: #f1f5f9; font-size: 16px;">
        <button id="add-coins-btn" style="padding: 10px 20px; border-radius: 8px; background: #10b981; color: #ffffff; font-weight: bold; cursor: pointer; border: none;"> Add Coins </button>
       </div>
       <button id="reset-coins-btn" style="width: 100%; padding: 10px; border-radius: 8px; background: #ef4444; color: #ffffff; font-weight: bold; cursor: pointer; border: none;"> Reset Coins to 0 </button>
      </div>
      <!-- Power-ups Section -->
      <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 12px; max-height: 400px; overflow-y: auto;">
       <h3 style="font-size: 20px; font-weight: bold; color: #f1f5f9; margin-bottom: 16px;">‚ö° Power-up Management</h3>
       <div style="display: grid; gap: 12px;" id="admin-powerups-list"></div>
      </div>
      <!-- Manual Save Section -->
      <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 12px; backdrop-filter: blur(10px);">
       <h3 style="font-size: 20px; font-weight: bold; color: #f1f5f9; margin-bottom: 16px;">üíæ Manual Save</h3>
       <div style="display: grid; gap: 12px;">
        <button id="force-save-btn" style="width: 100%; padding: 12px; border-radius: 8px; background: #10b981; color: #ffffff; font-weight: bold; cursor: pointer; border: none; transition: all 0.2s;"> üíæ FORCE SAVE ALL DATA</button>
        <button id="force-load-btn" style="width: 100%; padding: 12px; border-radius: 8px; background: #3b82f6; color: #ffffff; font-weight: bold; cursor: pointer; border: none; transition: all 0.2s;"> üì• FORCE LOAD ALL DATA</button>
        <button id="clear-storage-btn" style="width: 100%; padding: 12px; border-radius: 8px; background: #ef4444; color: #ffffff; font-weight: bold; cursor: pointer; border: none; transition: all 0.2s;"> üóëÔ∏è CLEAR ALL LOCAL DATA</button>
       </div>
       <div id="save-status" style="margin-top: 12px; padding: 8px; border-radius: 6px; font-size: 12px; text-align: center; display: none;"></div>
      </div>
      <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 12px; backdrop-filter: blur(10px);">
       <h3 style="font-size: 20px; font-weight: bold; color: #f1f5f9; margin-bottom: 16px;">üîì Unlock Everything</h3>
       <div style="display: grid; gap: 12px;">
        <button id="unlock-skins-btn" style="width: 100%; padding: 12px; border-radius: 8px; background: #9333ea; color: #ffffff; font-weight: bold; cursor: pointer; border: none; transition: all 0.2s;"> Unlock All Skins </button>
        <button id="unlock-themes-btn" style="width: 100%; padding: 12px; border-radius: 8px; background: #9333ea; color: #ffffff; font-weight: bold; cursor: pointer; border: none; transition: all 0.2s;"> Unlock All Themes </button>
        <button id="unlock-effects-btn" style="width: 100%; padding: 12px; border-radius: 8px; background: #9333ea; color: #ffffff; font-weight: bold; cursor: pointer; border: none; transition: all 0.2s;"> Unlock All Effects </button>
        <button id="unlock-all-btn" style="width: 100%; padding: 12px; border-radius: 8px; background: #f59e0b; color: #ffffff; font-weight: bold; cursor: pointer; border: none; transition: all 0.2s;"> üîì UNLOCK EVERYTHING </button>
       </div>
      </div>
     </div>
    </div>
   </div>
   
   <!-- Shop Modal -->
   <div id="shop-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; overflow-y: auto;">
    <div style="max-width: 600px; margin: 50px auto; background: #1e293b; border-radius: 16px; padding: 32px;">
     <!-- Sticky Header -->
     <div style="position: sticky; top: -32px; background: #1e293b; padding: 32px; margin: -32px -32px 24px -32px; border-radius: 16px 16px 0 0; z-index: 10; backdrop-filter: blur(10px);">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
       <h2 id="shop-title" style="font-size: 32px; font-weight: bold; color: #f1f5f9;">üõí Chess Shop</h2>
       <button id="close-shop" style="font-size: 32px; background: none; border: none; cursor: pointer; color: #f1f5f9;">√ó</button>
      </div>
      <div style="margin-bottom: 16px; padding: 16px; background: rgba(59, 130, 246, 0.2); border-radius: 8px; backdrop-filter: blur(10px);">
       <div id="shop-coins" style="font-size: 24px; font-weight: bold; color: #f1f5f9; text-align: center;">
        ü™ô Your Coins: <span id="shop-coin-count">0</span>
       </div>
      </div>
      <!-- Search Bar -->
      <div style="margin-bottom: 16px;">
       <input type="text" id="shop-search" placeholder="üîç Search items... (Press Enter to search)" style="width: 100%; padding: 12px 16px; border-radius: 8px; border: 2px solid #475569; background: #334155; color: #f1f5f9; font-size: 16px;" />
      </div>
     </div>
     
     <!-- Content Area -->
     <div id="shop-content">
      <h3 style="font-size: 28px; font-weight: bold; color: #f1f5f9; margin-bottom: 16px; background: linear-gradient(135deg, #f59e0b, #ef4444); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">üéÅ COMPLETE BUNDLES</h3>
      <div id="bundles-container" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 20px; margin-bottom: 32px;"></div>
      <h3 style="font-size: 24px; font-weight: bold; color: #f1f5f9; margin-bottom: 16px;">‚ö° Power-Ups</h3>
      <div id="powerups-container" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 16px; margin-bottom: 32px;"></div>
      <h3 id="skins-header" style="font-size: 24px; font-weight: bold; color: #f1f5f9; margin-bottom: 16px;">üé® Piece Skins</h3>
      <div id="skins-container" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 16px; margin-bottom: 32px;"></div>
      <h3 id="themes-header" style="font-size: 24px; font-weight: bold; color: #f1f5f9; margin-bottom: 16px;">üé® Board Themes</h3>
      <div id="themes-container" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 16px; margin-bottom: 32px;"></div>
      <h3 id="effects-header" style="font-size: 24px; font-weight: bold; color: #f1f5f9; margin-bottom: 16px;">‚ú® Special Effects</h3>
      <div id="effects-container" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 16px; margin-bottom: 32px;"></div>
      <h3 id="soundpacks-header" style="font-size: 24px; font-weight: bold; color: #f1f5f9; margin-bottom: 16px;">üîä Sound Packs</h3>
      <div id="soundpacks-container" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 16px;"></div>
     </div>
    </div>
   </div>
  </div>
  
  <!-- Admin Authentication Modal -->
  <div id="adminAuthModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000; justify-content: center; align-items: center;">
    <div style="background: linear-gradient(135deg, #1e293b, #334155); padding: 32px; border-radius: 16px; box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(10px); max-width: 400px; width: 90%;">
      <h2 style="color: #f1f5f9; margin-bottom: 24px; text-align: center; font-size: 24px;">üîê Admin Authentication</h2>
      <p style="color: #cbd5e1; margin-bottom: 20px; text-align: center; font-size: 14px;">Enter admin key to access protected functions</p>
      <input type="password" id="adminKeyInput" placeholder="Enter admin key..." style="width: 100%; padding: 12px; border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; background: rgba(255,255,255,0.1); color: #f1f5f9; font-size: 16px; margin-bottom: 16px; box-sizing: border-box;">
      <div style="display: flex; gap: 12px;">
        <button onclick="authenticateAdmin()" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #10b981, #059669); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: 600;">Authenticate</button>
        <button onclick="closeAdminAuth()" style="flex: 1; padding: 12px; background: rgba(255,255,255,0.1); color: #f1f5f9; border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; cursor: pointer; font-size: 16px;">Cancel</button>
      </div>
      <p style="color: #ef4444; margin-top: 12px; text-align: center; font-size: 12px; display: none;" id="authError">Invalid admin key!</p>
    </div>
  </div>
  
  <script>
    // Version Constants - Must be defined first
    const GAME_VERSION = '7.6.1';
    const CURRENT_VERSION = 'V7.6.1';
    
    // Code Protection System
    const ADMIN_KEY = 'Spots2019';
    const ALLOWED_DOMAINS = ['localhost', '127.0.0.1', 'file:///C:/Users/rober/Downloads/Fun%20Chess%20V7.html']; // Add your web domain here, e.g., 'your-site.netlify.app'
    let isAuthenticated = false;
    
    // Check if user is authenticated
    function checkAuthentication() {
      const storedAuth = localStorage.getItem('chessAdminAuth');
      const isFileProtocol = window.location.protocol === 'file:';
      
      // File:// users are automatically allowed for playing (but not for protected functions)
      if (isFileProtocol) {
        console.log('üìÅ File:// protocol detected - access allowed');
        return storedAuth === ADMIN_KEY; // Only return true if authenticated for protected functions
      }
      
      // Web users: check domain whitelist
      const currentDomain = window.location.hostname;
      if (!ALLOWED_DOMAINS.includes(currentDomain)) {
        console.warn('üö´ Unauthorized domain detected:', currentDomain);
        return false;
      }
      
      // Check authentication for web users
      if (storedAuth === ADMIN_KEY) {
        isAuthenticated = true;
        console.log('‚úÖ Admin authenticated');
        return true;
      }
      
      return false;
    }
    
    // Check authentication without showing modal (for initial load)
    function checkAuthenticationSilent() {
      const storedAuth = localStorage.getItem('chessAdminAuth');
      const isFileProtocol = window.location.protocol === 'file:';
      
      // File:// users are automatically allowed for playing (but not for protected functions)
      if (isFileProtocol) {
        return storedAuth === ADMIN_KEY; // Only return true if authenticated for protected functions
      }
      
      // Web users: check domain whitelist
      const currentDomain = window.location.hostname;
      if (!ALLOWED_DOMAINS.includes(currentDomain)) {
        console.warn('üö´ Unauthorized domain detected:', currentDomain);
        return false;
      }
      
      // Check authentication for web users
      if (storedAuth === ADMIN_KEY) {
        isAuthenticated = true;
        return true;
      }
      
      return false;
    }
    
    // Show admin authentication modal
    function showAdminAuthModal() {
      document.getElementById('adminAuthModal').style.display = 'flex';
      document.getElementById('adminKeyInput').value = '';
      document.getElementById('authError').style.display = 'none';
      document.getElementById('adminKeyInput').focus();
    }
    
    // Close admin authentication modal
    function closeAdminAuth() {
      document.getElementById('adminAuthModal').style.display = 'none';
    }
    
    // Authenticate admin
    function authenticateAdmin() {
      const inputKey = document.getElementById('adminKeyInput').value;
      if (inputKey === ADMIN_KEY) {
        localStorage.setItem('chessAdminAuth', ADMIN_KEY);
        isAuthenticated = true;
        closeAdminAuth();
        console.log('‚úÖ Admin authenticated successfully');
        // Retry the last attempted action
        if (window.pendingProtectedAction) {
          window.pendingProtectedAction();
          window.pendingProtectedAction = null;
        }
      } else {
        document.getElementById('authError').style.display = 'block';
        document.getElementById('adminKeyInput').value = '';
        setTimeout(() => {
          document.getElementById('authError').style.display = 'none';
        }, 3000);
      }
    }
    
    // Protect critical functions
    function protectFunction(funcName, originalFunc) {
      return function(...args) {
        if (!checkAuthentication()) {
          console.warn('üö´ Unauthorized access attempt to:', funcName);
          showAdminAuthModal();
          // Store the action to retry after authentication
          window.pendingProtectedAction = () => originalFunc.apply(this, args);
          return false;
        }
        return originalFunc.apply(this, args);
      };
    }
    
    // Handle Enter key in admin auth modal
    document.addEventListener('DOMContentLoaded', function() {
      const adminInput = document.getElementById('adminKeyInput');
      if (adminInput) {
        adminInput.addEventListener('keypress', function(e) {
          if (e.key === 'Enter') {
            authenticateAdmin();
          }
        });
      }
    });
    
    // Obfuscate version constants
    const _v = () => atob('Vi43LjUuOA=='); // V7.6.1 in base64
    const _gv = () => atob('Ny41Ljg=');   // 7.6.1 in base64
    
    // Sound Effects System - Unique sounds for each action
    const sounds = {
      buttonClick: 'data:audio/wav;base64,UklGRiQCAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQACAADw/wAA8P8AAAD/AP8A',
      move: 'data:audio/wav;base64,UklGRiQCAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQACAADw/wAA8P8AAAD/AP8A',
      capture: 'data:audio/wav;base64,UklGRiQCAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQACAADw/wAA8P8AAAD/AP8A',
      promotion: 'data:audio/wav;base64,UklGRiQCAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQACAADw/wAA8P8AAAD/AP8A',
      coins: 'data:audio/wav;base64,UklGRiQCAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQACAADw/wAA8P8AAAD/AP8A',
      powerUp: 'data:audio/wav;base64,UklGRiQCAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQACAADw/wAA8P8AAAD/AP8A',
      check: 'data:audio/wav;base64,UklGRiQCAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQACAADw/wAA8P8AAAD/AP8A',
      gameOver: 'data:audio/wav;base64,UklGRiQCAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQACAADw/wAA8P8AAAD/AP8A',
      modalOpen: 'data:audio/wav;base64,UklGRiQCAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQACAADw/wAA8P8AAAD/AP8A',
      modalClose: 'data:audio/wav;base64,UklGRiQCAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQACAADw/wAA8P8AAAD/AP8A',
      select: 'data:audio/wav;base64,UklGRiQCAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQACAADw/wAA8P8AAAD/AP8A',
      error: 'data:audio/wav;base64,UklGRiQCAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQACAADw/wAA8P8AAAD/AP8A',
      shop: 'data:audio/wav;base64,UklGRiQCAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQACAADw/wAA8P8AAAD/AP8A',
      buy: 'data:audio/wav;base64,UklGRiQCAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQACAADw/wAA8P8AAAD/AP8A',
      // New sounds for loading and home screen
      welcome: 'data:audio/wav;base64,UklGRiQCAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQACAADw/wAA8P8AAAD/AP8A',
      loading: 'data:audio/wav;base64,UklGRiQCAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQACAADw/wAA8P8AAAD/AP8A',
      roomCreated: 'data:audio/wav;base64,UklGRiQCAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQACAADw/wAA8P8AAAD/AP8A',
      roomJoined: 'data:audio/wav;base64,UklGRiQCAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQACAADw/wAA8P8AAAD/AP8A'
    };
    
    function playSound(soundName) {
      try {
        const audio = new Audio(sounds[soundName]);
        audio.volume = 0.3;
        audio.play().catch(e => console.log('Sound play failed:', e));
      } catch (e) {
        console.log('Sound system error:', e);
      }
    }
    
    // Enhanced sound effect functions
    function playButtonSound() { playSound('buttonClick'); }
    function playMoveSound() { playSound('move'); }
    function playCaptureSound() { playSound('capture'); }
    function playPromotionSound() { playSound('promotion'); }
    function playCoinsSound() { playSound('coins'); }
    function playPowerUpSound() { playSound('powerUp'); }
    function playCheckSound() { playSound('check'); }
    function playGameOverSound() { playSound('gameOver'); }
    function playModalOpenSound() { playSound('modalOpen'); }
    function playModalCloseSound() { playSound('modalClose'); }
    function playSelectSound() { playSound('select'); }
    function playErrorSound() { playSound('error'); }
    function playShopSound() { playSound('shop'); }
    function playBuySound() { playSound('buy'); }
    // New sound functions
    function playWelcomeSound() { playSound('welcome'); }
    function playLoadingSound() { playSound('loading'); }
    function playRoomCreatedSound() { playSound('roomCreated'); }
    function playRoomJoinedSound() { playSound('roomJoined'); }
    
    // Auto-Update System
    const UPDATE_CHECK_INTERVAL = 30000; // Check every 30 seconds
    let lastKnownVersion = localStorage.getItem('chessGameVersion') || GAME_VERSION;
    let updateCheckInterval = null;
    
 // Check for updates - PROTECTED
    const checkForUpdates = protectFunction('checkForUpdates', async function() {
      try {
        if (firebaseDatabase) {
          const versionRef = firebaseDatabase.ref('gameVersion');
          const snapshot = await versionRef.once('value');
          const latestVersion = snapshot.val();
          
          console.log('üîÑ Version check - Latest:', latestVersion, 'Current:', CURRENT_VERSION, 'Known:', lastKnownVersion);
          
          if (latestVersion && latestVersion !== CURRENT_VERSION) {
            console.log('üîÑ New version available on server:', latestVersion);
            showUpdateNotification(latestVersion);
          } else if (lastKnownVersion !== CURRENT_VERSION) {
            console.log('üîÑ Local version change detected:', CURRENT_VERSION);
            showUpdateNotification(CURRENT_VERSION);
            
            // Update server with new version (only if newer than server)
            if (!latestVersion || isNewerVersion(CURRENT_VERSION.replace('V', ''), latestVersion.replace('V', ''))) {
              await versionRef.set(CURRENT_VERSION);
              console.log('‚úÖ Server updated to newer version:', CURRENT_VERSION);
            } else {
              console.log('‚ÑπÔ∏è Server version is newer or equal, not updating server');
            }
          }
        } else {
          // Fallback to local version checking
          if (lastKnownVersion !== CURRENT_VERSION) {
            console.log('üîÑ New version detected:', CURRENT_VERSION, 'Current:', lastKnownVersion);
            showUpdateNotification(CURRENT_VERSION);
            
            // Try to update server with new version (only if newer than server)
            try {
              if (!latestVersion || isNewerVersion(CURRENT_VERSION.replace('V', ''), latestVersion.replace('V', ''))) {
                await versionRef.set(CURRENT_VERSION);
                console.log('‚úÖ Server updated to newer version:', CURRENT_VERSION);
              } else {
                console.log('‚ÑπÔ∏è Server version is newer or equal, not updating server');
              }
            } catch (updateError) {
              console.warn('‚ö†Ô∏è Could not update server:', updateError);
            }
          }
        }
      } catch (error) {
        console.error('üîÑ Error checking for updates:', error);
        // Fallback to local checking
        if (lastKnownVersion !== CURRENT_VERSION) {
          showUpdateNotification(CURRENT_VERSION);
        }
      }
    });
    
    // Unprotected version of update check for file:// users
    async function checkForUpdatesUnprotected() {
      try {
        if (firebaseDatabase) {
          const versionRef = firebaseDatabase.ref('gameVersion');
          const snapshot = await versionRef.once('value');
          const latestVersion = snapshot.val();
          
          console.log('üîÑ File:// version check - Latest:', latestVersion, 'Current:', CURRENT_VERSION, 'Known:', lastKnownVersion);
          
          if (latestVersion && latestVersion !== CURRENT_VERSION) {
            if (isNewerVersion(latestVersion.replace('V', ''), CURRENT_VERSION.replace('V', ''))) {
              console.log('üîÑ Server has newer version:', latestVersion);
              showUpdateNotification(latestVersion);
            } else {
              console.log('üîÑ Local version is newer:', CURRENT_VERSION);
              showUpdateNotification(CURRENT_VERSION);
              
              // Update server with new version
              await versionRef.set(CURRENT_VERSION);
              console.log('‚úÖ Server updated to newer version:', CURRENT_VERSION);
            }
          } else if (lastKnownVersion !== CURRENT_VERSION) {
            console.log('üîÑ Local version change detected:', CURRENT_VERSION);
            showUpdateNotification(CURRENT_VERSION);
            
            // Update server with new version
            await versionRef.set(CURRENT_VERSION);
            console.log('‚úÖ Server updated to new version:', CURRENT_VERSION);
          }
        } else {
          // Fallback to local version checking
          if (lastKnownVersion !== CURRENT_VERSION) {
            console.log('üîÑ New version detected:', CURRENT_VERSION, 'Current:', lastKnownVersion);
            showUpdateNotification(CURRENT_VERSION);
          }
        }
      } catch (error) {
        console.error('üîÑ Error checking for updates:', error);
        // Fallback to local checking
        if (lastKnownVersion !== CURRENT_VERSION) {
          showUpdateNotification(CURRENT_VERSION);
        }
      }
    }
    
    // Immediately sync current version to Firebase (only if newer) - PROTECTED
    const syncCurrentVersionToServer = protectFunction('syncCurrentVersionToServer', async function() {
      try {
        if (firebaseDatabase) {
          const versionRef = firebaseDatabase.ref('gameVersion');
          const snapshot = await versionRef.once('value');
          const serverVersion = snapshot.val();
          
          // Only update if local version is newer than server version
          if (!serverVersion || isNewerVersion(CURRENT_VERSION.replace('V', ''), serverVersion.replace('V', ''))) {
            await versionRef.set(CURRENT_VERSION);
            console.log('‚úÖ Server updated to newer version:', CURRENT_VERSION, '(was:', serverVersion + ')');
          } else {
            console.log('‚ÑπÔ∏è Server version', serverVersion, 'is already newer or equal to local', CURRENT_VERSION);
          }
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Could not sync version to server:', error);
      }
    });
    
    function showUpdateNotification(newVersion = CURRENT_VERSION) {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #10b981, #059669);
        color: white;
        padding: 16px 24px;
        border-radius: 12px;
        box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        z-index: 10000;
        font-family: system-ui, -apple-system, sans-serif;
        font-size: 14px;
        max-width: 300px;
        animation: slideIn 0.3s ease-out;
      `;
      
      const isUpgrade = isNewerVersion(newVersion.replace('V', ''), CURRENT_VERSION.replace('V', ''));
      const updateText = isUpgrade ? `Update to ${newVersion}` : `Reload to ${newVersion}`;
      
      notification.innerHTML = `
        <div style="display: flex; align-items: center; gap: 12px;">
          <div style="font-size: 24px;">üîÑ</div>
          <div>
            <div style="font-weight: bold; margin-bottom: 4px;">${isUpgrade ? 'Game Update Available!' : 'Game Updated!'}</div>
            <div style="opacity: 0.9; margin-bottom: 8px;">${updateText} (You have ${CURRENT_VERSION})</div>
            <button onclick="reloadGame()" style="
              background: white;
              color: #059669;
              border: none;
              padding: 6px 12px;
              border-radius: 6px;
              font-weight: bold;
              cursor: pointer;
              font-size: 12px;
            ">${isUpgrade ? 'Update Now' : 'Reload Now'}</button>
            <button onclick="dismissUpdate(this)" style="
              background: transparent;
              color: white;
              border: 1px solid rgba(255,255,255,0.3);
              padding: 6px 12px;
              border-radius: 6px;
              cursor: pointer;
              font-size: 12px;
              margin-left: 8px;
            ">Later</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(notification);
      
      // Auto-dismiss after 10 seconds
      setTimeout(() => {
        if (notification.parentNode) {
          notification.remove();
        }
      }, 10000);
    }
    
    function reloadGame() {
      console.log('üîÑ Reloading game to version:', CURRENT_VERSION);
      localStorage.setItem('chessGameVersion', CURRENT_VERSION);
      
      // Show loading screen
      const loadingScreen = document.createElement('div');
      loadingScreen.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #1e293b, #334155);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 99999;
        font-family: system-ui, -apple-system, sans-serif;
        color: white;
      `;
      
      loadingScreen.innerHTML = `
        <div style="font-size: 48px; margin-bottom: 20px;">‚ôüÔ∏è</div>
        <div style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">Updating Game...</div>
        <div style="opacity: 0.7; margin-bottom: 30px;">Version ${CURRENT_VERSION}</div>
        <div style="width: 200px; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; overflow: hidden;">
          <div style="width: 100%; height: 100%; background: linear-gradient(90deg, #10b981, #059669); animation: loading 1s ease-in-out infinite;"></div>
        </div>
      `;
      
      document.body.appendChild(loadingScreen);
      
      // Add loading animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes loading {
          0% { transform: translateX(-100%); }
          100% { transform: translateX(100%); }
        }
        @keyframes slideIn {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
      
      // Reload after a short delay to show the loading screen
      setTimeout(() => {
        window.location.reload();
      }, 1500);
    }
    
    function dismissUpdate(button) {
      const notification = button.closest('div').parentElement;
      notification.remove();
    }
    
    function startUpdateChecker() {
      console.log('üîÑ Starting auto-update checker for version:', CURRENT_VERSION);
      
      // Use appropriate version based on protocol
      if (window.location.protocol === 'file:') {
        // File:// users get unprotected version
        checkForUpdatesUnprotected();
        updateCheckInterval = setInterval(checkForUpdatesUnprotected, UPDATE_CHECK_INTERVAL);
      } else {
        // Web users get protected version
        checkForUpdates();
        updateCheckInterval = setInterval(checkForUpdates, UPDATE_CHECK_INTERVAL);
      }
    }
    
    function stopUpdateChecker() {
      if (updateCheckInterval) {
        clearInterval(updateCheckInterval);
        updateCheckInterval = null;
        console.log('üîÑ Stopped auto-update checker');
      }
    }
    
    // Online Storage Configuration - Production Mode
    const ONLINE_STORAGE_CONFIG = {
      provider: 'firebase', // Using Firebase for production
      firebase: {
        apiKey: 'AIzaSyBMy2MS8UUxrxui_QdLwG_r5C6GhUy4pvM', // Production Firebase API key
        authDomain: 'new-chess-game-cc325.firebaseapp.com',
        databaseURL: 'https://new-chess-game-cc325-default-rtdb.firebaseio.com', // Production database
        projectId: 'new-chess-game-cc325',
        storageBucket: 'new-chess-game-cc325.firebasestorage.app',
        messagingSenderId: '641864406456',
        appId: '1:641864406456:web:be77c86068509de3212b4d',
        measurementId: 'G-TQ97LB2J04'
      },
      jsonbinApiKey: localStorage.getItem('jsonbinApiKey') || '$2a$10$81lmfosn./Fikva0/TALFeSEvtW0fJir1ftqZpP.x3CVHnF01aaNW', // Backup JSONBin key
      googlesheets: {
        spreadsheetId: localStorage.getItem('spreadsheetId') || '',
        apiKey: localStorage.getItem('apiKey') || ''
      }
    };
    
    const SHEET_NAME = 'ChessGames';
    
    // Initialize Firebase
    let firebaseApp = null;
    let firebaseDatabase = null;
    
    function initFirebase() {
      if (ONLINE_STORAGE_CONFIG.provider === 'firebase' && !firebaseApp) {
        try {
          firebaseApp = firebase.initializeApp({
            apiKey: ONLINE_STORAGE_CONFIG.firebase.apiKey,
            databaseURL: ONLINE_STORAGE_CONFIG.firebase.databaseURL,
            projectId: 'my-chess-game-105dd',
            storageBucket: 'my-chess-game-105dd.appspot.com',
            authDomain: 'my-chess-game-105dd.firebaseapp.com'
          });
          firebaseDatabase = firebase.database();
          console.log('Firebase initialized successfully');
          return true;
        } catch (error) {
          console.error('Firebase initialization failed:', error);
          return false;
        }
      }
      return firebaseApp !== null;
    }
    
    // Rate limiting for API calls
    let lastApiCall = 0;
    const API_CALL_DELAY = 1100; // 1.1 seconds between calls to avoid quota limits
    
    async function rateLimitedApiCall(apiCall) {
      const now = Date.now();
      const timeSinceLastCall = now - lastApiCall;
      
      if (timeSinceLastCall < API_CALL_DELAY) {
        const delay = API_CALL_DELAY - timeSinceLastCall;
        await new Promise(resolve => setTimeout(resolve, delay));
      }
      
      lastApiCall = Date.now();
      return await apiCall();
    }
    
    // Initialize Online Storage
    async function initOnlineStorage() {
      if (ONLINE_STORAGE_CONFIG.provider === 'firebase') {
        return initFirebase();
      } else if (ONLINE_STORAGE_CONFIG.provider === 'jsonbin') {
        if (!ONLINE_STORAGE_CONFIG.jsonbinApiKey) {
          console.warn('JSONBin API key not configured. Please set up in Config panel.');
          return false;
        }
        return true;
      } else if (ONLINE_STORAGE_CONFIG.provider === 'googlesheets') {
        if (!ONLINE_STORAGE_CONFIG.googlesheets.spreadsheetId || !ONLINE_STORAGE_CONFIG.googlesheets.apiKey) {
          console.warn('Google Sheets not configured. Please set up in Config panel.');
          return false;
        }
        
        // Check if sheet exists, create if not
        try {
          await rateLimitedApiCall(ensureSheetExists);
          return true;
        } catch (error) {
          console.error('Failed to initialize Google Sheets:', error);
          // If quota exceeded, suggest switching to JSONBin
          if (error.message?.includes('Quota exceeded') || error.message?.includes('429')) {
            console.warn('Google Sheets quota exceeded. Consider switching to JSONBin for unlimited online play.');
          }
          return false;
        }
      }
      return false;
    }
    
    // JSONBin.io API Functions
    async function createJsonBinRecord(record) {
      try {
        const url = 'https://api.jsonbin.io/v3/b';
        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Master-Key': ONLINE_STORAGE_CONFIG.jsonbinApiKey,
            'X-Bin-Name': `chess_${record.room_code}`
          },
          body: JSON.stringify(record)
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(`Failed to create JSONBin record: ${JSON.stringify(error)}`);
        }
        
        const result = await response.json();
        return { success: true, id: result.metadata.id, data: record };
      } catch (error) {
        console.error('JSONBin create failed:', error);
        throw error;
      }
    }
    
    async function getJsonBinRecord(binId) {
      try {
        const url = `https://api.jsonbin.io/v3/b/${binId}/latest`;
        const response = await fetch(url, {
          headers: {
            'X-Master-Key': ONLINE_STORAGE_CONFIG.jsonbinApiKey
          }
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(`Failed to get JSONBin record: ${JSON.stringify(error)}`);
        }
        
        const result = await response.json();
        return result.record;
      } catch (error) {
        console.error('JSONBin read failed:', error);
        throw error;
      }
    }
    
    async function updateJsonBinRecord(binId, record) {
      try {
        const url = `https://api.jsonbin.io/v3/b/${binId}`;
        const response = await fetch(url, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
            'X-Master-Key': ONLINE_STORAGE_CONFIG.jsonbinApiKey
          },
          body: JSON.stringify(record)
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(`Failed to update JSONBin record: ${JSON.stringify(error)}`);
        }
        
        const result = await response.json();
        return { success: true, data: result.record };
      } catch (error) {
        console.error('JSONBin update failed:', error);
        throw error;
      }
    }
    
    async function findJsonBinByRoomCode(roomCode) {
      try {
        console.log('Searching for room code:', roomCode);
        // Use the uncatagorized bins endpoint to list all bins
        const url = 'https://api.jsonbin.io/v3/c/uncategorized/bins';
        const response = await fetch(url, {
          headers: {
            'X-Master-Key': ONLINE_STORAGE_CONFIG.jsonbinApiKey
          }
        });
        
        console.log('Search response status:', response.status);
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('Search API Error:', errorText);
          throw new Error(`Failed to list JSONBin records: ${response.status} ${errorText}`);
        }
        
        const result = await response.json();
        console.log('Search API response:', result);
        
        // JSONBin returns an array of bin metadata
        const bins = Array.isArray(result) ? result : [];
        console.log('Available bins metadata:', bins);
        
        const targetName = `chess_${roomCode}`;
        console.log('Looking for bin with name:', targetName);
        
        // We need to check each bin's actual data to find the matching name
        for (const bin of bins) {
          if (bin.record) {
            try {
              const record = await getJsonBinRecord(bin.record);
              if (record && record.name === targetName) {
                console.log('Found matching bin:', record);
                return record;
              }
            } catch (error) {
              console.warn('Failed to read bin:', bin.record, error);
            }
          }
        }
        
        console.log('No matching bin found for room code:', roomCode);
        return null;
      } catch (error) {
        console.error('JSONBin search failed:', error);
        return null;
      }
    }
    
    async function ensureSheetExists() {
      const url = `https://sheets.googleapis.com/v4/spreadsheets/${ONLINE_STORAGE_CONFIG.googlesheets.spreadsheetId}?key=${ONLINE_STORAGE_CONFIG.googlesheets.apiKey}`;
      
      try {
        const response = await fetch(url);
        if (!response.ok) {
          const error = await response.json();
          const errorMsg = error.error?.message || JSON.stringify(error);
          
          if (response.status === 429 || error.error?.message?.includes('Quota exceeded')) {
            throw new Error(`Quota exceeded: ${errorMsg}`);
          } else if (response.status === 404) {
            throw new Error(`Spreadsheet not found. Please check:\n1. The Spreadsheet ID is correct (copy from URL between /d/ and /edit)\n2. The spreadsheet is shared with "Anyone with the link" can VIEW (at minimum)\n3. The API key has access\n\nError: ${errorMsg}`);
          } else if (response.status === 403) {
            throw new Error(`Access denied. Please:\n1. Share the spreadsheet with "Anyone with the link" can EDIT\n2. Or ensure your API key has proper permissions\n\nError: ${errorMsg}`);
          } else if (response.status === 401) {
            throw new Error(`Authentication failed. Please check:\n1. Your API key is correct\n2. Google Sheets API is enabled in your project\n3. The spreadsheet is shared properly\n\nError: ${errorMsg}`);
          } else {
            throw new Error(`Cannot access spreadsheet: ${errorMsg}`);
          }
        }
        
        const data = await response.json();
        
        // Check if sheet exists
        const sheetExists = data.sheets?.some(sheet => sheet.properties.title === SHEET_NAME);
        
        if (!sheetExists) {
          // Try to create the sheet, but don't fail if it doesn't work (requires OAuth2)
          try {
            await createSheet();
          } catch (createError) {
            // Creating sheets requires OAuth2, not just API key
            // This is expected - user needs to create sheet manually
            console.warn('Cannot create sheet automatically (requires OAuth2). User must create manually.');
            const errorData = createError.message.includes('{') ? JSON.parse(createError.message.split('Error: ')[1] || '{}') : {};
            
            if (errorData.error?.code === 401 || createError.message.includes('OAuth2')) {
              // Expected - API keys can't create sheets
              throw new Error(`Sheet "${SHEET_NAME}" not found. Please create it manually:\n\n1. Open your Google Sheet\n2. Click the "+" button at the bottom to add a new sheet tab\n3. Right-click the new tab and select "Rename"\n4. Name it exactly: "${SHEET_NAME}" (case-sensitive)\n5. The headers will be created automatically when you try again\n\nNote: Creating sheets requires OAuth2 authentication. Using an API key, you must create the sheet tab manually.`);
            } else {
              throw createError;
            }
          }
        }
        
        // Check if header row exists
        const headers = await getSheetHeaders();
        if (!headers || headers.length === 0 || headers[0] !== 'room_code') {
          try {
            await createHeaderRow();
          } catch (headerError) {
            console.warn('Could not create headers automatically:', headerError);
            // Don't throw - let user create headers manually, but show instructions
            const headerList = 'room_code, host_player, guest_player, current_player, game_over, white_in_check, black_in_check, host_coins, guest_coins, host_powerups, guest_powerups, game_state_data, last_update';
            console.info('Please add these headers in row 1 of the ChessGames sheet:', headerList);
          }
        }
      } catch (error) {
        console.error('Error ensuring sheet exists:', error);
        throw error;
      }
    }
    
    async function createSheet() {
      // Try to create the sheet using batchUpdate
      // NOTE: This requires OAuth2, not just an API key. API keys can only read/write data, not modify structure.
      const url = `https://sheets.googleapis.com/v4/spreadsheets/${GOOGLE_SHEETS_CONFIG.spreadsheetId}:batchUpdate?key=${GOOGLE_SHEETS_CONFIG.apiKey}`;
      
      const requestBody = {
        requests: [{
          addSheet: {
            properties: {
              title: SHEET_NAME
            }
          }
        }]
      };
      
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      });
      
      if (!response.ok) {
        const error = await response.json();
        // This will fail with 401 because batchUpdate requires OAuth2
        throw new Error(JSON.stringify(error));
      }
      
      return await response.json();
    }
    
    async function createHeaderRow() {
      const headers = [
        'room_code', 'host_player', 'guest_player', 'current_player', 'game_over',
        'white_in_check', 'black_in_check', 'host_coins', 'guest_coins',
        'host_powerups', 'guest_powerups', 'game_state_data', 'last_update'
      ];
      
      await updateSheetRange(`A1:${String.fromCharCode(64 + headers.length)}1`, [headers]);
    }
    
    async function getSheetHeaders() {
      try {
        const url = `https://sheets.googleapis.com/v4/spreadsheets/${GOOGLE_SHEETS_CONFIG.spreadsheetId}/values/${SHEET_NAME}!A1:M1?key=${GOOGLE_SHEETS_CONFIG.apiKey}`;
        const response = await fetch(url);
        const data = await response.json();
        return data.values?.[0] || [];
      } catch (error) {
        return [];
      }
    }
    
    async function updateSheetRange(range, values) {
      const url = `https://sheets.googleapis.com/v4/spreadsheets/${GOOGLE_SHEETS_CONFIG.spreadsheetId}/values/${SHEET_NAME}!${range}?valueInputOption=RAW&key=${GOOGLE_SHEETS_CONFIG.apiKey}`;
      
      const requestBody = {
        values: values
      };
      
      const response = await fetch(url, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(`Failed to update sheet: ${JSON.stringify(error)}`);
      }
      
      return await response.json();
    }
    
    async function appendSheetRow(values) {
      try {
        return await rateLimitedApiCall(async () => {
          const url = `https://sheets.googleapis.com/v4/spreadsheets/${ONLINE_STORAGE_CONFIG.googlesheets.spreadsheetId}/values/${SHEET_NAME}!A:append?valueInputOption=RAW&key=${ONLINE_STORAGE_CONFIG.googlesheets.apiKey}`;
          
          const requestBody = {
            values: [values]
          };
          
          const response = await fetch(url, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
          });
          
          if (!response.ok) {
            const error = await response.json();
            console.error('Google Sheets API Error:', error);
            
            // Fallback to localStorage if Google Sheets fails
            if (response.status === 429 || error.error?.message?.includes('Quota exceeded')) {
              console.warn('Google Sheets quota exceeded. Using localStorage fallback.');
              return fallbackToLocalStorage(values, 'append');
            } else if (error.error?.code === 401 || error.error?.message?.includes('API keys are not supported')) {
              console.warn('Google Sheets API key authentication not supported. Using localStorage fallback.');
              return fallbackToLocalStorage(values, 'append');
            }
            
            throw new Error(`Failed to append row: ${JSON.stringify(error)}`);
          }
          
          return await response.json();
        });
      } catch (error) {
        console.error('Google Sheets append failed:', error);
        // Fallback to localStorage
        return fallbackToLocalStorage(values, 'append');
      }
    }
    
    // Fallback storage using localStorage
    function fallbackToLocalStorage(values, operation) {
      const storageKey = `chess_game_${gameState.roomCode || 'local'}`;
      let gameData = JSON.parse(localStorage.getItem(storageKey) || '{}');
      
      if (operation === 'append') {
        // Create a new record
        const timestamp = new Date().toISOString();
        const newRecord = {
          timestamp: timestamp,
          room_code: values[0] || '',
          player1_name: values[1] || '',
          player2_name: values[2] || '',
          game_state: values[3] || '',
          current_turn: values[4] || '',
          white_coins: values[5] || 0,
          black_coins: values[6] || 0,
          game_mode: values[7] || '',
          created_at: values[8] || timestamp,
          last_updated: timestamp,
          status: values[9] || 'active'
        };
        
        gameData = newRecord;
        localStorage.setItem(storageKey, JSON.stringify(gameData));
        
        console.log('Game saved to localStorage fallback:', newRecord);
        return { success: true, fallback: true, data: newRecord };
      }
      
      return { success: false, error: 'Unknown operation' };
    }
    
    async function getSheetData() {
      try {
        return await rateLimitedApiCall(async () => {
          const url = `https://sheets.googleapis.com/v4/spreadsheets/${ONLINE_STORAGE_CONFIG.googlesheets.spreadsheetId}/values/${SHEET_NAME}!A2:M?key=${ONLINE_STORAGE_CONFIG.googlesheets.apiKey}`;
          
          const response = await fetch(url);
          
          if (!response.ok) {
            const error = await response.json();
            console.error('Google Sheets read error:', error);
            
            // Fallback to localStorage
            if (response.status === 429 || error.error?.message?.includes('Quota exceeded')) {
              console.warn('Google Sheets quota exceeded. Using localStorage fallback.');
              return fallbackGetFromLocalStorage();
            } else if (response.status === 401 || error.error?.message?.includes('API keys are not supported')) {
              console.warn('Google Sheets API key authentication not supported. Using localStorage fallback.');
              return fallbackGetFromLocalStorage();
            }
            
            throw new Error(`Failed to read sheet: ${JSON.stringify(error)}`);
          }
          
          const data = await response.json();
          
          if (!data.values) {
            return [];
          }
          
          const headers = await getSheetHeaders();
          return data.values.map(row => {
            const record = {};
            headers.forEach((header, index) => {
              record[header] = row[index] || '';
            });
            return record;
          });
        });
      } catch (error) {
        console.error('Google Sheets read failed:', error);
        // Fallback to localStorage
        return fallbackGetFromLocalStorage();
      }
    }
    
    function fallbackGetFromLocalStorage() {
      // Get all stored games from localStorage
      const games = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('chess_game_')) {
          const gameData = JSON.parse(localStorage.getItem(key) || '{}');
          games.push(gameData);
        }
      }
      return games;
    }
    
    async function findRowByRoomCode(roomCode) {
      try {
        const data = await getSheetData();
        return data.find(record => record.room_code === roomCode);
      } catch (error) {
        console.error('Error finding room code:', error);
        // Try localStorage fallback
        const storageKey = `chess_game_${roomCode}`;
        const gameData = JSON.parse(localStorage.getItem(storageKey) || '{}');
        return gameData.room_code === roomCode ? gameData : null;
      }
    }
    
    async function updateRowByRoomCode(roomCode, updatedData) {
      try {
        const data = await getSheetData();
        const rowIndex = data.findIndex(record => record.room_code === roomCode);
        
        if (rowIndex === -1) {
          throw new Error('Room not found');
        }
        
        // Get headers
        const headers = await getSheetHeaders();
        
        // Build row values
        const rowValues = headers.map(header => {
          if (updatedData.hasOwnProperty(header)) {
            return updatedData[header];
          }
          return data[rowIndex][header] || '';
        });
        
        // Update the row (rowIndex + 2 because row 1 is header, and arrays are 0-indexed)
        const range = `A${rowIndex + 2}:${String.fromCharCode(64 + headers.length)}${rowIndex + 2}`;
        await updateSheetRange(range, [rowValues]);
        
        return { ...data[rowIndex], ...updatedData };
      } catch (error) {
        console.error('Google Sheets update failed:', error);
        // Fallback to localStorage
        return fallbackUpdateLocalStorage(roomCode, updatedData);
      }
    }
    
    function fallbackUpdateLocalStorage(roomCode, updatedData) {
      const storageKey = `chess_game_${roomCode}`;
      let gameData = JSON.parse(localStorage.getItem(storageKey) || '{}');
      
      // Update the game data
      Object.assign(gameData, updatedData);
      gameData.last_updated = new Date().toISOString();
      
      localStorage.setItem(storageKey, JSON.stringify(gameData));
      console.log('Game updated in localStorage fallback:', gameData);
      return { success: true, fallback: true, data: gameData };
    }
    
    // Firebase Functions
    async function createFirebaseRecord(record) {
      try {
        const roomRef = firebaseDatabase.ref('rooms/' + record.room_code);
        await roomRef.set({
          ...record,
          created_at: firebase.database.ServerValue.TIMESTAMP,
          last_update: firebase.database.ServerValue.TIMESTAMP
        });
        return { success: true, data: record };
      } catch (error) {
        console.error('Firebase create failed:', error);
        throw error;
      }
    }
    
    async function getFirebaseRecord(roomCode) {
      try {
        const roomRef = firebaseDatabase.ref('rooms/' + roomCode);
        const snapshot = await roomRef.once('value');
        const data = snapshot.val();
        return data;
      } catch (error) {
        console.error('Firebase read failed:', error);
        throw error;
      }
    }
    
    async function updateFirebaseRecord(roomCode, record) {
      try {
        const roomRef = firebaseDatabase.ref('rooms/' + roomCode);
        await roomRef.update({
          ...record,
          last_update: firebase.database.ServerValue.TIMESTAMP
        });
        return { success: true, data: record };
      } catch (error) {
        console.error('Firebase update failed:', error);
        throw error;
      }
    }
    
    async function getAllFirebaseRecords() {
      try {
        const roomsRef = firebaseDatabase.ref('rooms');
        const snapshot = await roomsRef.once('value');
        const data = snapshot.val();
        const records = [];
        
        if (data) {
          Object.keys(data).forEach(roomCode => {
            records.push({
              ...data[roomCode],
              room_code: roomCode
            });
          });
        }
        
        return records;
      } catch (error) {
        console.error('Firebase getAll failed:', error);
        return [];
      }
    }
    
    // Online Storage Data Handler
    const onlineStorageHandler = {
      async create(record) {
        if (ONLINE_STORAGE_CONFIG.provider === 'firebase') {
          if (!firebaseDatabase) {
            return { isOk: false, error: 'Firebase not initialized' };
          }
          
          try {
            const result = await createFirebaseRecord(record);
            return { isOk: true, data: result.data };
          } catch (error) {
            console.error('Error creating Firebase record:', error);
            return { isOk: false, error: error.message };
          }
        } else if (ONLINE_STORAGE_CONFIG.provider === 'jsonbin') {
          if (!ONLINE_STORAGE_CONFIG.jsonbinApiKey) {
            return { isOk: false, error: 'JSONBin not configured' };
          }
          
          try {
            const result = await createJsonBinRecord(record);
            return { isOk: true, data: result.data };
          } catch (error) {
            console.error('Error creating JSONBin record:', error);
            return { isOk: false, error: error.message };
          }
        } else if (ONLINE_STORAGE_CONFIG.provider === 'googlesheets') {
          if (!ONLINE_STORAGE_CONFIG.googlesheets.spreadsheetId || !ONLINE_STORAGE_CONFIG.googlesheets.apiKey) {
            return { isOk: false, error: 'Google Sheets not configured' };
          }
          
          try {
            await ensureSheetExists();
            const headers = await getSheetHeaders();
            const rowValues = headers.map(header => {
              const value = record[header];
              if (typeof value === 'object') {
                return JSON.stringify(value);
              }
              return value || '';
            });
            
            await appendSheetRow(rowValues);
            return { isOk: true, data: record };
          } catch (error) {
            console.error('Error appending to Google Sheets:', error);
            return { isOk: false, error: error.message };
          }
        }
        
        return { isOk: false, error: 'No storage provider configured' };
      },
      
      async read(roomCode) {
        if (ONLINE_STORAGE_CONFIG.provider === 'firebase') {
          if (!firebaseDatabase) {
            return { isOk: false, error: 'Firebase not initialized' };
          }
          
          try {
            const result = await getFirebaseRecord(roomCode);
            return { isOk: true, data: result };
          } catch (error) {
            console.error('Error reading Firebase record:', error);
            return { isOk: false, error: error.message };
          }
        } else if (ONLINE_STORAGE_CONFIG.provider === 'jsonbin') {
          if (!ONLINE_STORAGE_CONFIG.jsonbinApiKey) {
            return { isOk: false, error: 'JSONBin not configured' };
          }
          
          try {
            const result = await findJsonBinByRoomCode(roomCode);
            return { isOk: true, data: result };
          } catch (error) {
            console.error('Error reading JSONBin record:', error);
            return { isOk: false, error: error.message };
          }
        } else if (ONLINE_STORAGE_CONFIG.provider === 'googlesheets') {
          if (!ONLINE_STORAGE_CONFIG.googlesheets.spreadsheetId || !ONLINE_STORAGE_CONFIG.googlesheets.apiKey) {
            return { isOk: false, error: 'Google Sheets not configured' };
          }
          
          try {
            const result = await findRowByRoomCode(roomCode);
            return { isOk: true, data: result };
          } catch (error) {
            console.error('Error reading Google Sheets record:', error);
            return { isOk: false, error: error.message };
          }
        }
        
        return { isOk: false, error: 'No storage provider configured' };
      },
      
      async getAll() {
        if (ONLINE_STORAGE_CONFIG.provider === 'firebase') {
          if (!firebaseDatabase) {
            return [];
          }
          
          try {
            const result = await getAllFirebaseRecords();
            return result;
          } catch (error) {
            console.error('Error getting all Firebase records:', error);
            return [];
          }
        } else if (ONLINE_STORAGE_CONFIG.provider === 'jsonbin') {
          if (!ONLINE_STORAGE_CONFIG.jsonbinApiKey) {
            return [];
          }
          
          try {
            const url = 'https://api.jsonbin.io/v3/c/uncategorized/bins';
            console.log('Fetching bins from:', url);
            const response = await fetch(url, {
              headers: { 'X-Master-Key': ONLINE_STORAGE_CONFIG.jsonbinApiKey }
            });
            
            console.log('Response status:', response.status);
            
            if (!response.ok) {
              const errorText = await response.text();
              console.error('API Error Response:', errorText);
              throw new Error(`Failed to list JSONBin records: ${response.status} ${errorText}`);
            }
            
            const result = await response.json();
            console.log('Raw API response:', result);
            
            const gameRecords = [];
            
            // JSONBin returns an array of bin metadata
            const bins = Array.isArray(result) ? result : [];
            console.log('Processed bins array:', bins);
            
            for (const bin of bins) {
              console.log('Checking bin:', bin);
              // We need to get the actual bin data to check the name
              if (bin.record) {
                try {
                  const record = await getJsonBinRecord(bin.record);
                  if (record && record.name && record.name.startsWith('chess_')) {
                    gameRecords.push(record);
                    console.log('Added game record:', record);
                  }
                } catch (error) {
                  console.warn('Failed to read bin:', bin.record, error);
                }
              }
            }
            
            return gameRecords;
          } catch (error) {
            console.error('Error getting all JSONBin records:', error);
            return [];
          }
        } else if (ONLINE_STORAGE_CONFIG.provider === 'googlesheets') {
          if (!ONLINE_STORAGE_CONFIG.googlesheets.spreadsheetId || !ONLINE_STORAGE_CONFIG.googlesheets.apiKey) {
            return [];
          }
          
          try {
            return await getSheetData();
          } catch (error) {
            console.error('Error getting all Google Sheets records:', error);
            return [];
          }
        }
        
        return [];
      },
      
      async update(roomCode, updatedData) {
        if (ONLINE_STORAGE_CONFIG.provider === 'firebase') {
          if (!firebaseDatabase) {
            return { isOk: false, error: 'Firebase not initialized' };
          }
          
          try {
            const result = await updateFirebaseRecord(roomCode, updatedData);
            return { isOk: true, data: result.data };
          } catch (error) {
            console.error('Error updating Firebase record:', error);
            return { isOk: false, error: error.message };
          }
        } else if (ONLINE_STORAGE_CONFIG.provider === 'jsonbin') {
          if (!ONLINE_STORAGE_CONFIG.jsonbinApiKey) {
            return { isOk: false, error: 'JSONBin not configured' };
          }
          
          try {
            // First find the bin ID
            const binList = await fetch('https://api.jsonbin.io/v3/b', {
              headers: { 'X-Master-Key': ONLINE_STORAGE_CONFIG.jsonbinApiKey }
            });
            const bins = await binList.json();
            const bin = bins.find(b => b.name === `chess_${roomCode}`);
            
            if (!bin) {
              return { isOk: false, error: 'Game not found' };
            }
            
            const result = await updateJsonBinRecord(bin.id, updatedData);
            return { isOk: true, data: result.data };
          } catch (error) {
            console.error('Error updating JSONBin record:', error);
            return { isOk: false, error: error.message };
          }
        } else if (ONLINE_STORAGE_CONFIG.provider === 'googlesheets') {
          if (!ONLINE_STORAGE_CONFIG.googlesheets.spreadsheetId || !ONLINE_STORAGE_CONFIG.googlesheets.apiKey) {
            return { isOk: false, error: 'Google Sheets not configured' };
          }
          
          try {
            const result = await updateRowByRoomCode(roomCode, updatedData);
            return { isOk: true, data: result };
          } catch (error) {
            console.error('Error updating Google Sheets record:', error);
            return { isOk: false, error: error.message };
          }
        }
        
        return { isOk: false, error: 'No storage provider configured' };
      },
      
      async delete(roomCode) {
        if (ONLINE_STORAGE_CONFIG.provider === 'firebase') {
          if (!firebaseDatabase) {
            return { isOk: false, error: 'Firebase not initialized' };
          }
          
          try {
            const roomRef = firebaseDatabase.ref('rooms/' + roomCode);
            await roomRef.remove();
            return { isOk: true, data: { deleted: true } };
          } catch (error) {
            console.error('Error deleting Firebase record:', error);
            return { isOk: false, error: error.message };
          }
        } else if (ONLINE_STORAGE_CONFIG.provider === 'jsonbin') {
          if (!ONLINE_STORAGE_CONFIG.jsonbinApiKey) {
            return { isOk: false, error: 'JSONBin not configured' };
          }
          
          try {
            // First find the bin ID
            const binList = await fetch('https://api.jsonbin.io/v3/b', {
              headers: { 'X-Master-Key': ONLINE_STORAGE_CONFIG.jsonbinApiKey }
            });
            const bins = await binList.json();
            const bin = bins.find(b => b.name === `chess_${roomCode}`);
            
            if (!bin) {
              return { isOk: false, error: 'Game not found' };
            }
            
            const result = await deleteJsonBinRecord(bin.id);
            return { isOk: true, data: result.data };
          } catch (error) {
            console.error('Error deleting JSONBin record:', error);
            return { isOk: false, error: error.message };
          }
        } else if (ONLINE_STORAGE_CONFIG.provider === 'googlesheets') {
          if (!ONLINE_STORAGE_CONFIG.googlesheets.spreadsheetId || !ONLINE_STORAGE_CONFIG.googlesheets.apiKey) {
            return { isOk: false, error: 'Google Sheets not configured' };
          }
          
          try {
            // Find and delete the row
            const data = await getSheetData();
            const rowIndex = data.findIndex(row => row.room_code === roomCode);
            
            if (rowIndex === -1) {
              return { isOk: false, error: 'Game not found' };
            }
            
            await deleteSheetRow(rowIndex + 2); // +2 for header row and 1-based indexing
            return { isOk: true, data: { deleted: true } };
          } catch (error) {
            console.error('Error deleting Google Sheets row:', error);
            return { isOk: false, error: error.message };
          }
        }
        
        return { isOk: false, error: 'No storage provider configured' };
      }
    };
    
    // Quick setup functions
    function showQuickSetup() {
      document.getElementById('quick-setup-modal').style.display = 'block';
      document.getElementById('quick-setup-modal').style.position = 'fixed';
      document.getElementById('quick-setup-modal').style.top = '0';
      document.getElementById('quick-setup-modal').style.left = '0';
      document.getElementById('quick-setup-modal').style.width = '100%';
      document.getElementById('quick-setup-modal').style.height = '100%';
      document.getElementById('quick-setup-modal').style.zIndex = '3000';
    }
    
    function closeQuickSetup() {
      document.getElementById('quick-setup-modal').style.display = 'none';
    }
    
    // Configuration functions
    
    async function createNewSheet() {
      alert('üìã Google Sheets Setup Instructions:\n\n1. Go to https://sheets.google.com\n2. Create a new spreadsheet\n3. Copy the Spreadsheet ID from the URL:\n   - URL looks like: https://docs.google.com/spreadsheets/d/SPREADSHEET_ID_HERE/edit\n   - Copy the long string between /d/ and /edit\n\n4. IMPORTANT - Share Settings:\n   - Click "Share" button\n   - Set to "Anyone with the link"\n   - Permission: "Editor" (required for writing data)\n   - Click "Done"\n\n5. Create the "ChessGames" Sheet Tab:\n   - Click the "+" button at bottom to add new sheet\n   - Right-click the new tab ‚Üí "Rename"\n   - Name it exactly: ChessGames (case-sensitive)\n   - Headers will be added automatically\n\n6. Get Google API Key:\n   - Go to https://console.cloud.google.com\n   - Create/select a project\n   - Enable "Google Sheets API"\n   - Go to "Credentials" ‚Üí "Create Credentials" ‚Üí "API Key"\n   - (Optional) Restrict to Google Sheets API only\n\n7. Paste both in the Config panel:\n   - Spreadsheet ID\n   - API Key\n\n‚ö†Ô∏è Note: API keys can read/write data but cannot create new sheet tabs. You must create the "ChessGames" tab manually.');
    }
    
    function loadConfig() {
      const provider = localStorage.getItem('storageProvider') || 'jsonbin';
      const jsonbinApiKey = localStorage.getItem('jsonbinApiKey');
      const spreadsheetId = localStorage.getItem('spreadsheetId');
      const apiKey = localStorage.getItem('apiKey');
      
      // Load into config
      ONLINE_STORAGE_CONFIG.provider = provider;
      ONLINE_STORAGE_CONFIG.jsonbinApiKey = jsonbinApiKey || '';
      ONLINE_STORAGE_CONFIG.googlesheets.spreadsheetId = spreadsheetId || '';
      ONLINE_STORAGE_CONFIG.googlesheets.apiKey = apiKey || '';
      
      // Update UI elements
      const providerSelect = document.getElementById('storage-provider');
      const jsonbinConfig = document.getElementById('jsonbin-config');
      const googlesheetsConfig = document.getElementById('googlesheets-config');
      
      if (providerSelect) {
        providerSelect.value = provider;
        
        // Show/hide appropriate config sections
        if (provider === 'jsonbin') {
          jsonbinConfig.style.display = 'grid';
          googlesheetsConfig.style.display = 'none';
        } else if (provider === 'googlesheets') {
          jsonbinConfig.style.display = 'none';
          googlesheetsConfig.style.display = 'grid';
        }
      }
      
      // Load values into input fields
      const jsonbinKeyInput = document.getElementById('admin-jsonbin-key');
      const spreadsheetIdInput = document.getElementById('admin-spreadsheet-id');
      const apiKeyInput = document.getElementById('admin-api-key');
      
      if (jsonbinKeyInput) jsonbinKeyInput.value = jsonbinApiKey || '';
      if (spreadsheetIdInput) spreadsheetIdInput.value = spreadsheetId || '';
      if (apiKeyInput) apiKeyInput.value = apiKey || '';
    }
    
    // Game Constants and State
    const defaultConfig = {
      background_color: "#1e293b",
      board_light_color: "#f0d9b5",
      board_dark_color: "#b58863",
      text_color: "#f1f5f9",
      button_color: "#3b82f6",
      font_family: "system-ui",
      font_size: 16,
      game_title: "Fun Chess üéâ",
      player_white_label: "White",
      player_black_label: "Black",
      reset_button_text: "New Game"
    };
    
    const ADMIN_PASSWORD = "Spots2019";
    
    // Timer Functions
    function formatTime(seconds) {
      const minutes = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${minutes}:${secs.toString().padStart(2, '0')}`;
    }
    
    function updateTimerDisplay() {
      document.getElementById('white-timer').textContent = formatTime(gameState.whiteTime);
      document.getElementById('black-timer').textContent = formatTime(gameState.blackTime);
    }
    
    function startTimer() {
      if (gameState.timerRunning) return;
      
      gameState.timerRunning = true;
      document.getElementById('start-timer-btn').style.display = 'none';
      document.getElementById('pause-timer-btn').style.display = 'block';
      
      gameState.timerInterval = setInterval(() => {
        if (gameState.currentPlayer === 'white') {
          gameState.whiteTime--;
          if (gameState.whiteTime <= 0) {
            gameState.whiteTime = 0;
            stopTimer();
            endGame('black', 'White ran out of time!');
            return;
          }
        } else {
          gameState.blackTime--;
          if (gameState.blackTime <= 0) {
            gameState.blackTime = 0;
            stopTimer();
            endGame('white', 'Black ran out of time!');
            return;
          }
        }
        updateTimerDisplay();
        
        // Save timer state in online games
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }, 1000);
    }
    
    function pauseTimer() {
      gameState.timerRunning = false;
      clearInterval(gameState.timerInterval);
      document.getElementById('start-timer-btn').style.display = 'block';
      document.getElementById('pause-timer-btn').style.display = 'none';
    }
    
    function stopTimer() {
      gameState.timerRunning = false;
      clearInterval(gameState.timerInterval);
      gameState.timerInterval = null;
      document.getElementById('start-timer-btn').style.display = 'block';
      document.getElementById('pause-timer-btn').style.display = 'none';
    }
    
    function resetTimer() {
      stopTimer();
      gameState.whiteTime = 600;
      gameState.blackTime = 600;
      updateTimerDisplay();
    }
    
    // Chat Functions
    function addChatMessage(sender, message, isSystem = false) {
      const messageObj = {
        sender: sender,
        message: message,
        timestamp: Date.now(),
        isSystem: isSystem
      };
      
      gameState.chatMessages.push(messageObj);
      
      // Keep only last 50 messages
      if (gameState.chatMessages.length > 50) {
        gameState.chatMessages = gameState.chatMessages.slice(-50);
      }
      
      renderChatMessages();
      
      // Save chat in online games
      if (gameState.mode === 'online' && !isSystem) {
        updateGameStateOnServer();
      }
    }
    
    function renderChatMessages() {
      const container = document.getElementById('chat-messages');
      container.innerHTML = '';
      
      if (gameState.chatMessages.length === 0) {
        container.innerHTML = '<div style="color: #64748b; font-style: italic;">No messages yet...</div>';
        return;
      }
      
      gameState.chatMessages.forEach(msg => {
        const messageDiv = document.createElement('div');
        messageDiv.style.marginBottom = '8px';
        
        if (msg.isSystem) {
          messageDiv.innerHTML = `<span style="color: #f59e0b; font-style: italic;">‚öôÔ∏è ${msg.message}</span>`;
        } else {
          const isOpponent = msg.sender !== gameState.playerName;
          const color = isOpponent ? '#60a5fa' : '#34d399';
          messageDiv.innerHTML = `<span style="color: ${color}; font-weight: bold;">${msg.sender}:</span> <span style="color: #cbd5e1;">${msg.message}</span>`;
        }
        
        container.appendChild(messageDiv);
      });
      
      // Scroll to bottom
      container.scrollTop = container.scrollHeight;
    }
    
    function sendChatMessage() {
      const input = document.getElementById('chat-input');
      const message = input.value.trim();
      
      if (!message) return;
      
      // Use playerName with fallback to avoid "null" in chat
      const senderName = gameState.playerName || 
                        (gameState.playerColor === 'white' ? 'White Player' : 'Black Player');
      
      addChatMessage(senderName, message);
      input.value = '';
      
      // Play send sound
      playButtonSound();
    }
    
    function toggleChatSize() {
      const container = document.getElementById('chat-container');
      const currentHeight = container.style.height;
      
      if (currentHeight === '200px' || !currentHeight) {
        container.style.height = '100px';
      } else {
        container.style.height = '200px';
      }
    }
    
    function enableOnlineFeatures() {
      const onlineFeatures = document.getElementById('online-features');
      const timerSection = document.getElementById('timer-section');
      const chatSection = document.getElementById('chat-section');
      
      onlineFeatures.style.display = 'block';
      timerSection.style.display = 'block';
      
      if (gameState.mode === 'online') {
        chatSection.style.display = 'block';
        gameState.chatEnabled = true;
        addChatMessage('System', 'Chat enabled for online game!', true);
      }
      
      gameState.timerEnabled = true;
      updateTimerDisplay();
    }
    
    function disableOnlineFeatures() {
      const onlineFeatures = document.getElementById('online-features');
      onlineFeatures.style.display = 'none';
      
      stopTimer();
      gameState.timerEnabled = false;
      gameState.chatEnabled = false;
    }
    
    function endGame(winner, reason) {
      gameState.gameOver = true;
      stopTimer();
      
      // Update game status
      const statusDiv = document.getElementById('game-status');
      const winnerEmoji = winner === 'white' ? '‚ö™' : '‚ö´';
      statusDiv.innerHTML = `<span style="color: #10b981;">üéâ Game Over! ${winnerEmoji} ${winner.charAt(0).toUpperCase() + winner.slice(1)} wins!</span><br><span style="color: #f59e0b; font-size: 14px;">${reason}</span>`;
      
      // Add system chat message
      if (gameState.chatEnabled) {
        addChatMessage('System', `Game Over! ${winner} wins - ${reason}`, true);
      }
      
      // Play game over sound
      playGameOverSound();
      
      // Update server if online
      if (gameState.mode === 'online') {
        updateGameStateOnServer();
      }
    }
    
    const initialBoard = [
      ['‚ôú', '‚ôû', '‚ôù', '‚ôõ', '‚ôö', '‚ôù', '‚ôû', '‚ôú'],
      ['‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü'],
      ['', '', '', '', '', '', '', ''],
      ['', '', '', '', '', '', '', ''],
      ['', '', '', '', '', '', '', ''],
      ['', '', '', '', '', '', '', ''],
      ['‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô'],
      ['‚ôñ', '‚ôò', '‚ôó', '‚ôï', '‚ôî', '‚ôó', '‚ôò', '‚ôñ']
    ];

    const defaultPowerUps = {
      undo: 0, hint: 0, shield: 0, double_coins: 0, freeze: 0,
      knight_boost: 0, vision: 0, swap: 0, bomb: 0, time_warp: 0,
      lightning: 0, heal: 0, clone: 0, magnet: 0, poison: 0,
      shield_wall: 0, speed_boost: 0, invisibility: 0, earthquake: 0,
      blizzard: 0, laser: 0, mirror: 0, tornado: 0, gravity: 0,
      phoenix: 0, time_freeze: 0, coin_rain: 0, power_steal: 0,
      mega_bomb: 0, royal_guard: 0, lucky_charm: 0, chaos: 0
    };

    let gameState = {
      mode: null,
      aiDifficulty: 'medium',
      board: JSON.parse(JSON.stringify(initialBoard)),
      currentPlayer: 'white',
      selectedSquare: null,
      whiteCaptured: [],
      blackCaptured: [],
      gameOver: false,
      lastMove: null,
      whiteInCheck: false,
      blackInCheck: false,
      whiteCoins: 0,
      blackCoins: 0,
      whitePowerUps: { ...defaultPowerUps },
      blackPowerUps: { ...defaultPowerUps },
      moveHistory: [],
      currentTheme: 'classic',
      currentEffect: null,
      whiteCurrentSkin: 'classic',
      blackCurrentSkin: 'classic',
      whiteUnlockedSkins: ['classic'],
      blackUnlockedSkins: ['classic'],
      unlockedThemes: ['classic'],
      unlockedSoundPacks: ['classic'],
      currentSoundPack: 'classic',
      unlockedBundles: ['classic'],
      currentBundle: 'classic',
      whiteShieldActive: false,
      blackShieldActive: false,
      whiteDoubleCoinsActive: false,
      blackDoubleCoinsActive: false,
      whiteKnightBoostActive: false,
      blackKnightBoostActive: false,
      whiteKnightBoostMovesLeft: 0,
      blackKnightBoostMovesLeft: 0,
      whiteVisionActive: false,
      blackVisionActive: false,
      freezeActive: false,
      swapMode: false,
      swapFirstPiece: null,
      bombMode: false,
      timeWarpActive: false,
      lightningMode: false,
      cloneMode: false,
      magnetMode: false,
      poisonMode: false,
      lightningTarget: null,
      cloneTarget: null,
      poisonTarget: null,
      shieldWallActive: false,
      speedBoostActive: false,
      invisibilityActive: false,
      earthquakeActive: false,
      blizzardActive: false,
      laserTarget: null,
      mirrorActive: false,
      tornadoActive: false,
      gravityActive: false,
      phoenixActive: false,
      timeFreezeActive: false,
      coinRainActive: false,
      powerStealActive: false,
      megaBombTarget: null,
      royalGuardActive: false,
      luckyCharmActive: false,
      chaosActive: false,
      gameStartTime: null,
      timerRunning: false,
      timerSeconds: 0,
      playerColor: 'white',
      roomCode: null,
      playerName: null,
      opponentName: null,
      currentGameRecord: null,
      onlineGameId: null,
      isHost: false,
      syncInterval: null,
      lastSyncTime: null,
      retryCount: 0,
      maxRetries: 3,
      connectionStatus: 'disconnected',
      pendingMoves: [],
      spectators: [],
      chatMessages: [],
      isSpectating: false,
      disablePowerups: false
    };

    // Sound data and settings
    const soundPacks = {
      classic: { name: 'üîî Classic Chess', description: 'Traditional chess sounds', cost: 0 },
      retro: { name: 'üïπÔ∏è Retro Arcade', description: '8-bit game sounds', cost: 45 },
      nature: { name: 'üåø Nature Peace', description: 'Peaceful nature sounds', cost: 50 },
      medieval: { name: '‚öîÔ∏è Medieval Battle', description: 'Sword and armor sounds', cost: 60 },
      space: { name: 'üöÄ Space Sci-Fi', description: 'Futuristic space sounds', cost: 55 },
      ocean: { name: 'üåä Ocean Waves', description: 'Calming ocean sounds', cost: 40 },
      forest: { name: 'üå≤ Forest Ambience', description: 'Forest wildlife sounds', cost: 45 },
      magical: { name: 'ü™Ñ Magic Spells', description: 'Magical spell sounds', cost: 65 },
      cyber: { name: 'ü§ñ Cyber Tech', description: 'Electronic tech sounds', cost: 70 },
      royal: { name: 'üëë Royal Court', description: 'Elegant royal sounds', cost: 55 },
      minimal: { name: '‚ö™ Minimal Clean', description: 'Simple clean sounds', cost: 35 },
      fire: { name: 'üî• Fire Crackling', description: 'Burning fire sounds', cost: 50 },
      ice: { name: '‚ùÑÔ∏è Ice Cracking', description: 'Frozen ice sounds', cost: 45 },
      storm: { name: '‚õàÔ∏è Thunderstorm', description: 'Thunder and lightning sounds', cost: 55 },
      rainbow: { name: 'üåà Rainbow Joy', description: 'Colorful happy sounds', cost: 60 },
      neon: { name: 'üí´ Neon Lights', description: 'Electric neon sounds', cost: 65 },
      casino: { name: 'üé∞ Vegas Casino', description: 'Casino jackpot sounds', cost: 50 },
      halloween: { name: 'üéÉ Halloween Spooky', description: 'Spooky horror sounds', cost: 45 },
      christmas: { name: 'üéÑ Christmas Joy', description: 'Holiday festive sounds', cost: 40 }
    };

    // Complete Bundle Packs - matching themes, skins, effects, and sound packs
    const bundlePacks = {
      classic: {
        name: '‚ôüÔ∏è Classic Collection',
        description: 'Traditional chess experience with classic pieces and sounds',
        theme: 'classic',
        whiteSkin: 'default',
        blackSkin: 'default',
        effect: null,
        soundPack: 'classic',
        cost: 0,
        icon: '‚ôüÔ∏è'
      },
      retro: {
        name: 'üïπÔ∏è Retro Gaming Pack',
        description: '8-bit arcade nostalgia with retro pieces and electronic sounds',
        theme: 'matrix',
        whiteSkin: 'robots',
        blackSkin: 'robots',
        effect: 'retro',
        soundPack: 'retro',
        cost: 150,
        icon: 'üïπÔ∏è'
      },
      nature: {
        name: 'üåø Nature Harmony',
        description: 'Peaceful forest theme with natural sounds and organic pieces',
        theme: 'nature',
        whiteSkin: 'nature',
        blackSkin: 'nature',
        effect: 'nature',
        soundPack: 'nature',
        cost: 180,
        icon: 'üåø'
      },
      medieval: {
        name: '‚öîÔ∏è Medieval Battle',
        description: 'Epic medieval warfare with armored pieces and battle sounds',
        theme: 'royal',
        whiteSkin: 'medieval',
        blackSkin: 'medieval',
        effect: 'fire',
        soundPack: 'medieval',
        cost: 220,
        icon: '‚öîÔ∏è'
      },
      space: {
        name: 'üöÄ Space Odyssey',
        description: 'Futuristic space adventure with cosmic pieces and sci-fi sounds',
        theme: 'space',
        whiteSkin: 'space',
        blackSkin: 'space',
        effect: 'space',
        soundPack: 'space',
        cost: 250,
        icon: 'üöÄ'
      },
      ocean: {
        name: 'üåä Ocean Dreams',
        description: 'Underwater marine theme with sea creatures and wave sounds',
        theme: 'ocean',
        whiteSkin: 'ocean',
        blackSkin: 'ocean',
        effect: 'wave',
        soundPack: 'ocean',
        cost: 160,
        icon: 'üåä'
      },
      magical: {
        name: 'ü™Ñ Magic Kingdom',
        description: 'Enchanted fantasy with magical pieces and spell sounds',
        theme: 'magical',
        whiteSkin: 'magic',
        blackSkin: 'magic',
        effect: 'magic',
        soundPack: 'magical',
        cost: 240,
        icon: 'ü™Ñ'
      },
      cyber: {
        name: 'ü§ñ Cyber Revolution',
        description: 'High-tech cyberpunk with robotic pieces and electronic sounds',
        theme: 'cyber',
        whiteSkin: 'robots',
        blackSkin: 'robots',
        effect: 'cyber',
        soundPack: 'cyber',
        cost: 280,
        icon: 'ü§ñ'
      },
      royal: {
        name: 'üëë Royal Majesty',
        description: 'Elegant royal court with regal pieces and classical sounds',
        theme: 'royal',
        whiteSkin: 'fantasy',
        blackSkin: 'fantasy',
        effect: 'golden',
        soundPack: 'royal',
        cost: 260,
        icon: 'üëë'
      },
      minimal: {
        name: '‚ö™ Minimal Zen',
        description: 'Clean minimalist design with simple pieces and peaceful sounds',
        theme: 'minimal',
        whiteSkin: 'default',
        blackSkin: 'default',
        effect: 'zen',
        soundPack: 'minimal',
        cost: 120,
        icon: '‚ö™'
      },
      fire: {
        name: 'üî• Inferno Pack',
        description: 'Blazing hot theme with fire pieces and burning sound effects',
        theme: 'fire',
        whiteSkin: 'default',
        blackSkin: 'default',
        effect: null,
        soundPack: 'fire',
        cost: 180,
        icon: 'üî•'
      },
      ice: {
        name: '‚ùÑÔ∏è Arctic Pack',
        description: 'Frozen arctic theme with ice pieces and chilling sounds',
        theme: 'ice',
        whiteSkin: 'default',
        blackSkin: 'default',
        effect: null,
        soundPack: 'ice',
        cost: 160,
        icon: '‚ùÑÔ∏è'
      },
      storm: {
        name: '‚õàÔ∏è Storm Pack',
        description: 'Thunderous weather theme with storm pieces and dramatic sounds',
        theme: 'storm',
        whiteSkin: 'weather',
        blackSkin: 'weather',
        effect: null,
        soundPack: 'storm',
        cost: 200,
        icon: '‚õàÔ∏è'
      },
      rainbow: {
        name: 'üåà Rainbow Pride',
        description: 'Colorful rainbow theme with vibrant pieces and joyful sounds',
        theme: 'rainbow',
        whiteSkin: 'party',
        blackSkin: 'party',
        effect: null,
        soundPack: 'rainbow',
        cost: 220,
        icon: 'üåà'
      },
      neon: {
        name: 'üí´ Neon Nights',
        description: 'Electric neon theme with glowing pieces and synth sounds',
        theme: 'neon',
        whiteSkin: 'robots',
        blackSkin: 'robots',
        effect: null,
        soundPack: 'neon',
        cost: 260,
        icon: 'üí´'
      },
      casino: {
        name: 'üé∞ Vegas Nights',
        description: 'Casino gambling theme with lucky pieces and jackpot sounds',
        theme: 'casino',
        whiteSkin: 'gems',
        blackSkin: 'gems',
        effect: null,
        soundPack: 'casino',
        cost: 200,
        icon: 'üé∞'
      },
      halloween: {
        name: 'üéÉ Halloween Spooky',
        description: 'Spooky Halloween theme with ghostly pieces and horror sounds',
        theme: 'halloween',
        whiteSkin: 'default',
        blackSkin: 'default',
        effect: null,
        soundPack: 'halloween',
        cost: 180,
        icon: 'üéÉ'
      },
      christmas: {
        name: 'üéÑ Christmas Joy',
        description: 'Festive Christmas theme with holiday pieces and jolly sounds',
        theme: 'christmas',
        whiteSkin: 'candy',
        blackSkin: 'candy',
        effect: null,
        soundPack: 'christmas',
        cost: 160,
        icon: 'üéÑ'
      },
    };

    // Sound pack settings with frequencies and characteristics
    const soundPackSettings = {
      classic: {
        move: { frequency: 440, duration: 0.1, type: 'sine', volume: 0.3 },
        capture: { frequency: 880, duration: 0.2, type: 'square', volume: 0.4 },
        button: { frequency: 600, duration: 0.05, type: 'sine', volume: 0.2 },
        coins: { frequency: 1200, duration: 0.15, type: 'triangle', volume: 0.3 },
        error: { frequency: 200, duration: 0.3, type: 'sawtooth', volume: 0.3 },
        promotion: { frequency: 1320, duration: 0.25, type: 'triangle', volume: 0.35 },
        powerUp: { frequency: 990, duration: 0.18, type: 'sine', volume: 0.3 },
        check: { frequency: 330, duration: 0.15, type: 'square', volume: 0.25 },
        gameOver: { frequency: 220, duration: 0.4, type: 'sawtooth', volume: 0.35 },
        modalOpen: { frequency: 550, duration: 0.08, type: 'sine', volume: 0.2 },
        modalClose: { frequency: 440, duration: 0.06, type: 'sine', volume: 0.15 },
        select: { frequency: 770, duration: 0.07, type: 'triangle', volume: 0.25 },
        shop: { frequency: 660, duration: 0.09, type: 'sine', volume: 0.2 },
        buy: { frequency: 1320, duration: 0.12, type: 'triangle', volume: 0.3 },
        welcome: { frequency: 523, duration: 0.3, type: 'sine', volume: 0.25 },
        loading: { frequency: 440, duration: 0.2, type: 'sine', volume: 0.2 },
        roomCreated: { frequency: 880, duration: 0.2, type: 'triangle', volume: 0.3 },
        roomJoined: { frequency: 660, duration: 0.15, type: 'sine', volume: 0.25 }
      },
      retro: {
        move: { frequency: 220, duration: 0.08, type: 'square', volume: 0.2 },
        capture: { frequency: 440, duration: 0.15, type: 'square', volume: 0.3 },
        button: { frequency: 330, duration: 0.04, type: 'square', volume: 0.15 },
        coins: { frequency: 880, duration: 0.12, type: 'square', volume: 0.25 },
        error: { frequency: 110, duration: 0.25, type: 'square', volume: 0.25 },
        promotion: { frequency: 660, duration: 0.2, type: 'square', volume: 0.3 },
        powerUp: { frequency: 550, duration: 0.15, type: 'square', volume: 0.25 },
        check: { frequency: 165, duration: 0.12, type: 'square', volume: 0.2 },
        gameOver: { frequency: 82.5, duration: 0.35, type: 'square', volume: 0.3 },
        modalOpen: { frequency: 275, duration: 0.06, type: 'square', volume: 0.15 },
        modalClose: { frequency: 220, duration: 0.05, type: 'square', volume: 0.12 },
        select: { frequency: 440, duration: 0.05, type: 'square', volume: 0.2 },
        shop: { frequency: 330, duration: 0.07, type: 'square', volume: 0.15 },
        buy: { frequency: 660, duration: 0.1, type: 'square', volume: 0.25 },
        welcome: { frequency: 246.94, duration: 0.25, type: 'square', volume: 0.2 },
        loading: { frequency: 220, duration: 0.15, type: 'square', volume: 0.15 },
        roomCreated: { frequency: 440, duration: 0.15, type: 'square', volume: 0.25 },
        roomJoined: { frequency: 330, duration: 0.12, type: 'square', volume: 0.2 }
      },
      nature: {
        move: { frequency: 261.63, duration: 0.12, type: 'sine', volume: 0.25 },
        capture: { frequency: 523.25, duration: 0.25, type: 'sine', volume: 0.35 },
        button: { frequency: 329.63, duration: 0.06, type: 'sine', volume: 0.2 },
        coins: { frequency: 783.99, duration: 0.18, type: 'sine', volume: 0.3 },
        error: { frequency: 196, duration: 0.35, type: 'sine', volume: 0.25 },
        promotion: { frequency: 1046.5, duration: 0.3, type: 'sine', volume: 0.4 },
        powerUp: { frequency: 659.25, duration: 0.2, type: 'sine', volume: 0.3 },
        check: { frequency: 246.94, duration: 0.18, type: 'sine', volume: 0.2 },
        gameOver: { frequency: 174.61, duration: 0.45, type: 'sine', volume: 0.3 },
        modalOpen: { frequency: 392, duration: 0.1, type: 'sine', volume: 0.2 },
        modalClose: { frequency: 329.63, duration: 0.08, type: 'sine', volume: 0.15 },
        select: { frequency: 523.25, duration: 0.08, type: 'sine', volume: 0.25 },
        shop: { frequency: 440, duration: 0.11, type: 'sine', volume: 0.2 },
        buy: { frequency: 1046.5, duration: 0.15, type: 'sine', volume: 0.3 },
        welcome: { frequency: 329.63, duration: 0.35, type: 'sine', volume: 0.25 },
        loading: { frequency: 261.63, duration: 0.25, type: 'sine', volume: 0.2 },
        roomCreated: { frequency: 523.25, duration: 0.25, type: 'sine', volume: 0.3 },
        roomJoined: { frequency: 392, duration: 0.18, type: 'sine', volume: 0.25 }
      },
      medieval: {
        move: { frequency: 130.81, duration: 0.15, type: 'sawtooth', volume: 0.3 },
        capture: { frequency: 196, duration: 0.3, type: 'sawtooth', volume: 0.4 },
        button: { frequency: 164.81, duration: 0.08, type: 'sawtooth', volume: 0.25 },
        coins: { frequency: 261.63, duration: 0.2, type: 'sawtooth', volume: 0.35 },
        error: { frequency: 98, duration: 0.4, type: 'sawtooth', volume: 0.35 },
        promotion: { frequency: 329.63, duration: 0.35, type: 'sawtooth', volume: 0.4 },
        powerUp: { frequency: 220, duration: 0.25, type: 'sawtooth', volume: 0.35 },
        check: { frequency: 146.83, duration: 0.2, type: 'sawtooth', volume: 0.3 },
        gameOver: { frequency: 110, duration: 0.5, type: 'sawtooth', volume: 0.4 },
        modalOpen: { frequency: 174.61, duration: 0.12, type: 'sawtooth', volume: 0.25 },
        modalClose: { frequency: 146.83, duration: 0.1, type: 'sawtooth', volume: 0.2 },
        select: { frequency: 246.94, duration: 0.1, type: 'sawtooth', volume: 0.3 },
        shop: { frequency: 196, duration: 0.13, type: 'sawtooth', volume: 0.25 },
        buy: { frequency: 329.63, duration: 0.18, type: 'sawtooth', volume: 0.35 },
        welcome: { frequency: 164.81, duration: 0.4, type: 'sawtooth', volume: 0.3 },
        loading: { frequency: 130.81, duration: 0.3, type: 'sawtooth', volume: 0.25 },
        roomCreated: { frequency: 196, duration: 0.3, type: 'sawtooth', volume: 0.35 },
        roomJoined: { frequency: 174.61, duration: 0.22, type: 'sawtooth', volume: 0.3 }
      },
      space: {
        move: { frequency: 880, duration: 0.08, type: 'sine', volume: 0.25 },
        capture: { frequency: 1760, duration: 0.15, type: 'sine', volume: 0.35 },
        button: { frequency: 1320, duration: 0.04, type: 'sine', volume: 0.2 },
        coins: { frequency: 3520, duration: 0.12, type: 'sine', volume: 0.3 },
        error: { frequency: 440, duration: 0.25, type: 'sine', volume: 0.25 },
        promotion: { frequency: 2640, duration: 0.2, type: 'sine', volume: 0.4 },
        powerUp: { frequency: 1980, duration: 0.15, type: 'sine', volume: 0.3 },
        check: { frequency: 660, duration: 0.12, type: 'sine', volume: 0.2 },
        gameOver: { frequency: 330, duration: 0.35, type: 'sine', volume: 0.3 },
        modalOpen: { frequency: 1100, duration: 0.06, type: 'sine', volume: 0.2 },
        modalClose: { frequency: 880, duration: 0.05, type: 'sine', volume: 0.15 },
        select: { frequency: 1540, duration: 0.06, type: 'sine', volume: 0.25 },
        shop: { frequency: 1320, duration: 0.08, type: 'sine', volume: 0.2 },
        buy: { frequency: 2640, duration: 0.1, type: 'sine', volume: 0.3 },
        welcome: { frequency: 990, duration: 0.25, type: 'sine', volume: 0.25 },
        loading: { frequency: 880, duration: 0.18, type: 'sine', volume: 0.2 },
        roomCreated: { frequency: 1760, duration: 0.18, type: 'sine', volume: 0.3 },
        roomJoined: { frequency: 1320, duration: 0.14, type: 'sine', volume: 0.25 }
      },
      ocean: {
        move: { frequency: 196, duration: 0.14, type: 'sine', volume: 0.2 },
        capture: { frequency: 392, duration: 0.28, type: 'sine', volume: 0.3 },
        button: { frequency: 261.63, duration: 0.07, type: 'sine', volume: 0.15 },
        coins: { frequency: 587.33, duration: 0.16, type: 'sine', volume: 0.25 },
        error: { frequency: 146.83, duration: 0.38, type: 'sine', volume: 0.2 },
        promotion: { frequency: 783.99, duration: 0.32, type: 'sine', volume: 0.35 },
        powerUp: { frequency: 440, duration: 0.22, type: 'sine', volume: 0.25 },
        check: { frequency: 220, duration: 0.16, type: 'sine', volume: 0.15 },
        gameOver: { frequency: 164.81, duration: 0.48, type: 'sine', volume: 0.25 },
        modalOpen: { frequency: 329.63, duration: 0.11, type: 'sine', volume: 0.15 },
        modalClose: { frequency: 261.63, duration: 0.09, type: 'sine', volume: 0.12 },
        select: { frequency: 523.25, duration: 0.09, type: 'sine', volume: 0.2 },
        shop: { frequency: 392, duration: 0.12, type: 'sine', volume: 0.15 },
        buy: { frequency: 783.99, duration: 0.14, type: 'sine', volume: 0.25 },
        welcome: { frequency: 329.63, duration: 0.38, type: 'sine', volume: 0.2 },
        loading: { frequency: 196, duration: 0.28, type: 'sine', volume: 0.15 },
        roomCreated: { frequency: 392, duration: 0.28, type: 'sine', volume: 0.25 },
        roomJoined: { frequency: 329.63, duration: 0.2, type: 'sine', volume: 0.2 }
      },
      forest: {
        move: { frequency: 293.66, duration: 0.13, type: 'triangle', volume: 0.22 },
        capture: { frequency: 587.33, duration: 0.26, type: 'triangle', volume: 0.32 },
        button: { frequency: 369.99, duration: 0.06, type: 'triangle', volume: 0.17 },
        coins: { frequency: 880, duration: 0.15, type: 'triangle', volume: 0.27 },
        error: { frequency: 220, duration: 0.36, type: 'triangle', volume: 0.22 },
        promotion: { frequency: 1174.66, duration: 0.3, type: 'triangle', volume: 0.37 },
        powerUp: { frequency: 440, duration: 0.21, type: 'triangle', volume: 0.27 },
        check: { frequency: 261.63, duration: 0.15, type: 'triangle', volume: 0.17 },
        gameOver: { frequency: 196, duration: 0.46, type: 'triangle', volume: 0.27 },
        modalOpen: { frequency: 493.88, duration: 0.1, type: 'triangle', volume: 0.17 },
        modalClose: { frequency: 369.99, duration: 0.08, type: 'triangle', volume: 0.13 },
        select: { frequency: 659.25, duration: 0.08, type: 'triangle', volume: 0.22 },
        shop: { frequency: 523.25, duration: 0.11, type: 'triangle', volume: 0.17 },
        buy: { frequency: 1174.66, duration: 0.13, type: 'triangle', volume: 0.27 },
        welcome: { frequency: 369.99, duration: 0.36, type: 'triangle', volume: 0.22 },
        loading: { frequency: 293.66, duration: 0.26, type: 'triangle', volume: 0.17 },
        roomCreated: { frequency: 587.33, duration: 0.26, type: 'triangle', volume: 0.27 },
        roomJoined: { frequency: 493.88, duration: 0.19, type: 'triangle', volume: 0.22 }
      },
      magical: {
        move: { frequency: 523.25, duration: 0.11, type: 'triangle', volume: 0.28 },
        capture: { frequency: 1046.5, duration: 0.22, type: 'triangle', volume: 0.38 },
        button: { frequency: 659.25, duration: 0.05, type: 'triangle', volume: 0.23 },
        coins: { frequency: 1568, duration: 0.13, type: 'triangle', volume: 0.33 },
        error: { frequency: 392, duration: 0.32, type: 'triangle', volume: 0.28 },
        promotion: { frequency: 2093, duration: 0.27, type: 'triangle', volume: 0.43 },
        powerUp: { frequency: 783.99, duration: 0.18, type: 'triangle', volume: 0.33 },
        check: { frequency: 440, duration: 0.13, type: 'triangle', volume: 0.23 },
        gameOver: { frequency: 329.63, duration: 0.42, type: 'triangle', volume: 0.33 },
        modalOpen: { frequency: 880, duration: 0.08, type: 'triangle', volume: 0.23 },
        modalClose: { frequency: 659.25, duration: 0.06, type: 'triangle', volume: 0.18 },
        select: { frequency: 1174.66, duration: 0.07, type: 'triangle', volume: 0.28 },
        shop: { frequency: 990, duration: 0.1, type: 'triangle', volume: 0.23 },
        buy: { frequency: 2093, duration: 0.12, type: 'triangle', volume: 0.33 },
        welcome: { frequency: 659.25, duration: 0.32, type: 'triangle', volume: 0.28 },
        loading: { frequency: 523.25, duration: 0.22, type: 'triangle', volume: 0.23 },
        roomCreated: { frequency: 1046.5, duration: 0.22, type: 'triangle', volume: 0.33 },
        roomJoined: { frequency: 880, duration: 0.16, type: 'triangle', volume: 0.28 }
      },
      cyber: {
        move: { frequency: 1320, duration: 0.06, type: 'square', volume: 0.26 },
        capture: { frequency: 2640, duration: 0.12, type: 'square', volume: 0.36 },
        button: { frequency: 1760, duration: 0.03, type: 'square', volume: 0.21 },
        coins: { frequency: 5280, duration: 0.11, type: 'square', volume: 0.31 },
        error: { frequency: 880, duration: 0.28, type: 'square', volume: 0.26 },
        promotion: { frequency: 3960, duration: 0.23, type: 'square', volume: 0.41 },
        powerUp: { frequency: 2200, duration: 0.15, type: 'square', volume: 0.31 },
        check: { frequency: 1100, duration: 0.11, type: 'square', volume: 0.21 },
        gameOver: { frequency: 660, duration: 0.38, type: 'square', volume: 0.31 },
        modalOpen: { frequency: 2420, duration: 0.06, type: 'square', volume: 0.21 },
        modalClose: { frequency: 1760, duration: 0.04, type: 'square', volume: 0.16 },
        select: { frequency: 3080, duration: 0.05, type: 'square', volume: 0.26 },
        shop: { frequency: 2640, duration: 0.08, type: 'square', volume: 0.21 },
        buy: { frequency: 3960, duration: 0.1, type: 'square', volume: 0.31 },
        welcome: { frequency: 1760, duration: 0.28, type: 'square', volume: 0.26 },
        loading: { frequency: 1320, duration: 0.18, type: 'square', volume: 0.21 },
        roomCreated: { frequency: 2640, duration: 0.18, type: 'square', volume: 0.31 },
        roomJoined: { frequency: 2200, duration: 0.13, type: 'square', volume: 0.26 }
      },
      royal: {
        move: { frequency: 415.3, duration: 0.12, type: 'sine', volume: 0.24 },
        capture: { frequency: 830.61, duration: 0.24, type: 'sine', volume: 0.34 },
        button: { frequency: 554.37, duration: 0.06, type: 'sine', volume: 0.19 },
        coins: { frequency: 1661.22, duration: 0.14, type: 'sine', volume: 0.29 },
        error: { frequency: 311.13, duration: 0.34, type: 'sine', volume: 0.24 },
        promotion: { frequency: 2489.02, duration: 0.29, type: 'sine', volume: 0.39 },
        powerUp: { frequency: 1108.73, duration: 0.19, type: 'sine', volume: 0.29 },
        check: { frequency: 369.99, duration: 0.14, type: 'sine', volume: 0.19 },
        gameOver: { frequency: 277.18, duration: 0.44, type: 'sine', volume: 0.29 },
        modalOpen: { frequency: 698.46, duration: 0.09, type: 'sine', volume: 0.19 },
        modalClose: { frequency: 554.37, duration: 0.07, type: 'sine', volume: 0.14 },
        select: { frequency: 1244.51, duration: 0.08, type: 'sine', volume: 0.24 },
        shop: { frequency: 1046.5, duration: 0.11, type: 'sine', volume: 0.19 },
        buy: { frequency: 2489.02, duration: 0.13, type: 'sine', volume: 0.29 },
        welcome: { frequency: 554.37, duration: 0.34, type: 'sine', volume: 0.24 },
        loading: { frequency: 415.3, duration: 0.24, type: 'sine', volume: 0.19 },
        roomCreated: { frequency: 830.61, duration: 0.24, type: 'sine', volume: 0.29 },
        roomJoined: { frequency: 698.46, duration: 0.18, type: 'sine', volume: 0.24 }
      },
      minimal: {
        move: { frequency: 800, duration: 0.05, type: 'sine', volume: 0.15 },
        capture: { frequency: 1000, duration: 0.1, type: 'sine', volume: 0.2 },
        button: { frequency: 600, duration: 0.03, type: 'sine', volume: 0.1 },
        coins: { frequency: 1200, duration: 0.08, type: 'sine', volume: 0.18 },
        error: { frequency: 300, duration: 0.15, type: 'sine', volume: 0.15 },
        promotion: { frequency: 1400, duration: 0.12, type: 'sine', volume: 0.22 },
        powerUp: { frequency: 900, duration: 0.08, type: 'sine', volume: 0.18 },
        check: { frequency: 400, duration: 0.08, type: 'sine', volume: 0.12 },
        gameOver: { frequency: 200, duration: 0.2, type: 'sine', volume: 0.18 },
        modalOpen: { frequency: 700, duration: 0.04, type: 'sine', volume: 0.1 },
        modalClose: { frequency: 500, duration: 0.03, type: 'sine', volume: 0.08 },
        select: { frequency: 1100, duration: 0.04, type: 'sine', volume: 0.15 },
        shop: { frequency: 650, duration: 0.06, type: 'sine', volume: 0.1 },
        buy: { frequency: 1400, duration: 0.08, type: 'sine', volume: 0.18 },
        welcome: { frequency: 750, duration: 0.15, type: 'sine', volume: 0.12 },
        loading: { frequency: 550, duration: 0.1, type: 'sine', volume: 0.1 },
        roomCreated: { frequency: 1000, duration: 0.1, type: 'sine', volume: 0.18 },
        roomJoined: { frequency: 800, duration: 0.08, type: 'sine', volume: 0.15 }
      },
      fire: {
        move: { frequency: 220, duration: 0.12, type: 'sawtooth', volume: 0.25 },
        capture: { frequency: 110, duration: 0.25, type: 'sawtooth', volume: 0.35 },
        button: { frequency: 330, duration: 0.06, type: 'sawtooth', volume: 0.2 },
        coins: { frequency: 440, duration: 0.15, type: 'sawtooth', volume: 0.3 },
        error: { frequency: 165, duration: 0.3, type: 'sawtooth', volume: 0.25 },
        promotion: { frequency: 550, duration: 0.2, type: 'sawtooth', volume: 0.4 },
        powerUp: { frequency: 660, duration: 0.15, type: 'sawtooth', volume: 0.3 },
        check: { frequency: 196, duration: 0.14, type: 'sawtooth', volume: 0.2 },
        gameOver: { frequency: 110, duration: 0.4, type: 'sawtooth', volume: 0.3 },
        modalOpen: { frequency: 293.66, duration: 0.08, type: 'sawtooth', volume: 0.2 },
        modalClose: { frequency: 246.94, duration: 0.06, type: 'sawtooth', volume: 0.15 },
        select: { frequency: 392, duration: 0.08, type: 'sawtooth', volume: 0.25 },
        shop: { frequency: 330, duration: 0.1, type: 'sawtooth', volume: 0.2 },
        buy: { frequency: 880, duration: 0.12, type: 'sawtooth', volume: 0.3 },
        welcome: { frequency: 220, duration: 0.35, type: 'sawtooth', volume: 0.25 },
        loading: { frequency: 196, duration: 0.25, type: 'sawtooth', volume: 0.2 },
        roomCreated: { frequency: 440, duration: 0.25, type: 'sawtooth', volume: 0.35 },
        roomJoined: { frequency: 330, duration: 0.18, type: 'sawtooth', volume: 0.3 }
      },
      ice: {
        move: { frequency: 880, duration: 0.08, type: 'triangle', volume: 0.2 },
        capture: { frequency: 1760, duration: 0.16, type: 'triangle', volume: 0.3 },
        button: { frequency: 1320, duration: 0.04, type: 'triangle', volume: 0.15 },
        coins: { frequency: 3520, duration: 0.1, type: 'triangle', volume: 0.25 },
        error: { frequency: 440, duration: 0.2, type: 'triangle', volume: 0.2 },
        promotion: { frequency: 2640, duration: 0.18, type: 'triangle', volume: 0.35 },
        powerUp: { frequency: 1980, duration: 0.12, type: 'triangle', volume: 0.25 },
        check: { frequency: 660, duration: 0.1, type: 'triangle', volume: 0.15 },
        gameOver: { frequency: 330, duration: 0.3, type: 'triangle', volume: 0.25 },
        modalOpen: { frequency: 1100, duration: 0.05, type: 'triangle', volume: 0.15 },
        modalClose: { frequency: 880, duration: 0.04, type: 'triangle', volume: 0.12 },
        select: { frequency: 1540, duration: 0.05, type: 'triangle', volume: 0.2 },
        shop: { frequency: 1320, duration: 0.07, type: 'triangle', volume: 0.15 },
        buy: { frequency: 2640, duration: 0.09, type: 'triangle', volume: 0.25 },
        welcome: { frequency: 990, duration: 0.22, type: 'triangle', volume: 0.2 },
        loading: { frequency: 880, duration: 0.15, type: 'triangle', volume: 0.15 },
        roomCreated: { frequency: 1760, duration: 0.15, type: 'triangle', volume: 0.25 },
        roomJoined: { frequency: 1320, duration: 0.12, type: 'triangle', volume: 0.2 }
      },
      storm: {
        move: { frequency: 130.81, duration: 0.15, type: 'square', volume: 0.3 },
        capture: { frequency: 65.41, duration: 0.3, type: 'square', volume: 0.4 },
        button: { frequency: 196, duration: 0.07, type: 'square', volume: 0.25 },
        coins: { frequency: 261.63, duration: 0.18, type: 'square', volume: 0.35 },
        error: { frequency: 98, duration: 0.35, type: 'square', volume: 0.3 },
        promotion: { frequency: 329.63, duration: 0.25, type: 'square', volume: 0.45 },
        powerUp: { frequency: 392, duration: 0.18, type: 'square', volume: 0.35 },
        check: { frequency: 146.83, duration: 0.18, type: 'square', volume: 0.25 },
        gameOver: { frequency: 82.41, duration: 0.45, type: 'square', volume: 0.35 },
        modalOpen: { frequency: 174.61, duration: 0.1, type: 'square', volume: 0.25 },
        modalClose: { frequency: 146.83, duration: 0.08, type: 'square', volume: 0.2 },
        select: { frequency: 246.94, duration: 0.1, type: 'square', volume: 0.3 },
        shop: { frequency: 196, duration: 0.12, type: 'square', volume: 0.25 },
        buy: { frequency: 523.25, duration: 0.15, type: 'square', volume: 0.35 },
        welcome: { frequency: 130.81, duration: 0.4, type: 'square', volume: 0.3 },
        loading: { frequency: 110, duration: 0.3, type: 'square', volume: 0.25 },
        roomCreated: { frequency: 261.63, duration: 0.3, type: 'square', volume: 0.4 },
        roomJoined: { frequency: 196, duration: 0.22, type: 'square', volume: 0.35 }
      },
      rainbow: {
        move: { frequency: 523.25, duration: 0.08, type: 'sine', volume: 0.25 },
        capture: { frequency: 1046.5, duration: 0.16, type: 'sine', volume: 0.35 },
        button: { frequency: 783.99, duration: 0.04, type: 'sine', volume: 0.2 },
        coins: { frequency: 2093, duration: 0.12, type: 'sine', volume: 0.3 },
        error: { frequency: 261.63, duration: 0.2, type: 'sine', volume: 0.25 },
        promotion: { frequency: 1567.98, duration: 0.18, type: 'sine', volume: 0.4 },
        powerUp: { frequency: 1174.66, duration: 0.12, type: 'sine', volume: 0.3 },
        check: { frequency: 392, duration: 0.1, type: 'sine', volume: 0.2 },
        gameOver: { frequency: 196, duration: 0.3, type: 'sine', volume: 0.3 },
        modalOpen: { frequency: 659.25, duration: 0.06, type: 'sine', volume: 0.2 },
        modalClose: { frequency: 523.25, duration: 0.05, type: 'sine', volume: 0.15 },
        select: { frequency: 932.33, duration: 0.06, type: 'sine', volume: 0.25 },
        shop: { frequency: 783.99, duration: 0.09, type: 'sine', volume: 0.2 },
        buy: { frequency: 1567.98, duration: 0.11, type: 'sine', volume: 0.3 },
        welcome: { frequency: 587.33, duration: 0.25, type: 'sine', volume: 0.25 },
        loading: { frequency: 523.25, duration: 0.18, type: 'sine', volume: 0.2 },
        roomCreated: { frequency: 1046.5, duration: 0.18, type: 'sine', volume: 0.3 },
        roomJoined: { frequency: 783.99, duration: 0.14, type: 'sine', volume: 0.25 }
      },
      neon: {
        move: { frequency: 932.33, duration: 0.06, type: 'sawtooth', volume: 0.3 },
        capture: { frequency: 1864.66, duration: 0.12, type: 'sawtooth', volume: 0.4 },
        button: { frequency: 1396.91, duration: 0.03, type: 'sawtooth', volume: 0.25 },
        coins: { frequency: 2793.83, duration: 0.09, type: 'sawtooth', volume: 0.35 },
        error: { frequency: 466.16, duration: 0.18, type: 'sawtooth', volume: 0.3 },
        promotion: { frequency: 2793.83, duration: 0.15, type: 'sawtooth', volume: 0.45 },
        powerUp: { frequency: 2093, duration: 0.1, type: 'sawtooth', volume: 0.35 },
        check: { frequency: 698.46, duration: 0.08, type: 'sawtooth', volume: 0.25 },
        gameOver: { frequency: 349.23, duration: 0.25, type: 'sawtooth', volume: 0.35 },
        modalOpen: { frequency: 1174.66, duration: 0.04, type: 'sawtooth', volume: 0.25 },
        modalClose: { frequency: 932.33, duration: 0.03, type: 'sawtooth', volume: 0.2 },
        select: { frequency: 1661.22, duration: 0.04, type: 'sawtooth', volume: 0.3 },
        shop: { frequency: 1396.91, duration: 0.07, type: 'sawtooth', volume: 0.25 },
        buy: { frequency: 2793.83, duration: 0.09, type: 'sawtooth', volume: 0.35 },
        welcome: { frequency: 1046.5, duration: 0.2, type: 'sawtooth', volume: 0.3 },
        loading: { frequency: 932.33, duration: 0.15, type: 'sawtooth', volume: 0.25 },
        roomCreated: { frequency: 1864.66, duration: 0.15, type: 'sawtooth', volume: 0.35 },
        roomJoined: { frequency: 1396.91, duration: 0.11, type: 'sawtooth', volume: 0.3 }
      },
      casino: {
        move: { frequency: 587.33, duration: 0.1, type: 'square', volume: 0.25 },
        capture: { frequency: 1174.66, duration: 0.2, type: 'square', volume: 0.35 },
        button: { frequency: 880, duration: 0.05, type: 'square', volume: 0.2 },
        coins: { frequency: 2349.32, duration: 0.15, type: 'square', volume: 0.3 },
        error: { frequency: 293.66, duration: 0.25, type: 'square', volume: 0.25 },
        promotion: { frequency: 1760, duration: 0.22, type: 'square', volume: 0.4 },
        powerUp: { frequency: 1318.51, duration: 0.15, type: 'square', volume: 0.3 },
        check: { frequency: 440, duration: 0.12, type: 'square', volume: 0.2 },
        gameOver: { frequency: 220, duration: 0.35, type: 'square', volume: 0.3 },
        modalOpen: { frequency: 739.99, duration: 0.08, type: 'square', volume: 0.2 },
        modalClose: { frequency: 587.33, duration: 0.06, type: 'square', volume: 0.15 },
        select: { frequency: 1046.5, duration: 0.08, type: 'square', volume: 0.25 },
        shop: { frequency: 880, duration: 0.11, type: 'square', volume: 0.2 },
        buy: { frequency: 1760, duration: 0.13, type: 'square', volume: 0.3 },
        welcome: { frequency: 659.25, duration: 0.3, type: 'square', volume: 0.25 },
        loading: { frequency: 587.33, duration: 0.22, type: 'square', volume: 0.2 },
        roomCreated: { frequency: 1174.66, duration: 0.22, type: 'square', volume: 0.3 },
        roomJoined: { frequency: 880, duration: 0.16, type: 'square', volume: 0.25 }
      },
      halloween: {
        move: { frequency: 196, duration: 0.12, type: 'triangle', volume: 0.2 },
        capture: { frequency: 98, duration: 0.24, type: 'triangle', volume: 0.3 },
        button: { frequency: 293.66, duration: 0.06, type: 'triangle', volume: 0.15 },
        coins: { frequency: 392, duration: 0.18, type: 'triangle', volume: 0.25 },
        error: { frequency: 146.83, duration: 0.3, type: 'triangle', volume: 0.2 },
        promotion: { frequency: 523.25, duration: 0.26, type: 'triangle', volume: 0.35 },
        powerUp: { frequency: 440, duration: 0.18, type: 'triangle', volume: 0.25 },
        check: { frequency: 246.94, duration: 0.14, type: 'triangle', volume: 0.15 },
        gameOver: { frequency: 130.81, duration: 0.4, type: 'triangle', volume: 0.25 },
        modalOpen: { frequency: 329.63, duration: 0.09, type: 'triangle', volume: 0.15 },
        modalClose: { frequency: 261.63, duration: 0.07, type: 'triangle', volume: 0.12 },
        select: { frequency: 440, duration: 0.09, type: 'triangle', volume: 0.2 },
        shop: { frequency: 349.23, duration: 0.12, type: 'triangle', volume: 0.15 },
        buy: { frequency: 698.46, duration: 0.14, type: 'triangle', volume: 0.25 },
        welcome: { frequency: 293.66, duration: 0.32, type: 'triangle', volume: 0.2 },
        loading: { frequency: 246.94, duration: 0.24, type: 'triangle', volume: 0.15 },
        roomCreated: { frequency: 440, duration: 0.24, type: 'triangle', volume: 0.25 },
        roomJoined: { frequency: 349.23, duration: 0.18, type: 'triangle', volume: 0.2 }
      },
      christmas: {
        move: { frequency: 523.25, duration: 0.09, type: 'sine', volume: 0.22 },
        capture: { frequency: 1046.5, duration: 0.18, type: 'sine', volume: 0.32 },
        button: { frequency: 783.99, duration: 0.045, type: 'sine', volume: 0.17 },
        coins: { frequency: 1318.51, duration: 0.135, type: 'sine', volume: 0.27 },
        error: { frequency: 392, duration: 0.27, type: 'sine', volume: 0.22 },
        promotion: { frequency: 1567.98, duration: 0.24, type: 'sine', volume: 0.37 },
        powerUp: { frequency: 987.77, duration: 0.135, type: 'sine', volume: 0.27 },
        check: { frequency: 440, duration: 0.11, type: 'sine', volume: 0.17 },
        gameOver: { frequency: 329.63, duration: 0.33, type: 'sine', volume: 0.27 },
        modalOpen: { frequency: 659.25, duration: 0.07, type: 'sine', volume: 0.17 },
        modalClose: { frequency: 523.25, duration: 0.055, type: 'sine', volume: 0.13 },
        select: { frequency: 880, duration: 0.07, type: 'sine', volume: 0.22 },
        shop: { frequency: 698.46, duration: 0.105, type: 'sine', volume: 0.17 },
        buy: { frequency: 1318.51, duration: 0.125, type: 'sine', volume: 0.27 },
        welcome: { frequency: 587.33, duration: 0.285, type: 'sine', volume: 0.22 },
        loading: { frequency: 493.88, duration: 0.21, type: 'sine', volume: 0.17 },
        roomCreated: { frequency: 987.77, duration: 0.21, type: 'sine', volume: 0.27 },
        roomJoined: { frequency: 783.99, duration: 0.155, type: 'sine', volume: 0.22 }
      }
    };

    // Main sound playing function
    function playSound(soundName) {
      try {
        const audioContext = initializeAudioContext();
        if (!audioContext) {
          console.log('Audio context not available, skipping sound');
          return;
        }
        const currentPack = gameState.currentSoundPack || 'classic';
        const packSettings = soundPackSettings[currentPack];
        let soundType = 'button'; // default
        if (soundName === 'move') soundType = 'move';
        else if (soundName === 'capture') soundType = 'capture';
        else if (soundName === 'coins') soundType = 'coins';
        else if (soundName === 'error') soundType = 'error';
        else if (soundName === 'buttonClick') soundType = 'button';
        else if (soundName === 'buy') soundType = 'buy';
        else if (soundName === 'shop') soundType = 'shop';
        else if (soundName === 'promotion') soundType = 'promotion';
        else if (soundName === 'powerUp') soundType = 'powerUp';
        else if (soundName === 'check') soundType = 'check';
        else if (soundName === 'gameOver') soundType = 'gameOver';
        else if (soundName === 'modalOpen') soundType = 'modalOpen';
        else if (soundName === 'modalClose') soundType = 'modalClose';
        else if (soundName === 'select') soundType = 'select';
        else if (soundName === 'welcome') soundType = 'welcome';
        else if (soundName === 'loading') soundType = 'loading';
        else if (soundName === 'roomCreated') soundType = 'roomCreated';
        else if (soundName === 'roomJoined') soundType = 'roomJoined';
        
        if (packSettings && packSettings[soundType]) {
          generateDynamicSound(packSettings[soundType]);
        } else {
          generateDynamicSound({
            frequency: 440 + (soundType.length * 20),
            duration: 0.1,
            type: 'sine',
            volume: 0.2
          });
        }
      } catch (e) {
        console.log('Sound system error:', e);
      }
    }

    // Specific sound functions
    function playShopSound() { 
      playSound('shop'); 
    }

    function playBuySound() { 
      playSound('buy'); 
    }

    function playButtonSound() {
      playSound('buttonClick');
    }

    function playErrorSound() {
      playSound('error');
    }

    function playWelcomeSound() {
      playSound('welcome');
    }

    let allGameRecords = [];
    let hostColorChoice = 'white';
    let syncInterval = null;

    const whitePieces = ['‚ôî', '‚ôï', '‚ôñ', '‚ôó', '‚ôò', '‚ôô'];
    const blackPieces = ['‚ôö', '‚ôõ', '‚ôú', '‚ôù', '‚ôû', '‚ôü'];
    
    const powerUpsData = {
      undo: { icon: '‚è™', name: 'Undo Move', description: 'Take back your last move', cost: 30 },
      hint: { icon: 'üí°', name: 'Hint', description: 'Show a valid move', cost: 25 },
      shield: { icon: 'üõ°', name: 'Shield', description: 'Protect from next capture', cost: 40 },
      double_coins: { icon: 'üí∞', name: '2x Coins', description: 'Double coins for 5 moves', cost: 50 },
      freeze: { icon: '‚ùÑ', name: 'Freeze', description: 'Opponent skips next turn', cost: 60 },
      knight_boost: { icon: 'üê¥', name: 'Knight Boost', description: 'Knights move 2x for 3 turns', cost: 55 },
      vision: { icon: 'üëÅ', name: 'Vision', description: 'Show all valid moves 3 turns', cost: 45 },
      swap: { icon: 'üîÑ', name: 'Piece Swap', description: 'Swap any two of your pieces', cost: 65 },
      bomb: { icon: 'üí£', name: 'Bomb', description: 'Remove any enemy piece', cost: 80 },
      time_warp: { icon: '‚è±', name: 'Time Warp', description: 'Take 2 turns in a row', cost: 75 },
      
      // NEW POWER-UPS
      lightning: { icon: '‚ö°', name: 'Lightning Strike', description: 'Remove all pieces in a row/column', cost: 120 },
      heal: { icon: 'üíö', name: 'Heal', description: 'Restore one captured piece', cost: 100 },
      clone: { icon: 'üë•', name: 'Clone', description: 'Duplicate any of your pawns', cost: 90 },
      magnet: { icon: 'üß≤', name: 'Magnet', description: 'Pull enemy pieces closer', cost: 70 },
      poison: { icon: '‚ò†Ô∏è', name: 'Poison', description: 'Enemy piece dies in 2 turns', cost: 95 },
      shield_wall: { icon: 'üè∞', name: 'Shield Wall', description: 'Protect entire back row', cost: 110 },
      speed_boost: { icon: 'üöÄ', name: 'Speed Boost', description: 'Move twice this turn', cost: 130 },
      invisibility: { icon: 'üëª', name: 'Invisibility', description: 'Piece invisible for 3 turns', cost: 105 },
      earthquake: { icon: 'üåã', name: 'Earthquake', description: 'Shuffle all pieces randomly', cost: 140 },
      blizzard: { icon: 'üå®Ô∏è', name: 'Blizzard', description: 'Freeze all enemy pieces 2 turns', cost: 115 },
      laser: { icon: 'üî¥', name: 'Laser Beam', description: 'Remove piece in straight line', cost: 125 },
      mirror: { icon: 'ü™û', name: 'Mirror', description: 'Copy enemy\'s last move', cost: 80 },
      tornado: { icon: 'üå™Ô∏è', name: 'Tornado', description: 'Spin pieces in 3x3 area', cost: 135 },
      gravity: { icon: 'üåç', name: 'Gravity Flip', description: 'Pieces fall to bottom', cost: 95 },
      phoenix: { icon: 'üî•', name: 'Phoenix Rise', description: 'Revive your queen', cost: 150 },
      time_freeze: { icon: '‚è∞', name: 'Time Freeze', description: 'Stop timer for 1 minute', cost: 60 },
      coin_rain: { icon: 'ü™ô', name: 'Coin Rain', description: 'Get 50 free coins', cost: 40 },
      power_steal: { icon: 'üé≠', name: 'Power Steal', description: 'Steal random power-up', cost: 75 },
      mega_bomb: { icon: 'üí•', name: 'Mega Bomb', description: 'Remove 3x3 area of pieces', cost: 160 },
      royal_guard: { icon: '‚öîÔ∏è', name: 'Royal Guard', description: 'King immune 1 turn', cost: 85 },
      lucky_charm: { icon: 'üçÄ', name: 'Lucky Charm', description: 'Next move always succeeds', cost: 55 },
      chaos: { icon: 'üé≤', name: 'Chaos Roll', description: 'Random effect happens', cost: 45 }
    };
    
    const skins = {
      default: { name: 'Classic', white: whitePieces, black: blackPieces, cost: 0 },
      emoji: { name: 'üëë Emoji Fun', white: ['üëë', 'üíé', 'üè∞', '‚õ™', 'üê¥', '‚ö™'], black: ['üëë', 'üíé', 'üè∞', '‚õ™', 'üê¥', '‚ö´'], cost: 50 },
      animals: { name: 'ü¶Å Animal Kingdom', white: ['ü¶Å', 'ü¶Ö', 'üêò', 'ü¶¢', 'ü¶å', 'üêë'], black: ['ü¶Å', 'ü¶Ö', 'üêò', 'ü¶¢', 'ü¶å', 'üêë'], cost: 100 },
      fantasy: { name: 'üßö Fantasy', white: ['üë∏', 'üßö', 'üèØ', 'üí´', 'ü¶¢', '‚≠ê'], black: ['üë∏', 'üßö', 'üèØ', 'üí´', 'ü¶¢', '‚≠ê'], cost: 150 },
      ocean: { name: 'üåä Ocean Life', white: ['üêö', 'ü¶à', 'üèù', 'üåä', 'üê¨', '‚ö™'], black: ['üêö', 'ü¶à', 'üèù', 'üåä', 'üê¨', '‚ö™'], cost: 120 },
      space: { name: 'üöÄ Space Explorer', white: ['üöÄ', 'üåü', 'üõ∏', 'üí´', 'üå†', '‚≠ê'], black: ['üöÄ', 'üåü', 'üõ∏', 'üí´', 'üå†', '‚≠ê'], cost: 180 },
      food: { name: 'üçï Foodie', white: ['üç∞', 'üç¶', 'üç™', 'üßÅ', 'ü•ñ', 'ü•ê'], black: ['üç∞', 'üç¶', 'üç™', 'üßÅ', 'ü•ñ', 'ü•ê'], cost: 90 },
      robots: { name: 'ü§ñ Cyber Tech', white: ['üëæ', '‚ö°', 'üíª', 'üîã', 'üì±', 'üíø'], black: ['üëæ', '‚ö°', 'üíª', 'üîã', 'üì±', 'üíø'], cost: 200 },
      
      // NEW SKINS
      medieval: { name: '‚öîÔ∏è Medieval', white: ['üó°Ô∏è', 'üõ°Ô∏è', 'üè∞', '‚õ™', 'üê¥', 'üèπ'], black: ['üó°Ô∏è', 'üõ°Ô∏è', 'üè∞', '‚õ™', 'üê¥', 'üèπ'], cost: 110 },
      dinosaurs: { name: 'ü¶ï Dino World', white: ['ü¶ï', 'ü¶ñ', 'ü•ö', 'üåø', 'ü¶¥', 'ü¶æ'], black: ['ü¶ï', 'ü¶ñ', 'ü•ö', 'üåø', 'ü¶¥', 'ü¶æ'], cost: 130 },
      sports: { name: '‚öΩ Sports Arena', white: ['‚öΩ', 'üèÄ', 'üèà', '‚öæ', 'üéæ', 'üèê'], black: ['‚öΩ', 'üèÄ', 'üèà', '‚öæ', 'üéæ', 'üèê'], cost: 85 },
      music: { name: 'üéµ Music Notes', white: ['üé∏', 'üéπ', 'ü•Å', 'üé∫', 'üéª', 'üéµ'], black: ['üé∏', 'üéπ', 'ü•Å', 'üé∫', 'üéª', 'üéµ'], cost: 95 },
      nature: { name: 'üåø Nature Peace', white: ['üå≥', 'üå∫', 'üåª', 'ü¶ã', 'üêù', 'üå±'], black: ['üå≥', 'üå∫', 'üåª', 'ü¶ã', 'üêù', 'üå±'], cost: 75 },
      candy: { name: 'üç≠ Sweet Treats', white: ['üç≠', 'üç¨', 'üßÅ', 'üç©', 'üç™', 'üç´'], black: ['üç≠', 'üç¨', 'üßÅ', 'üç©', 'üç™', 'üç´'], cost: 65 },
      vehicles: { name: 'üöó Fast & Furious', white: ['üöó', 'üèéÔ∏è', 'üöì', 'üöë', 'üöí', 'üöê'], black: ['üöó', 'üèéÔ∏è', 'üöì', 'üöë', 'üöí', 'üöê'], cost: 140 },
      weather: { name: 'üå§Ô∏è Weather Mood', white: ['‚òÄÔ∏è', 'üå§Ô∏è', '‚õÖ', 'üå•Ô∏è', '‚òÅÔ∏è', 'üå¶Ô∏è'], black: ['‚òÄÔ∏è', 'üå§Ô∏è', '‚õÖ', 'üå•Ô∏è', '‚òÅÔ∏è', 'üå¶Ô∏è'], cost: 80 },
      gems: { name: 'üíé Gem Collection', white: ['üíé', 'üíç', 'üëë', '‚ö±Ô∏è', 'üè∫', 'üóø'], black: ['üíé', 'üíç', 'üëë', '‚ö±Ô∏è', 'üè∫', 'üóø'], cost: 160 },
      fruits: { name: 'üçì Fruity Fresh', white: ['üçì', 'üçä', 'üçã', 'üçå', 'üçâ', 'üçá'], black: ['üçì', 'üçä', 'üçã', 'üçå', 'üçâ', 'üçá'], cost: 70 },
      tools: { name: 'üîß Builder\'s Kit', white: ['üîß', 'üî®', '‚öíÔ∏è', 'üõ†Ô∏è', '‚öôÔ∏è', 'üî©'], black: ['üîß', 'üî®', '‚öíÔ∏è', 'üõ†Ô∏è', '‚öôÔ∏è', 'üî©'], cost: 100 },
      magic: { name: 'ü™Ñ Magic Spells', white: ['ü™Ñ', 'üîÆ', 'üßø', 'üî±', '‚öóÔ∏è', 'üß™'], black: ['ü™Ñ', 'üîÆ', 'üßø', 'üî±', '‚öóÔ∏è', 'üß™'], cost: 145 },
      insects: { name: 'üêõ Bug World', white: ['üêõ', 'ü¶ã', 'üêù', 'üêû', 'üêú', 'ü¶ó'], black: ['üêõ', 'ü¶ã', 'üêù', 'üêû', 'üêú', 'ü¶ó'], cost: 55 },
      flowers: { name: 'üå∏ Garden Beauty', white: ['üå∏', 'üå∫', 'üåª', 'üå∑', 'üåπ', 'üèµÔ∏è'], black: ['üå∏', 'üå∫', 'üåª', 'üå∑', 'üåπ', 'üèµÔ∏è'], cost: 60 },
      space2: { name: 'üõ∞Ô∏è Cosmic Voyage', white: ['üõ∞Ô∏è', 'üåå', 'ü™ê', '‚òÑÔ∏è', 'üåë', 'üåí'], black: ['üõ∞Ô∏è', 'üåå', 'ü™ê', '‚òÑÔ∏è', 'üåë', 'üåí'], cost: 175 },
      egypt: { name: 'üè∫ Ancient Egypt', white: ['üè∫', 'üóø', '‚ö±Ô∏è', 'üëë', 'üî±', 'üê™'], black: ['üè∫', 'üóø', '‚ö±Ô∏è', 'üëë', 'üî±', 'üê™'], cost: 125 },
      pirates: { name: 'üè¥‚Äç‚ò†Ô∏è Pirate Adventure', white: ['üè¥‚Äç‚ò†Ô∏è', '‚öì', 'üóùÔ∏è', 'üß≠', 'üìú', 'üè¥'], black: ['üè¥‚Äç‚ò†Ô∏è', '‚öì', 'üóùÔ∏è', 'üß≠', 'üìú', 'üè¥'], cost: 115 },
      ninja: { name: 'ü•∑ Stealth Ninja', white: ['ü•∑', 'üó°Ô∏è', 'üìç', 'üéØ', 'ü™∂', 'üåÄ'], black: ['ü•∑', 'üó°Ô∏è', 'üìç', 'üéØ', 'ü™∂', 'üåÄ'], cost: 135 },
      party: { name: 'üéâ Party Time', white: ['üéâ', 'üéä', 'üéà', 'üéÅ', 'üéÄ', 'üéóÔ∏è'], black: ['üéâ', 'üéä', 'üéà', 'üéÅ', 'üéÄ', 'üéóÔ∏è'], cost: 45 },
      gaming: { name: 'üéÆ Game On', white: ['üéÆ', 'üïπÔ∏è', 'üëæ', 'üéØ', 'üé≤', 'üÉè'], black: ['üéÆ', 'üïπÔ∏è', 'üëæ', 'üéØ', 'üé≤', 'üÉè'], cost: 105 },
      hearts: { name: 'üíï Love & Hearts', white: ['üíï', 'üíñ', 'üíó', 'üíì', 'üíù', 'üíò'], black: ['üíï', 'üíñ', 'üíó', 'üíì', 'üíù', 'üíò'], cost: 50 },
      stars: { name: '‚≠ê Star Power', white: ['‚≠ê', 'üåü', '‚ú®', 'üí´', 'üå†', 'üåÉ'], black: ['‚≠ê', 'üåü', '‚ú®', 'üí´', 'üå†', 'üåÉ'], cost: 95 }
    };
    
    const effects = {
      rainbow: { name: 'üåà Rainbow Trail', description: 'Colorful trails on moves', cost: 75, purchased: false },
      fire: { name: 'üî• Fire Effect', description: 'Blazing capture animations', cost: 100, purchased: false },
      stars: { name: 'üåü Starry Effect', description: 'Cosmic animations', cost: 85, purchased: false },
      lightning: { name: '‚ö° Lightning Bolt', description: 'Electric move effects', cost: 95, purchased: false },
      sparkles: { name: '‚ú® Sparkle Burst', description: 'Glittery explosions', cost: 80, purchased: false },
      hearts: { name: 'üíñ Love Effect', description: 'Heart particles on moves', cost: 70, purchased: false },
      snow: { name: '‚ùÑ Snowfall', description: 'Snowy capture effects', cost: 90, purchased: false },
      confetti: { name: 'üéä Confetti Blast', description: 'Party mode captures', cost: 85, purchased: false },
      
      // NEW EFFECTS
      matrix: { name: 'üíª Matrix Code', description: 'Digital rain effects', cost: 110, purchased: false },
      neon: { name: 'üí´ Neon Glow', description: 'Cyberpunk neon lights', cost: 95, purchased: false },
      bubble: { name: 'ü´ß Bubble Pop', description: 'Bubbly capture effects', cost: 65, purchased: false },
      smoke: { name: 'üí® Smoke Screen', description: 'Mysterious smoke effects', cost: 80, purchased: false },
      crystal: { name: 'üíé Crystal Shatter', description: 'Shattering glass effects', cost: 120, purchased: false },
      earthquake: { name: 'üåã Screen Shake', description: 'Earthquake on captures', cost: 90, purchased: false },
      ghost: { name: 'üëª Ghost Trail', description: 'Eerie ghost effects', cost: 85, purchased: false },
      laser: { name: 'üî¥ Laser Beams', description: 'Sci-fi laser effects', cost: 105, purchased: false },
      flower: { name: 'üå∏ Petal Fall', description: 'Falling flower petals', cost: 75, purchased: false },
      wave: { name: 'üåä Wave Splash', description: 'Water wave effects', cost: 70, purchased: false },
      pixel: { name: 'üéÆ Pixel Art', description: 'Retro pixel animations', cost: 80, purchased: false },
      aurora: { name: 'üåå Aurora Borealis', description: 'Northern lights effects', cost: 130, purchased: false },
      tornado: { name: 'üå™Ô∏è Vortex Spin', description: 'Swirling vortex effects', cost: 115, purchased: false },
      magic: { name: 'ü™Ñ Magic Sparkle', description: 'Magical sparkle effects', cost: 100, purchased: false },
      retro: { name: 'üìº Retro TV', description: 'Static and glitch effects', cost: 85, purchased: false },
      disco: { name: 'üï∫ Disco Fever', description: 'Disco ball lights', cost: 90, purchased: false },
      zen: { name: 'üßò Zen Garden', description: 'Peaceful ripple effects', cost: 75, purchased: false },
      carnival: { name: 'üé° Carnival', description: 'Festival celebration effects', cost: 95, purchased: false },
      cyber: { name: 'ü§ñ Cyber Grid', description: 'Digital grid overlay', cost: 105, purchased: false },
      nature: { name: 'üçÉ Nature Wind', description: 'Leaf blowing effects', cost: 70, purchased: false },
      space: { name: 'üöÄ Warp Speed', description: 'Space warp effects', cost: 125, purchased: false },
      golden: { name: 'üèÜ Golden Touch', description: 'Everything turns gold', cost: 140, purchased: false },
      shadow: { name: 'üåë Shadow Realm', description: 'Dark shadow effects', cost: 95, purchased: false },
      ice: { name: 'üßä Ice Crystal', description: 'Freezing ice effects', cost: 85, purchased: false },
      storm: { name: '‚õà Thunder Storm', description: 'Lightning and thunder', cost: 110, purchased: false },
      candy: { name: 'üç≠ Candy Rain', description: 'Falling candy effects', cost: 65, purchased: false },
      royal: { name: 'üëë Royal Procession', description: 'Royal fanfare effects', cost: 120, purchased: false },
      minimal: { name: '‚ö™ Minimal Clean', description: 'Simple clean effects', cost: 50, purchased: false },
      chaos: { name: 'üé≤ Chaos Mode', description: 'Random crazy effects', cost: 100, purchased: false }
    };
    
    const boardThemes = {
      classic: { name: 'üé® Classic', light: '#f0d9b5', dark: '#b58863', cost: 0 },
      ocean: { name: 'üåä Ocean Blue', light: '#a8dadc', dark: '#457b9d', cost: 40 },
      forest: { name: 'üå≤ Forest Green', light: '#b8e6c4', dark: '#52b788', cost: 40 },
      sunset: { name: 'üåÖ Sunset', light: '#ffb5a7', dark: '#f4978e', cost: 50 },
      lavender: { name: 'üíú Lavender Dream', light: '#e0b0ff', dark: '#9370db', cost: 45 },
      mint: { name: 'üçÉ Mint Fresh', light: '#b2f7ef', dark: '#5eead4', cost: 45 },
      rose: { name: 'üåπ Rose Gold', light: '#ffcccb', dark: '#ff9999', cost: 55 },
      
      // NEW BOARD THEMES
      midnight: { name: 'üåô Midnight Blue', light: '#2c3e50', dark: '#34495e', cost: 60 },
      cherry: { name: 'üçí Cherry Blossom', light: '#ffb7c5', dark: '#ff69b4', cost: 50 },
      chocolate: { name: 'üç´ Chocolate', light: '#d2691e', dark: '#8b4513', cost: 45 },
      sky: { name: '‚òÅÔ∏è Sky Blue', light: '#87ceeb', dark: '#4682b4', cost: 40 },
      grape: { name: 'üçá Purple Grape', light: '#dda0dd', dark: '#8b008b', cost: 55 },
      lemon: { name: 'üçã Lemon Zest', light: '#fffacd', dark: '#ffd700', cost: 35 },
      emerald: { name: 'üíö Emerald City', light: '#50c878', dark: '#006400', cost: 65 },
      ruby: { name: 'üíé Ruby Red', light: '#ff6b6b', dark: '#c92a2a', cost: 70 },
      sapphire: { name: 'üíô Sapphire', light: '#4dabf7', dark: '#1864ab', cost: 65 },
      gold: { name: 'üèÜ Golden Luxury', light: '#ffd700', dark: '#b8860b', cost: 80 },
      silver: { name: 'ü•à Silver Elegance', light: '#c0c0c0', dark: '#808080', cost: 75 },
      bronze: { name: 'ü•â Bronze Age', light: '#cd7f32', dark: '#8b4513', cost: 60 },
      rainbow: { name: 'üåà Rainbow Pride', light: '#ff69b4', dark: '#4169e1', cost: 90 },
      neon: { name: 'üí´ Neon Nights', light: '#ff1493', dark: '#00ffff', cost: 85 },
      pastel: { name: 'üå∏ Pastel Dreams', light: '#ffdab9', dark: '#e6e6fa', cost: 45 },
      dark: { name: '‚ö´ Dark Mode', light: '#2c2c2c', dark: '#1a1a1a', cost: 35 },
      candy: { name: 'üç≠ Candy Land', light: '#ff69b4', dark: '#ff1493', cost: 50 },
      space: { name: 'üöÄ Space Black', light: '#191970', dark: '#000080', cost: 70 },
      fire: { name: 'üî• Fire & Ice', light: '#ff6347', dark: '#4169e1', cost: 65 },
      nature: { name: 'üåø Earth Tones', light: '#deb887', dark: '#8b7355', cost: 40 },
      ice: { name: 'üßä Arctic Chill', light: '#e0ffff', dark: '#00ced1', cost: 55 },
      desert: { name: 'üèú Desert Sand', light: '#f4a460', dark: '#d2691e', cost: 45 },
      jungle: { name: 'üå¥ Jungle Green', light: '#90ee90', dark: '#228b22', cost: 50 },
      royal: { name: 'üëë Royal Purple', light: '#9370db', dark: '#4b0082', cost: 75 },
      vintage: { name: 'üìú Vintage Sepia', light: '#f5deb3', dark: '#8b7d6b', cost: 55 },
      cyber: { name: 'ü§ñ Cyber Grid', light: '#00ff00', dark: '#000000', cost: 80 },
      zen: { name: 'üßò Zen Garden', light: '#f0e68c', dark: '#bdb76b', cost: 45 },
      carnival: { name: 'üé° Carnival', light: '#ff69b4', dark: '#ff1493', cost: 60 },
      matrix: { name: 'üíª Matrix Code', light: '#00ff00', dark: '#003300', cost: 85 },
      galaxy: { name: 'üåå Galaxy Swirl', light: '#4b0082', dark: '#000080', cost: 90 },
      sunset2: { name: 'üåÖ Tropical Sunset', light: '#ff7f50', dark: '#ff6347', cost: 55 },
      ocean2: { name: 'üåä Deep Ocean', light: '#006994', dark: '#003f5c', cost: 60 },
      aurora: { name: 'üåå Aurora Lights', light: '#00ff7f', dark: '#006400', cost: 95 },
      crystal: { name: 'üíé Crystal Clear', light: '#e6e6fa', dark: '#9370db', cost: 70 },
      storm: { name: '‚õà Storm Clouds', light: '#708090', dark: '#2f4f4f', cost: 50 },
      autumn: { name: 'üçÇ Autumn Leaves', light: '#ff8c00', dark: '#8b4513', cost: 55 },
      spring: { name: 'üå∏ Spring Bloom', light: '#98fb98', dark: '#90ee90', cost: 45 },
      winter: { name: '‚ùÑÔ∏è Winter Frost', light: '#f0f8ff', dark: '#b0e0e6', cost: 50 },
      halloween: { name: 'üéÉ Halloween Spooky', light: '#ff8c00', dark: '#000000', cost: 65 },
      christmas: { name: 'üéÑ Christmas Joy', light: '#ff0000', dark: '#008000', cost: 60 },
      valentine: { name: 'üíï Valentine Love', light: '#ffc0cb', dark: '#ff1493', cost: 55 },
      stpatrick: { name: 'üçÄ St. Patrick\'s', light: '#90ee90', dark: '#228b22', cost: 50 },
      easter: { name: 'üê∞ Easter Pastel', light: '#ffb6c1', dark: '#98fb98', cost: 45 }
    };

    // Data sync function (replaces Canva Data SDK onDataChanged)
    async function syncDataFromSheets() {
      if ((ONLINE_STORAGE_CONFIG.provider === 'googlesheets' && (!ONLINE_STORAGE_CONFIG.googlesheets.spreadsheetId || !ONLINE_STORAGE_CONFIG.googlesheets.apiKey)) ||
          (ONLINE_STORAGE_CONFIG.provider === 'jsonbin' && !ONLINE_STORAGE_CONFIG.jsonbinApiKey) ||
          (ONLINE_STORAGE_CONFIG.provider === 'firebase' && !firebaseDatabase)) {
        return;
      }
      
      try {
        allGameRecords = await onlineStorageHandler.getAll();
        
        // If we're in an online game, check for updates
        if (gameState.mode === 'online' && gameState.roomCode) {
          console.log('üîç POLLING: Checking for room updates for:', gameState.roomCode);
          const currentRoom = allGameRecords.find(record => record.room_code === gameState.roomCode);
          
          console.log('üîç POLLING: Found room:', currentRoom);
          console.log('üîç POLLING: Game mode:', gameState.game_mode);
          console.log('üîç POLLING: Player color:', gameState.playerColor);
          console.log('üîç POLLING: Player role:', gameState.playerRole);
          
          if (currentRoom) {
            gameState.currentGameRecord = currentRoom;
            
            // Update opponent name if joined (for regular rooms)
            if (gameState.playerRole === 'host' && currentRoom.guest_player) {
              const guestJustJoined = !gameState.opponentName || gameState.opponentName !== currentRoom.guest_player;
              gameState.opponentName = currentRoom.guest_player;
              updateMultiplayerStatus();
              
              // Show notification when guest joins
              if (guestJustJoined) {
                console.log('üî• GUEST JUST JOINED! Showing modal...');
                console.log('üî• Guest player:', currentRoom.guest_player);
                console.log('üî• Current opponent name:', gameState.opponentName);
                showGuestJoinedModal(currentRoom.guest_player);
              } else {
                console.log('üî• Guest already joined, not showing modal');
              }
            } else if (gameState.playerRole === 'guest' && !gameState.opponentName) {
              gameState.opponentName = currentRoom.host_player;
              updateMultiplayerStatus();
            }
            
            // Update opponent name for public games (check for host using playerColor)
            if (gameState.game_mode === 'public') {
              console.log('üîç PUBLIC GAME: Checking for guest updates...');
              console.log('üîç PUBLIC GAME: Player color:', gameState.playerColor);
              console.log('üîç PUBLIC GAME: Guest player:', currentRoom.guest_player);
              console.log('üîç PUBLIC GAME: Current opponent name:', gameState.opponentName);
              
              if (gameState.playerColor === 'white' && currentRoom.guest_player) {
                // Host (white) sees guest (black) joined
                const guestJustJoined = !gameState.opponentName || gameState.opponentName !== currentRoom.guest_player;
                console.log('üîç PUBLIC GAME: Guest just joined?', guestJustJoined);
                gameState.opponentName = currentRoom.guest_player;
                document.getElementById('opponent-status').textContent = `Connected to ${currentRoom.guest_player}`;
                console.log('üéÆ Public game: Host detected guest joined:', currentRoom.guest_player);
                
                // Always show notification when guest joins
                if (guestJustJoined) {
                  console.log('üî• PUBLIC GAME: GUEST JUST JOINED! Showing modal...');
                  console.log('üî• PUBLIC GAME: Guest player:', currentRoom.guest_player);
                  console.log('üî• PUBLIC GAME: Current opponent name:', gameState.opponentName);
                  showGuestJoinedModal(currentRoom.guest_player);
                } else {
                  console.log('üî• PUBLIC GAME: Guest already joined, not showing modal');
                }
              } else if (gameState.playerColor === 'black' && currentRoom.host_player && !gameState.opponentName) {
                // Guest (black) sees host (white)
                gameState.opponentName = currentRoom.host_player;
                document.getElementById('opponent-status').textContent = `Connected to ${currentRoom.host_player}`;
                console.log('üéÆ Public game: Guest detected host:', currentRoom.host_player);
              }
            }
            
            // Sync game state from server
            syncGameStateFromServer(currentRoom);
          }
        }
        
        // Update admin panel if open
        if (document.getElementById('admin-panel-modal').style.display === 'block') {
          renderActiveGames();
        }
      } catch (error) {
        console.error('Error syncing data:', error);
      }
    }
    
    // Start periodic sync
    function startDataSync() {
      if (syncInterval) {
        clearInterval(syncInterval);
      }
      
      // For Firebase, use real-time listeners
      if (ONLINE_STORAGE_CONFIG.provider === 'firebase' && firebaseDatabase && gameState.roomCode) {
        console.log('üî• Setting up Firebase real-time listener for room:', gameState.roomCode);
        console.log('üî• Provider:', ONLINE_STORAGE_CONFIG.provider);
        console.log('üî• Firebase database exists:', !!firebaseDatabase);
        console.log('üî• Room code exists:', !!gameState.roomCode);
        
        // Set up real-time listener for the room
        const roomRef = firebaseDatabase.ref('rooms/' + gameState.roomCode);
        console.log('üî• Room ref created:', roomRef.toString());
        
        roomRef.on('value', (snapshot) => {
          const roomData = snapshot.val();
          console.log('üî• Firebase real-time update received:', roomData);
          if (roomData) {
            console.log('üî• Processing room data...');
            gameState.currentGameRecord = roomData;
            
            // Update opponent name if joined (for regular rooms)
            if (gameState.playerRole === 'host' && roomData.guest_player) {
              const guestJustJoined = !gameState.opponentName || gameState.opponentName !== roomData.guest_player;
              const forceNotification = roomData.force_host_notification === true;
              
              gameState.opponentName = roomData.guest_player;
              updateMultiplayerStatus();
              
              // Show notification when guest joins OR when force notification is triggered
              if (guestJustJoined || forceNotification) {
                console.log('üî• GUEST JUST JOINED! Showing modal...');
                console.log('üî• Guest player:', roomData.guest_player);
                console.log('üî• Current opponent name:', gameState.opponentName);
                console.log('üî• Force notification:', forceNotification);
                showGuestJoinedModal(roomData.guest_player);
                
                // Clear the force notification flag
                if (forceNotification) {
                  onlineStorageHandler.update(gameState.roomCode, {
                    force_host_notification: false,
                    guest_just_joined: false
                  });
                }
              }
            } else if (gameState.playerRole === 'guest' && !gameState.opponentName) {
              gameState.opponentName = roomData.host_player;
              updateMultiplayerStatus();
            }
            
            // Update opponent name for public games (this was missing!)
            if (gameState.game_mode === 'public') {
              if (gameState.playerColor === 'white' && roomData.guest_player) {
                // Host (white) sees guest (black) joined
                const guestJustJoined = !gameState.opponentName || gameState.opponentName !== roomData.guest_player;
                const forceNotification = roomData.force_host_notification === true;
                
                gameState.opponentName = roomData.guest_player;
                document.getElementById('opponent-status').textContent = `Connected to ${roomData.guest_player}`;
                console.log('üéÆ Firebase: Host detected guest joined:', roomData.guest_player);
                
                // Always show notification when guest joins OR when force notification is triggered
                if (guestJustJoined || forceNotification) {
                  gameState.guestJoinedNotified = true;
                  console.log('üî• PUBLIC GAME: GUEST JUST JOINED! Showing modal...');
                  console.log('üî• Guest player:', roomData.guest_player);
                  console.log('üî• Current opponent name:', gameState.opponentName);
                  console.log('üî• Force notification:', forceNotification);
                  showGuestJoinedModal(roomData.guest_player);
                  
                  // Clear the force notification flag
                  if (forceNotification) {
                    onlineStorageHandler.update(gameState.roomCode, {
                      force_host_notification: false,
                      guest_just_joined: false
                    });
                  }
                }
              } else if (gameState.playerColor === 'black' && roomData.host_player && !gameState.opponentName) {
                // Guest (black) sees host (white)
                gameState.opponentName = roomData.host_player;
                document.getElementById('opponent-status').textContent = `Connected to ${roomData.host_player}`;
                console.log('üéÆ Firebase: Guest detected host:', roomData.host_player);
              }
              
              // Auto-start game when joining as guest (guest perspective)
              if (roomData.guest_player && roomData.host_player) {
                console.log('Both players present! Game ready to start!');
                playGameStartSound();
                
                // Show game ready notification
                setTimeout(() => {
                  alert(`üéâ Joined ${roomData.host_player}'s game! Ready to play!`);
                }, 500);
              }
            }
            
            // Sync game state from server
            syncGameStateFromServer(roomData);
          }
        });
        
        // Store the listener reference so we can detach it later
        gameState.firebaseListener = roomRef;
        
        // For public games, also set up a listener on the public games node
        if (gameState.game_mode === 'public') {
          console.log('üî• Setting up public games listener for:', gameState.roomCode);
          const publicGamesRef = firebaseDatabase.ref('publicGames/' + gameState.roomCode);
          
          publicGamesRef.on('value', (snapshot) => {
            const publicGameData = snapshot.val();
            console.log('üî• Public games update received:', publicGameData);
            
            if (publicGameData && publicGameData.force_host_notification === true) {
              console.log('üî• PUBLIC GAMES: Force notification detected!');
              
              // Show alert to host
              if (gameState.playerColor === 'white') {
                showGuestJoinedModal(publicGameData.guest_player);
                
                // Clear the force notification flag
                publicGamesRef.update({
                  force_host_notification: false,
                  guest_just_joined: false
                });
              }
            }
          });
        }
      } else {
        // For JSONBin and Google Sheets, use polling
        syncInterval = setInterval(syncDataFromSheets, 2000); // Sync every 2 seconds
      }
    }
    
    function stopDataSync() {
      if (syncInterval) {
        clearInterval(syncInterval);
        syncInterval = null;
      }
      
      // For Firebase, remove the real-time listener
      if (ONLINE_STORAGE_CONFIG.provider === 'firebase' && gameState.firebaseListener) {
        console.log('Removing Firebase real-time listener');
        gameState.firebaseListener.off('value');
        gameState.firebaseListener = null;
      }
    }
    
    function getCurrentCoins() {
      return gameState.currentPlayer === 'white' ? gameState.whiteCoins : gameState.blackCoins;
    }
    
    function getCurrentPowerUps() {
      return gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
    }
    
    function generateRoomCode() {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      let code = 'CHESS-';
      for (let i = 0; i < 4; i++) {
        code += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return code;
    }
    
    function serializeGameState() {
      return JSON.stringify({
        board: gameState.board,
        whiteCaptured: gameState.whiteCaptured,
        blackCaptured: gameState.blackCaptured,
        whiteInCheck: gameState.whiteInCheck,
        blackInCheck: gameState.blackInCheck,
        moveHistory: gameState.moveHistory,
        whiteShieldActive: gameState.whiteShieldActive,
        blackShieldActive: gameState.blackShieldActive,
        whiteDoubleCoinsActive: gameState.whiteDoubleCoinsActive,
        blackDoubleCoinsActive: gameState.blackDoubleCoinsActive,
        whiteDoubleCoinsMovesLeft: gameState.whiteDoubleCoinsMovesLeft,
        blackDoubleCoinsMovesLeft: gameState.blackDoubleCoinsMovesLeft,
        freezeActive: gameState.freezeActive,
        whiteKnightBoostActive: gameState.whiteKnightBoostActive,
        blackKnightBoostActive: gameState.blackKnightBoostActive,
        whiteKnightBoostMovesLeft: gameState.whiteKnightBoostMovesLeft,
        blackKnightBoostMovesLeft: gameState.blackKnightBoostMovesLeft,
        whiteVisionActive: gameState.whiteVisionActive,
        blackVisionActive: gameState.blackVisionActive,
        // Skin data for synchronization
        whiteCurrentSkin: gameState.whiteCurrentSkin,
        blackCurrentSkin: gameState.blackCurrentSkin,
        currentTheme: gameState.currentTheme,
        currentEffect: gameState.currentEffect,
        // Timer state
        whiteTime: gameState.whiteTime,
        blackTime: gameState.blackTime,
        timerRunning: gameState.timerRunning,
        // Chat state
        chatMessages: gameState.chatMessages
      });
    }
    
    function deserializeGameState(stateStr) {
      try {
        return JSON.parse(stateStr);
      } catch (e) {
        return null;
      }
    }
    
    function syncGameStateFromServer(record) {
      const savedState = deserializeGameState(record.game_state_data);
      if (!savedState) return;
      
      console.log('Syncing game state from server:', savedState);
      
      // Always update the board state - this ensures pieces move in real-time
      const boardChanged = JSON.stringify(gameState.board) !== JSON.stringify(savedState.board);
      const currentPlayerChanged = gameState.currentPlayer !== record.current_player;
      const timerChanged = gameState.whiteTime !== (savedState.whiteTime || 600) || 
                           gameState.blackTime !== (savedState.blackTime || 600) ||
                           gameState.timerRunning !== (savedState.timerRunning || false);
      const chatChanged = JSON.stringify(gameState.chatMessages) !== JSON.stringify(savedState.chatMessages || []);
      const skinChanged = gameState.whiteCurrentSkin !== (savedState.whiteCurrentSkin || 'classic') ||
                         gameState.blackCurrentSkin !== (savedState.blackCurrentSkin || 'classic') ||
                         gameState.currentTheme !== (savedState.currentTheme || 'classic') ||
                         gameState.currentEffect !== (savedState.currentEffect || null);
      
      // Update core game state
      gameState.board = savedState.board;
      gameState.currentPlayer = record.current_player;
      gameState.whiteCaptured = savedState.whiteCaptured || [];
      gameState.blackCaptured = savedState.blackCaptured || [];
      gameState.whiteInCheck = savedState.whiteInCheck || false;
      gameState.blackInCheck = savedState.blackInCheck || false;
      gameState.gameOver = record.game_over === 'true' || record.game_over === true;
      gameState.moveHistory = savedState.moveHistory || [];
      gameState.whiteShieldActive = savedState.whiteShieldActive || false;
      gameState.blackShieldActive = savedState.blackShieldActive || false;
      gameState.whiteDoubleCoinsActive = savedState.whiteDoubleCoinsActive || false;
      gameState.blackDoubleCoinsActive = savedState.blackDoubleCoinsActive || false;
      gameState.whiteDoubleCoinsMovesLeft = savedState.whiteDoubleCoinsMovesLeft || 0;
      gameState.blackDoubleCoinsMovesLeft = savedState.blackDoubleCoinsMovesLeft || 0;
      gameState.freezeActive = savedState.freezeActive || false;
      gameState.whiteKnightBoostActive = savedState.whiteKnightBoostActive || false;
      gameState.blackKnightBoostActive = savedState.blackKnightBoostActive || false;
      gameState.whiteKnightBoostMovesLeft = savedState.whiteKnightBoostMovesLeft || 0;
      gameState.blackKnightBoostMovesLeft = savedState.blackKnightBoostMovesLeft || 0;
      gameState.whiteVisionActive = savedState.whiteVisionActive || false;
      gameState.blackVisionActive = savedState.blackVisionActive || false;
      
      // Check for admin termination
      if (record.admin_terminated === true) {
        console.log('üî¥ Game was terminated by admin, kicking player out...');
        
        // Show termination message to player
        const terminationMessage = record.termination_message || 'Game terminated by administrator';
        alert(`üî¥ ${terminationMessage}\n\nYou have been disconnected from the game.`);
        
        // Kick player out
        gameState.gameOver = true;
        gameState.mode = null;
        gameState.roomCode = null;
        gameState.playerName = null;
        gameState.opponentName = null;
        gameState.currentGameRecord = null;
        
        // Show game over screen
        document.getElementById('game-area').style.display = 'none';
        document.getElementById('mode-selection').style.display = 'flex';
        document.getElementById('multiplayer-status').style.display = 'none';
        
        // Reset game state
        resetGame();
        
        return; // Stop further processing
      }
      
      // Sync skin data
      if (savedState.whiteCurrentSkin) {
        gameState.whiteCurrentSkin = savedState.whiteCurrentSkin;
      }
      if (savedState.blackCurrentSkin) {
        gameState.blackCurrentSkin = savedState.blackCurrentSkin;
      }
      if (savedState.currentTheme) {
        gameState.currentTheme = savedState.currentTheme;
      }
      if (savedState.currentEffect) {
        gameState.currentEffect = savedState.currentEffect;
      }
      
      // Restore timer state
      gameState.whiteTime = savedState.whiteTime || 600;
      gameState.blackTime = savedState.blackTime || 600;
      gameState.timerRunning = savedState.timerRunning || false;
      
      // Restore chat messages
      if (savedState.chatMessages && savedState.chatMessages.length > 0) {
        gameState.chatMessages = savedState.chatMessages;
        renderChatMessages();
      }
      
      // Update timer display if timer changed
      if (timerChanged && gameState.timerEnabled) {
        updateTimerDisplay();
        
        // Restart timer if it was running
        if (gameState.timerRunning && !gameState.timerInterval) {
          startTimer();
        } else if (!gameState.timerRunning && gameState.timerInterval) {
          stopTimer();
        }
      }
      
      // Update coins and power-ups
      if (gameState.playerColor === 'white') {
        gameState.whiteCoins = parseInt(record.host_coins) || 0;
        // Parse power-ups from JSON string
        if (record.host_powerups) {
          try {
            gameState.whitePowerUps = JSON.parse(record.host_powerups);
          } catch (e) {
            console.error('Failed to parse host power-ups:', e);
            gameState.whitePowerUps = { freeze: 0, shield: 0, invisibility: 0, doublecoins: 0, knightboost: 0, vision: 0 };
          }
        }
      } else {
        gameState.blackCoins = parseInt(record.guest_coins) || 0;
        // Parse power-ups from JSON string
        if (record.guest_powerups) {
          try {
            gameState.blackPowerUps = JSON.parse(record.guest_powerups);
          } catch (e) {
            console.error('Failed to parse guest power-ups:', e);
            gameState.blackPowerUps = { freeze: 0, shield: 0, invisibility: 0, doublecoins: 0, knightboost: 0, vision: 0 };
          }
        }
      }
      
      // Always update board if anything changed
      if (boardChanged || currentPlayerChanged || skinChanged) {
        console.log('Board, turn, or skin changed, re-rendering');
        renderBoard();
        updatePowerUpButtons();
      }
      
      // Check for animation triggers
      if (record.last_animation && record.last_animation_timestamp) {
        const timeDiff = Date.now() - record.last_animation_timestamp;
        // Only play animation if it's recent (within 2 seconds) and not from us
        if (timeDiff < 2000 && record.last_animation_player !== gameState.playerColor) {
          console.log('Playing online animation:', record.last_animation);
          playOnlineAnimation(record.last_animation);
        }
      }
      
      // Update coin display
      document.getElementById('coin-count').textContent = getCurrentCoins();
    }
    
    function playOnlineAnimation(animationType) {
      console.log('üé¨ Playing online animation:', animationType);
      
      // Create a dummy target element for animations that need one
      const dummyTarget = document.createElement('div');
      dummyTarget.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
        z-index: 9999;
      `;
      document.body.appendChild(dummyTarget);
      
      // Play the animation based on type
      switch(animationType) {
        case 'lightning':
          createLightningAnimation(dummyTarget);
          break;
        case 'megaBomb':
          createMegaBombAnimation(dummyTarget);
          break;
        case 'tornado':
          createTornadoAnimation(dummyTarget);
          break;
        case 'bomb':
          createBombAnimation(dummyTarget);
          break;
        case 'laser':
          createLaserAnimation(dummyTarget);
          break;
        case 'shield':
          createShieldAnimation(dummyTarget);
          break;
        case 'timeWarp':
          createTimeWarpAnimation(dummyTarget);
          break;
        case 'swap':
          createSwapAnimation(dummyTarget);
          break;
        case 'teleport':
          createTeleportAnimation(dummyTarget);
          break;
        case 'freeze':
          createFreezeAnimation(dummyTarget);
          break;
        case 'doubleCoins':
          createDoubleCoinsAnimation(dummyTarget);
          break;
        case 'knightBoost':
          createKnightBoostAnimation(dummyTarget);
          break;
        case 'vision':
          createVisionAnimation(dummyTarget);
          break;
        case 'heal':
          createHealAnimation(dummyTarget);
          break;
        case 'clone':
          createCloneAnimation(dummyTarget);
          break;
        case 'magnet':
          createMagnetAnimation(dummyTarget);
          break;
        case 'poison':
          createPoisonAnimation(dummyTarget);
          break;
        case 'shieldWall':
          createShieldWallAnimation(dummyTarget);
          break;
        case 'speedBoost':
          createSpeedBoostAnimation(dummyTarget);
          break;
        case 'invisibility':
          createInvisibilityAnimation(dummyTarget);
          break;
        case 'earthquake':
          createEarthquakeAnimation(dummyTarget);
          break;
        case 'blizzard':
          createBlizzardAnimation(dummyTarget);
          break;
        case 'mirror':
          createMirrorAnimation(dummyTarget);
          break;
        case 'gravity':
          createGravityAnimation(dummyTarget);
          break;
        case 'phoenix':
          createPhoenixAnimation(dummyTarget);
          break;
        case 'timeFreeze':
          createTimeFreezeAnimation(dummyTarget);
          break;
        case 'coinRain':
          createCoinRainAnimation(dummyTarget);
          break;
        case 'powerSteal':
          createPowerStealAnimation(dummyTarget);
          break;
        case 'royalGuard':
          createRoyalGuardAnimation(dummyTarget);
          break;
        case 'luckyCharm':
          createLuckyCharmAnimation(dummyTarget);
          break;
        case 'chaos':
          createChaosAnimation(dummyTarget);
          break;
        default:
          console.log('Unknown animation type:', animationType);
      }
      
      // Clean up dummy target after animation
      setTimeout(() => {
        if (dummyTarget.parentNode) {
          dummyTarget.remove();
        }
      }, 2000);
    }
    
    function sendAnimationToServer(animationType) {
      if (!gameState.currentGameRecord || !gameState.roomCode) {
        console.log('Missing game record or room code, skipping animation send');
        return;
      }
      
      console.log('üì§ Sending animation to server:', animationType);
      
      // Update the game record with animation data
      const animationData = {
        last_animation: animationType,
        last_animation_timestamp: Date.now(),
        last_animation_player: gameState.playerColor
      };
      
      // Send to server
      onlineStorageHandler.update(gameState.roomCode, animationData)
        .then(() => {
          console.log('‚úÖ Animation sent successfully:', animationType);
        })
        .catch(error => {
          console.error('‚ùå Failed to send animation:', error);
        });
    }
    
    async function updateGameStateOnServer() {
      if (!gameState.currentGameRecord || !gameState.roomCode) {
        console.log('Missing game record or room code, skipping server update');
        return;
      }
      
      console.log('Updating game state on server for room:', gameState.roomCode);
      
      const updatedRecord = {
        ...gameState.currentGameRecord,
        current_player: gameState.currentPlayer,
        game_state_data: serializeGameState(),
        game_over: gameState.gameOver,
        last_update: Date.now(),
        white_in_check: gameState.whiteInCheck,
        black_in_check: gameState.blackInCheck
      };
      
      if (gameState.playerColor === 'white') {
        updatedRecord.host_coins = gameState.whiteCoins;
      } else {
        updatedRecord.guest_coins = gameState.blackCoins;
      }
      
      console.log('Sending update to server:', updatedRecord);
      const result = await onlineStorageHandler.update(gameState.roomCode, updatedRecord);
      if (!result.isOk) {
        console.error('Failed to update game state:', result.error);
      } else {
        console.log('Game state updated successfully');
        gameState.currentGameRecord = updatedRecord;
      }
    }
    
    function updateMultiplayerStatus() {
      const statusDiv = document.getElementById('multiplayer-status');
      const roomCodeDisplay = document.getElementById('room-code-display');
      const playerRoleSpan = document.getElementById('player-role');
      const opponentStatusSpan = document.getElementById('opponent-status');
      
      if (gameState.mode === 'online' && gameState.roomCode) {
        statusDiv.style.display = 'block';
        roomCodeDisplay.textContent = `Online Game`;
        
        const colorEmoji = gameState.playerColor === 'white' ? '‚ö™' : '‚ö´';
        playerRoleSpan.textContent = `You: ${gameState.playerName} ${colorEmoji}`;
        
        if (gameState.opponentName) {
          const oppColorEmoji = gameState.playerColor === 'white' ? '‚ö´' : '‚ö™';
          opponentStatusSpan.textContent = `Opponent: ${gameState.opponentName} ${oppColorEmoji}`;
        } else {
          opponentStatusSpan.textContent = 'Waiting for opponent...';
        }
      } else {
        statusDiv.style.display = 'none';
      }
    }
    
    // Mode selection handlers
    document.getElementById('local-mode-btn').addEventListener('click', () => {
      gameState.mode = 'local';
      document.getElementById('mode-selection').style.display = 'none';
      document.getElementById('game-area').style.display = 'block';
      stopDataSync();
      
      // Wait 250ms for game area to fully render, then force load all data
      console.log('=== LOCAL MODE: WAITING 250MS BEFORE FORCE LOADING ===');
      setTimeout(() => {
        console.log('=== LOCAL MODE: FORCE LOADING DATA ===');
        forceLoadAllData();
      }, 250);
      
      resetGame();
      // Timer disabled for local play
    });
    
    document.getElementById('online-mode-btn').addEventListener('click', () => {
      if ((ONLINE_STORAGE_CONFIG.provider === 'googlesheets' && (!ONLINE_STORAGE_CONFIG.googlesheets.spreadsheetId || !ONLINE_STORAGE_CONFIG.googlesheets.apiKey)) ||
          (ONLINE_STORAGE_CONFIG.provider === 'jsonbin' && !ONLINE_STORAGE_CONFIG.jsonbinApiKey) ||
          (ONLINE_STORAGE_CONFIG.provider === 'firebase' && (!ONLINE_STORAGE_CONFIG.firebase.apiKey || !ONLINE_STORAGE_CONFIG.firebase.databaseURL))) {
        alert('Please configure online storage first! Click the Config button.');
        return;
      }
      document.getElementById('mode-selection').style.display = 'none';
      document.getElementById('online-options').style.display = 'flex';
      startDataSync();
    });
    
    document.getElementById('ai-mode-btn').addEventListener('click', () => {
      console.log('ü§ñ AI MODE BUTTON CLICKED!');
      const modal = document.getElementById('ai-difficulty-modal');
      console.log('üìã Modal element found:', modal);
      modal.style.display = 'block';
      modal.style.position = 'fixed';
      modal.style.top = '0';
      modal.style.left = '0';
      modal.style.width = '100%';
      modal.style.height = '100%';
      modal.style.zIndex = '2000';
      console.log('üé≠ AI difficulty modal should now be visible');
    });
    
    // AI difficulty selection
    document.getElementById('ai-easy-btn').addEventListener('click', () => {
      console.log('üü¢ AI EASY BUTTON CLICKED!');
      startAIGame('easy');
    });
    
    document.getElementById('ai-medium-btn').addEventListener('click', () => {
      console.log('üü° AI MEDIUM BUTTON CLICKED!');
      startAIGame('medium');
    });
    
    document.getElementById('ai-hard-btn').addEventListener('click', () => {
      console.log('üî¥ AI HARD BUTTON CLICKED!');
      startAIGame('hard');
    });
    
    document.getElementById('cancel-ai-btn').addEventListener('click', () => {
      document.getElementById('ai-difficulty-modal').style.display = 'none';
    });
    
    // Public Lobby Event Listeners
    document.getElementById('public-lobby-btn').addEventListener('click', () => {
      console.log('üåç PUBLIC LOBBY BUTTON CLICKED!');
      playButtonSound();
      const modal = document.getElementById('public-lobby-modal');
      modal.style.display = 'flex';
      modal.style.position = 'fixed';
      modal.style.top = '0';
      modal.style.left = '0';
      // Start global lobby sync when opening
      startGlobalLobbySync();
    });
    
    document.getElementById('close-public-lobby-btn').addEventListener('click', () => {
      playButtonSound();
      document.getElementById('public-lobby-modal').style.display = 'none';
      // Stop global lobby sync when closing
      stopGlobalLobbySync();
    });
    
    document.getElementById('create-powerups-on-btn').addEventListener('click', () => {
      gameState.publicGamePowerUps = true;
      document.getElementById('create-powerups-on-btn').style.background = '#10b981';
      document.getElementById('create-powerups-off-btn').style.background = 'rgba(239, 68, 68, 0.5)';
    });
    
    document.getElementById('create-powerups-off-btn').addEventListener('click', () => {
      gameState.publicGamePowerUps = false;
      document.getElementById('create-powerups-off-btn').style.background = '#ef4444';
      document.getElementById('create-powerups-on-btn').style.background = 'rgba(16, 185, 129, 0.5)';
    });
    
    document.getElementById('create-public-game-btn').addEventListener('click', () => {
      playButtonSound();
      createPublicGame();
    });
    
    document.getElementById('refresh-games-btn').addEventListener('click', () => {
      playButtonSound();
      const btn = document.getElementById('refresh-games-btn');
      btn.textContent = 'üîÑ Refreshing...';
      btn.disabled = true;
      
      // Load global games
      loadGlobalPublicGames().then(() => {
        btn.textContent = 'üîÑ Refresh Games';
        btn.disabled = false;
      }).catch(() => {
        btn.textContent = 'üîÑ Refresh Games';
        btn.disabled = false;
      });
    });
    
    function startAIGame(difficulty) {
      console.log('üöÄ STARTING AI GAME with difficulty:', difficulty);
      gameState.mode = 'ai';
      gameState.aiDifficulty = difficulty;
      gameState.currentPlayer = 'white'; // Player always plays as white
      console.log('üéÆ Game state set - Mode:', gameState.mode, 'Difficulty:', gameState.aiDifficulty, 'Current Player:', gameState.currentPlayer);
      document.getElementById('ai-difficulty-modal').style.display = 'none';
      document.getElementById('mode-selection').style.display = 'none';
      document.getElementById('game-area').style.display = 'block';
      stopDataSync();
      
      // Wait 250ms for game area to fully render, then force load all data
      console.log('=== AI MODE: WAITING 250MS BEFORE FORCE LOADING ===');
      setTimeout(() => {
        console.log('=== AI MODE: FORCE LOADING DATA ===');
        forceLoadAllData();
      }, 250);
      
      resetGame();
      // Timer disabled for AI play
    }
    
    document.getElementById('back-to-mode-btn').addEventListener('click', () => {
      document.getElementById('online-options').style.display = 'none';
      document.getElementById('mode-selection').style.display = 'flex';
    });
    
    // Power-ups toggle functionality
    let powerupsVisible = true;
    document.getElementById('toggle-powerups-btn').addEventListener('click', () => {
      const powerupsSection = document.getElementById('powerups-section');
      const toggleBtn = document.getElementById('toggle-powerups-btn');
      
      if (powerupsVisible) {
        powerupsSection.style.display = 'none';
        toggleBtn.textContent = '‚öîÔ∏è Show Power-ups';
        toggleBtn.style.background = '#10b981';
      } else {
        powerupsSection.style.display = 'flex';
        toggleBtn.textContent = '‚öîÔ∏è Hide Power-ups';
        toggleBtn.style.background = '#ef4444';
      }
      
      powerupsVisible = !powerupsVisible;
      playButtonSound();
    });
    
    // Host game
    document.getElementById('host-game-btn').addEventListener('click', () => {
      const modal = document.getElementById('host-modal');
      modal.style.display = 'block';
      modal.style.position = 'fixed';
      modal.style.top = '0';
      modal.style.left = '0';
      modal.style.width = '100%';
      modal.style.height = '100%';
      modal.style.zIndex = '2000';
      
      const roomCode = generateRoomCode();
      document.getElementById('generated-code').textContent = roomCode;
      gameState.roomCode = roomCode;
      
      document.getElementById('host-name').value = '';
      document.getElementById('host-loading').style.display = 'none';
    });
    
    document.getElementById('cancel-host-btn').addEventListener('click', () => {
      document.getElementById('host-modal').style.display = 'none';
      gameState.roomCode = null;
    });
    
    document.getElementById('host-white-btn').addEventListener('click', () => {
      hostColorChoice = 'white';
      document.getElementById('host-white-btn').style.border = '3px solid #8b5cf6';
      document.getElementById('host-black-btn').style.border = '3px solid transparent';
    });
    
    document.getElementById('host-black-btn').addEventListener('click', () => {
      hostColorChoice = 'black';
      document.getElementById('host-black-btn').style.border = '3px solid #8b5cf6';
      document.getElementById('host-white-btn').style.border = '3px solid transparent';
    });
    
    // Create room
    document.getElementById('create-room-btn').addEventListener('click', async () => {
      const playerName = document.getElementById('host-name').value.trim();
      if (!playerName) {
        document.getElementById('host-name').style.border = '2px solid #ef4444';
        return;
      }
      
      try {
        // Debug: Log current provider and config
        console.log('Creating room with provider:', ONLINE_STORAGE_CONFIG.provider);
        console.log('Firebase config:', ONLINE_STORAGE_CONFIG.firebase);
        
        // Initialize storage if not already done
        if ((ONLINE_STORAGE_CONFIG.provider === 'jsonbin' && !ONLINE_STORAGE_CONFIG.jsonbinApiKey) ||
            (ONLINE_STORAGE_CONFIG.provider === 'googlesheets' && (!ONLINE_STORAGE_CONFIG.googlesheets.spreadsheetId || !ONLINE_STORAGE_CONFIG.googlesheets.apiKey)) ||
            (ONLINE_STORAGE_CONFIG.provider === 'firebase' && (!ONLINE_STORAGE_CONFIG.firebase.apiKey || !ONLINE_STORAGE_CONFIG.firebase.databaseURL))) {
          throw new Error('Online storage not configured. Please configure storage in the Admin panel.');
        }
        
        document.getElementById('create-room-btn').disabled = true;
        document.getElementById('create-room-btn').textContent = 'Creating...';
        
        try {
          // Ensure Firebase is initialized if using Firebase
          if (ONLINE_STORAGE_CONFIG.provider === 'firebase') {
            console.log('Initializing Firebase for room creation...');
            const initialized = await initOnlineStorage();
            console.log('Firebase initialized:', initialized);
            if (!initialized) {
              throw new Error('Failed to initialize Firebase');
            }
          }
        
        const roomData = {
          room_code: gameState.roomCode,
          host_player: playerName,
          guest_player: '',
          current_player: 'white',
          game_over: false,
          white_in_check: false,
          black_in_check: false,
          last_update: Date.now(),
          host_coins: 0,
          guest_coins: 0,
          host_powerups: JSON.stringify(gameState.whitePowerUps),
          guest_powerups: JSON.stringify(gameState.blackPowerUps),
          disable_powerups: document.getElementById('disable-powerups-checkbox').checked,
          game_state_data: serializeGameState()
        };
        
        const result = await onlineStorageHandler.create(roomData);
        
        if (result.isOk) {
          gameState.mode = 'online';
          gameState.playerRole = 'host';
          gameState.playerName = playerName;
          gameState.playerColor = hostColorChoice;
          
          // Initialize timer values to prevent NaN
          gameState.whiteTime = 600; // 10 minutes
          gameState.blackTime = 600;
          gameState.timerEnabled = true;
          gameState.timerRunning = false;
          
          // Close host modal and show game
          document.getElementById('host-modal').style.display = 'none';
          document.getElementById('online-options').style.display = 'none';
          document.getElementById('game-area').style.display = 'block';
          
          // Hide power-ups section if disabled
          const disablePowerups = document.getElementById('disable-powerups-checkbox').checked;
          if (disablePowerups) {
            const powerupsSection = document.getElementById('powerups-section');
            if (powerupsSection) {
              powerupsSection.style.display = 'none';
            }
            // Also hide the toggle button since power-ups are disabled for this room
            const toggleBtn = document.getElementById('toggle-powerups-btn');
            if (toggleBtn) {
              toggleBtn.style.display = 'none';
            }
          }
          
          // Show End Game button for online games
          document.getElementById('end-game-btn').style.display = 'block';
          
          // Play room created sound
          playRoomCreatedSound();
          
          // Enable timer and chat
          enableOnlineFeatures();
          
          // Start syncing for this room
          startDataSync();
          
          // Show room code to share
          setTimeout(() => {
            alert(`üéâ Room created successfully! Share this code with your friend: ${gameState.roomCode}`);
          }, 500);
        } else {
          document.getElementById('create-room-btn').disabled = false;
          document.getElementById('create-room-btn').textContent = 'Create Room';
          alert('Failed to create room: ' + (result.error || 'Unknown error'));
        }
        } catch (initError) {
          console.error('Firebase initialization error:', initError);
          throw new Error('Firebase initialization failed: ' + initError.message);
        }
      } catch (error) {
        console.error('Error creating room:', error);
        document.getElementById('create-room-btn').disabled = false;
        document.getElementById('create-room-btn').textContent = 'Create Room';
        
        let errorMsg = 'Failed to create room. ';
        if (error.message.includes('not configured')) {
          errorMsg = 'Online storage not configured. Please configure in Admin panel first.';
        } else if (error.message.includes('Quota exceeded')) {
          errorMsg = 'Service quota exceeded. Please try again later or switch to JSONBin.io.';
        } else {
          errorMsg += 'Please try again.';
        }
        
        alert(errorMsg);
      }
    });
    
    // Join game
    document.getElementById('join-game-btn').addEventListener('click', () => {
      const modal = document.getElementById('join-modal');
      modal.style.display = 'block';
      modal.style.position = 'fixed';
      modal.style.top = '0';
      modal.style.left = '0';
      modal.style.width = '100%';
      modal.style.height = '100%';
      modal.style.zIndex = '2000';
      document.getElementById('join-name').value = '';
      document.getElementById('join-code').value = '';
      document.getElementById('join-error').style.display = 'none';
      document.getElementById('join-loading').style.display = 'none';
    });
    
    document.getElementById('cancel-join-btn').addEventListener('click', () => {
      document.getElementById('join-modal').style.display = 'none';
    });
    
    // Join room function (extracted from event listener for public games)
    async function joinRoom(roomCode, playerName) {
      try {
        // Initialize storage if not already done
        if ((ONLINE_STORAGE_CONFIG.provider === 'jsonbin' && !ONLINE_STORAGE_CONFIG.jsonbinApiKey) ||
            (ONLINE_STORAGE_CONFIG.provider === 'googlesheets' && (!ONLINE_STORAGE_CONFIG.googlesheets.spreadsheetId || !ONLINE_STORAGE_CONFIG.googlesheets.apiKey)) ||
            (ONLINE_STORAGE_CONFIG.provider === 'firebase' && (!ONLINE_STORAGE_CONFIG.firebase.apiKey || !ONLINE_STORAGE_CONFIG.firebase.databaseURL))) {
          throw new Error('Online storage not configured. Please configure storage in the Admin panel.');
        }
        
        await initOnlineStorage();
        await syncDataFromSheets();
        
        console.log('All game records after sync:', allGameRecords);
        console.log('Looking for room code:', roomCode);
        console.log('Available room codes:', allGameRecords.map(r => ({ room_code: r.room_code, guest_player: r.guest_player })));
        
        const room = allGameRecords.find(r => r.room_code === roomCode && !r.guest_player);
        console.log('Found room to join:', room);
        
        if (room) {
          const updatedRoom = {
            ...room,
            guest_player: playerName,
            last_update: Date.now()
          };
          
          console.log('Updating room with guest:', updatedRoom);
          const result = await onlineStorageHandler.update(room.room_code, updatedRoom);
          console.log('Update result:', result);
          
          if (result.isOk) {
            gameState.mode = 'online';
            gameState.playerRole = 'guest';
            gameState.playerName = playerName;
            gameState.roomCode = roomCode;
            gameState.opponentName = room.host_player;
            gameState.currentGameRecord = updatedRoom;
            gameState.playerColor = 'black';
            
            // Play room joined sound
            playRoomJoinedSound();
            
            // Initialize timer values to prevent NaN
            gameState.whiteTime = 600; // 10 minutes
            gameState.blackTime = 600;
            gameState.timerEnabled = true;
            gameState.timerRunning = false;
            
            // Enable timer and chat
            enableOnlineFeatures();
            
            document.getElementById('mode-selection').style.display = 'none';
            document.getElementById('online-options').style.display = 'none';
            document.getElementById('game-area').style.display = 'block';
            
            // Hide power-ups section if disabled in this room
            const disablePowerups = room.disable_powerups === true;
            gameState.disablePowerups = disablePowerups; // Set the game state flag
            if (disablePowerups) {
              const powerupsSection = document.getElementById('powerups-section');
              if (powerupsSection) {
                powerupsSection.style.display = 'none';
              }
              // Also hide the toggle button since power-ups are disabled for this room
              const toggleBtn = document.getElementById('toggle-powerups-btn');
              if (toggleBtn) {
                toggleBtn.style.display = 'none';
              }
            }
            
            // Show End Game button for online games
            document.getElementById('end-game-btn').style.display = 'block';
            
            updateMultiplayerStatus();
            syncGameStateFromServer(updatedRoom);
            renderBoard();
            
            // Start data sync for real-time updates
            startDataSync();
            
            resetGame();
            
            return true;
          } else {
            throw new Error('Failed to join room. Please try again.');
          }
        } else {
          throw new Error('Room not found or already full. Please check the room code.');
        }
      } catch (error) {
        console.error('Error joining room:', error);
        let errorMsg = 'Failed to join room. ';
        
        if (error.message.includes('not configured')) {
          errorMsg = 'Online storage not configured. Please configure in Admin panel first.';
        } else if (error.message.includes('Quota exceeded')) {
          errorMsg = 'Service quota exceeded. Please try again later or switch to JSONBin.io.';
        } else {
          errorMsg += error.message;
        }
        
        throw new Error(errorMsg);
      }
    }
    
    // Join room
    document.getElementById('join-room-btn').addEventListener('click', async () => {
      const playerName = document.getElementById('join-name').value.trim();
      const roomCode = document.getElementById('join-code').value.trim().toUpperCase();
      
      if (!playerName || !roomCode) {
        if (!playerName) document.getElementById('join-name').style.border = '2px solid #ef4444';
        if (!roomCode) document.getElementById('join-code').style.border = '2px solid #ef4444';
        return;
      }
      
      document.getElementById('join-error').style.display = 'none';
      document.getElementById('join-loading').style.display = 'block';
      document.getElementById('join-room-btn').disabled = true;
      
      try {
        await joinRoom(roomCode, playerName);
        
        // Close modal on success
        document.getElementById('join-modal').style.display = 'none';
        document.getElementById('join-loading').style.display = 'none';
        document.getElementById('join-room-btn').disabled = false;
        
      } catch (error) {
        console.error('Error joining room:', error);
        document.getElementById('join-error').textContent = error.message;
        document.getElementById('join-error').style.display = 'block';
        document.getElementById('join-loading').style.display = 'none';
        document.getElementById('join-room-btn').disabled = false;
      }
    });

    // Game logic functions (piece movement, check detection, etc.)
    function isWhitePiece(piece) {
      return whitePieces.includes(piece);
    }

    function isBlackPiece(piece) {
      return blackPieces.includes(piece);
    }
    
    function canMovePiece(fromRow, fromCol, toRow, toCol) {
      const piece = gameState.board[fromRow][fromCol];
      const target = gameState.board[toRow][toCol];
      
      if ((gameState.currentPlayer === 'white' && !isWhitePiece(piece)) ||
          (gameState.currentPlayer === 'black' && !isBlackPiece(piece))) {
        return false;
      }
      
      if ((gameState.currentPlayer === 'white' && isWhitePiece(target)) ||
          (gameState.currentPlayer === 'black' && isBlackPiece(target))) {
        return false;
      }
      
      return canPieceMoveTo(piece, fromRow, fromCol, toRow, toCol);
    }
    
    function canPieceMoveTo(piece, fromRow, fromCol, toRow, toCol) {
      const target = gameState.board[toRow][toCol];
      
      // Check if target is friendly piece
      if (isWhitePiece(piece) && isWhitePiece(target)) return false;
      if (isBlackPiece(piece) && isBlackPiece(target)) return false;
      
      const rowDiff = toRow - fromRow;
      const colDiff = toCol - fromCol;
      const absRowDiff = Math.abs(rowDiff);
      const absColDiff = Math.abs(colDiff);
      
      const pieceType = piece.toLowerCase();
      
      if (pieceType === '‚ôü' || pieceType === '‚ôô') {
        const direction = isWhitePiece(piece) ? -1 : 1;
        const startRow = isWhitePiece(piece) ? 6 : 1;
        
        if (colDiff === 0 && rowDiff === direction && !target) {
          return true;
        }
        
        if (colDiff === 0 && rowDiff === direction * 2 && fromRow === startRow && 
            !target && !gameState.board[fromRow + direction][fromCol]) {
          return true;
        }
        
        if (absColDiff === 1 && rowDiff === direction && target) {
          return true;
        }
        
        return false;
      }
      
      if (pieceType === '‚ôú' || pieceType === '‚ôñ') {
        if (rowDiff !== 0 && colDiff !== 0) return false;
        return isPathClearOnBoard(gameState.board, fromRow, fromCol, toRow, toCol);
      }
      
      if (pieceType === '‚ôû' || pieceType === '‚ôò') {
        const isWhiteKnight = isWhitePiece(piece);
        const hasBoost = (isWhiteKnight && gameState.whiteKnightBoostActive && gameState.whiteKnightBoostMovesLeft > 0) ||
                         (!isWhiteKnight && gameState.blackKnightBoostActive && gameState.blackKnightBoostMovesLeft > 0);
        if (hasBoost) {
          return (absRowDiff === 2 && absColDiff === 1) || (absRowDiff === 1 && absColDiff === 2) ||
                 (absRowDiff === 4 && absColDiff === 2) || (absRowDiff === 2 && absColDiff === 4);
        }
        return (absRowDiff === 2 && absColDiff === 1) || (absRowDiff === 1 && absColDiff === 2);
      }
      
      if (pieceType === '‚ôù' || pieceType === '‚ôó') {
        if (absRowDiff !== absColDiff) return false;
        return isPathClearOnBoard(gameState.board, fromRow, fromCol, toRow, toCol);
      }
      
      if (pieceType === '‚ôõ' || pieceType === '‚ôï') {
        if (rowDiff !== 0 && colDiff !== 0 && absRowDiff !== absColDiff) return false;
        return isPathClearOnBoard(gameState.board, fromRow, fromCol, toRow, toCol);
      }
      
      if (pieceType === '‚ôö' || pieceType === '‚ôî') {
        return absRowDiff <= 1 && absColDiff <= 1;
      }
      
      return false;
    }
    
    function wouldBeInCheck(board, player) {
      const isWhite = player === 'white';
      const kingPos = findKingOnBoard(board, isWhite);
      if (!kingPos) return false;
      
      return isSquareUnderAttackOnBoard(board, kingPos.row, kingPos.col, !isWhite);
    }
    
    function findKingOnBoard(board, isWhite) {
      const kingPiece = isWhite ? '‚ôî' : '‚ôö';
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          if (board[row][col] === kingPiece) {
            return { row, col };
          }
        }
      }
      return null;
    }
    
    function isSquareUnderAttackOnBoard(board, row, col, byWhite) {
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const piece = board[r][c];
          if (!piece) continue;
          
          const isPieceWhite = isWhitePiece(piece);
          if (isPieceWhite !== byWhite) continue;
          
          // Check if this piece can attack the square
          if (canPieceMoveTo(piece, r, c, row, col)) {
            return true;
          }
        }
      }
      return false;
    }
    
    function isPathClearOnBoard(board, fromRow, fromCol, toRow, toCol) {
      const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
      const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;
      
      let currentRow = fromRow + rowStep;
      let currentCol = fromCol + colStep;
      
      while (currentRow !== toRow || currentCol !== toCol) {
        if (board[currentRow][currentCol]) {
          return false;
        }
        currentRow += rowStep;
        currentCol += colStep;
      }
      
      return true;
    }
    
    function isPathClear(fromRow, fromCol, toRow, toCol) {
      const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
      const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;
      
      let currentRow = fromRow + rowStep;
      let currentCol = fromCol + colStep;
      
      while (currentRow !== toRow || currentCol !== toCol) {
        if (gameState.board[currentRow][currentCol]) {
          return false;
        }
        currentRow += rowStep;
        currentCol += colStep;
      }
      
      return true;
    }
    
    function isKingInCheck(player) {
      return wouldBeInCheck(gameState.board, player);
    }
    
    function findKing(isWhite) {
      const kingPiece = isWhite ? '‚ôî' : '‚ôö';
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          if (gameState.board[row][col] === kingPiece) {
            return { row, col };
          }
        }
      }
      return null;
    }
    
    function isSquareUnderAttack(row, col, byWhite) {
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const piece = gameState.board[r][c];
          if (!piece) continue;
          
          const isPieceWhite = isWhitePiece(piece);
          if (isPieceWhite !== byWhite) continue;
          
          // Temporarily switch turn to check if piece can move
          const originalPlayer = gameState.currentPlayer;
          gameState.currentPlayer = byWhite ? 'white' : 'black';
          
          const canAttack = canMovePiece(r, c, row, col);
          
          gameState.currentPlayer = originalPlayer;
          
          if (canAttack) {
            return true;
          }
        }
      }
      return false;
    }
    
    function detectCheck() {
      const whiteKing = findKing(true);
      const blackKing = findKing(false);
      
      gameState.whiteInCheck = whiteKing && isSquareUnderAttack(whiteKing.row, whiteKing.col, false);
      gameState.blackInCheck = blackKing && isSquareUnderAttack(blackKing.row, blackKing.col, true);
    }
    
    function isKingInCheck(player) {
      const isWhite = player === 'white';
      const kingPos = findKing(isWhite);
      
      if (!kingPos) return false;
      
      return isSquareUnderAttack(kingPos.row, kingPos.col, !isWhite);
    }
    
    function wouldBeInCheck(board, player) {
      const isWhite = player === 'white';
      const kingPiece = isWhite ? '‚ôî' : '‚ôö';
      
      // Find the king on the test board
      let kingPos = null;
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          if (board[row][col] === kingPiece) {
            kingPos = { row, col };
            break;
          }
        }
        if (kingPos) break;
      }
      
      if (!kingPos) return false;
      
      // Check if any opponent piece can attack the king
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const piece = board[r][c];
          if (!piece) continue;
          
          const isPieceWhite = isWhitePiece(piece);
          // Check if opponent piece can attack the king
          if (isPieceWhite !== isWhite) {
            if (canPieceMoveToOnBoard(board, piece, r, c, kingPos.row, kingPos.col)) {
              return true;
            }
          }
        }
      }
      
      return false;
    }
    
    function canPieceMoveToOnBoard(board, piece, fromRow, fromCol, toRow, toCol) {
      const target = board[toRow][toCol];
      
      // Check if target is friendly piece
      if (isWhitePiece(piece) && isWhitePiece(target)) return false;
      if (isBlackPiece(piece) && isBlackPiece(target)) return false;
      
      const rowDiff = toRow - fromRow;
      const colDiff = toCol - fromCol;
      const absRowDiff = Math.abs(rowDiff);
      const absColDiff = Math.abs(colDiff);
      
      const pieceType = piece.toLowerCase();
      
      if (pieceType === '‚ôü' || pieceType === '‚ôô') {
        // Simplified pawn movement
        if (isWhitePiece(piece)) {
          if (fromRow > toRow) return false; // Can't move backwards
          if (colDiff !== 0 && absColDiff !== 1) return false;
          if (absRowDiff > 2) return false;
          if (absRowDiff === 2 && fromRow !== 6) return false;
        } else {
          if (fromRow < toRow) return false; // Can't move backwards
          if (colDiff !== 0 && absColDiff !== 1) return false;
          if (absRowDiff > 2) return false;
          if (absRowDiff === 2 && fromRow !== 1) return false;
        }
        return true;
      }
      
      if (pieceType === '‚ôú' || pieceType === '‚ôñ') {
        if (rowDiff !== 0 && colDiff !== 0) return false;
        return isPathClearOnBoard(board, fromRow, fromCol, toRow, toCol);
      }
      
      if (pieceType === '‚ôû' || pieceType === '‚ôò') {
        return (absRowDiff === 2 && absColDiff === 1) || (absRowDiff === 1 && absColDiff === 2);
      }
      
      if (pieceType === '‚ôù' || pieceType === '‚ôó') {
        if (absRowDiff !== absColDiff) return false;
        return isPathClearOnBoard(board, fromRow, fromCol, toRow, toCol);
      }
      
      if (pieceType === '‚ôõ' || pieceType === '‚ôï') {
        if (rowDiff !== 0 && colDiff !== 0 && absRowDiff !== absColDiff) return false;
        return isPathClearOnBoard(board, fromRow, fromCol, toRow, toCol);
      }
      
      if (pieceType === '‚ôö' || pieceType === '‚ôî') {
        return absRowDiff <= 1 && absColDiff <= 1;
      }
      
      return false;
    }

    function createSparkles(element, count = 5) {
      const rect = element.getBoundingClientRect();
      const sparkleEmojis = ['‚ú®', '‚≠ê', 'üí´', 'ü™ô', '‚ú®'];
      
      for (let i = 0; i < count; i++) {
        const sparkle = document.createElement('div');
        sparkle.className = 'sparkle';
        sparkle.textContent = sparkleEmojis[i % sparkleEmojis.length];
        sparkle.style.left = `${rect.left + Math.random() * rect.width}px`;
        sparkle.style.top = `${rect.top + rect.height / 2}px`;
        sparkle.style.animationDelay = `${i * 0.1}s`;
        document.body.appendChild(sparkle);
        
        setTimeout(() => sparkle.remove(), 1000);
      }
    }
    
    function createLightningBoltEffect(centerSquare, centerRow, centerCol, directions, struckPieces) {
      const centerRect = centerSquare.getBoundingClientRect();
      const centerX = centerRect.left + centerRect.width / 2;
      const centerY = centerRect.top + centerRect.height / 2;
      
      // Create central lightning flash
      const centralFlash = document.createElement('div');
      centralFlash.style.cssText = `
        position: fixed;
        left: ${centerX}px;
        top: ${centerY}px;
        width: 60px;
        height: 60px;
        background: radial-gradient(circle, #ffffff, #ffff00, #ff9900);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        z-index: 9999;
        pointer-events: none;
        animation: lightningFlash 0.3s ease-out;
      `;
      document.body.appendChild(centralFlash);
      
      // Create lightning bolts in each direction
      directions.forEach(([dRow, dCol], dirIndex) => {
        setTimeout(() => {
          for (let dist = 1; dist < 8; dist++) {
            const targetRow = centerRow + (dRow * dist);
            const targetCol = centerCol + (dCol * dist);
            
            if (targetRow >= 0 && targetRow < 8 && targetCol >= 0 && targetCol < 8) {
              const targetSquare = document.querySelector(`[data-row="${targetRow}"][data-col="${targetCol}"]`);
              if (targetSquare) {
                const targetRect = targetSquare.getBoundingClientRect();
                const targetX = targetRect.left + targetRect.width / 2;
                const targetY = targetRect.top + targetRect.height / 2;
                
                // Create lightning bolt
                const bolt = document.createElement('div');
                bolt.style.cssText = `
                  position: fixed;
                  left: ${centerX}px;
                  top: ${centerY}px;
                  width: 4px;
                  height: ${Math.sqrt(Math.pow(targetX - centerX, 2) + Math.pow(targetY - centerY, 2))}px;
                  background: linear-gradient(to bottom, #ffffff, #ffff00, #ff9900);
                  transform-origin: top center;
                  transform: rotate(${Math.atan2(targetY - centerY, targetX - centerX) * 180 / Math.PI + 90}deg);
                  z-index: 9998;
                  pointer-events: none;
                  animation: lightningBolt 0.4s ease-out;
                  box-shadow: 0 0 20px #ffff00, 0 0 40px #ff9900;
                `;
                document.body.appendChild(bolt);
                
                // Create spark at target
                setTimeout(() => {
                  const spark = document.createElement('div');
                  spark.style.cssText = `
                    position: fixed;
                    left: ${targetX}px;
                    top: ${targetY}px;
                    width: 30px;
                    height: 30px;
                    background: radial-gradient(circle, #ffffff, #ffff00);
                    border-radius: 50%;
                    transform: translate(-50%, -50%);
                    z-index: 9999;
                    pointer-events: none;
                    animation: lightningSpark 0.3s ease-out;
                  `;
                  document.body.appendChild(spark);
                  
                  setTimeout(() => spark.remove(), 300);
                }, 200);
                
                setTimeout(() => bolt.remove(), 400);
              }
            }
          }
        }, dirIndex * 50); // Stagger the directions
      });
      
      // Remove central flash
      setTimeout(() => centralFlash.remove(), 300);
      
      // Add screen flash effect
      const screenFlash = document.createElement('div');
      screenFlash.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: radial-gradient(circle at ${centerX}px ${centerY}px, rgba(255, 255, 0, 0.3), transparent);
        z-index: 9997;
        pointer-events: none;
        animation: screenFlash 0.2s ease-out;
      `;
      document.body.appendChild(screenFlash);
      
      setTimeout(() => screenFlash.remove(), 200);
    }
    
    function createConfetti(element) {
      const rect = element.getBoundingClientRect();
      const currentEffect = gameState.currentEffect;
      
      // Default confetti emojis
      let confettiEmojis = ['üéâ', 'üéä', 'üéà', 'üéÜ', 'üéá', 'üéÅ', 'üí•', 'üåü'];
      let particleCount = 30;
      let customClass = 'confetti';
      
      // Apply effect-specific modifications
      if (currentEffect && effects[currentEffect] && effects[currentEffect].purchased) {
        console.log(`üé® Using effect: ${currentEffect}`);
        
        switch (currentEffect) {
          case 'rainbow':
            confettiEmojis = ['üåà', 'ü¶Ñ', 'üå∏', 'ü¶ã', 'üå∫', 'üå∑', 'üåπ', 'üåª'];
            customClass = 'confetti-rainbow';
            break;
          case 'fire':
            confettiEmojis = ['üî•', 'üí•', '‚ö°', 'üåã', '‚òÑÔ∏è', 'üí´', '‚ú®', 'üî¥'];
            customClass = 'confetti-fire';
            break;
          case 'stars':
            confettiEmojis = ['‚≠ê', 'üåü', '‚ú®', 'üí´', 'üå†', 'üåÉ', 'üåå', 'ü™ê'];
            customClass = 'confetti-stars';
            break;
          case 'lightning':
            confettiEmojis = ['‚ö°', 'üîå', 'üí°', 'üî¶', '‚ö†Ô∏è', 'üå©Ô∏è', 'üå™Ô∏è', '‚õàÔ∏è'];
            customClass = 'confetti-lightning';
            break;
          case 'sparkles':
            confettiEmojis = ['‚ú®', 'üí´', '‚≠ê', 'üåü', 'üíé', 'üîÆ', 'üéä', 'üéâ'];
            particleCount = 40;
            customClass = 'confetti-sparkles';
            break;
          case 'hearts':
            confettiEmojis = ['üíñ', 'üíï', 'üíó', 'üíì', 'üíù', 'üíò', '‚ù§Ô∏è', 'üß°'];
            customClass = 'confetti-hearts';
            break;
          case 'snow':
            confettiEmojis = ['‚ùÑÔ∏è', '‚õÑ', '‚òÉÔ∏è', 'üå®Ô∏è', 'ü•∂', '‚õ∏Ô∏è', 'üéø', 'üå®'];
            customClass = 'confetti-snow';
            break;
          case 'confetti':
            confettiEmojis = ['üéä', 'üéâ', 'üéà', 'üéÄ', 'üéÅ', 'üéÇ', 'üéÑ', 'üéÜ'];
            particleCount = 50;
            customClass = 'confetti-party';
            break;
          case 'matrix':
            confettiEmojis = ['üíª', 'üì±', 'üñ•Ô∏è', '‚å®Ô∏è', 'üñ±Ô∏è', 'üíæ', 'üìÄ', 'üíø'];
            customClass = 'confetti-matrix';
            break;
          case 'neon':
            confettiEmojis = ['üí´', 'üåü', '‚ú®', 'üíé', 'üîÆ', 'üåà', 'üéÜ', '‚ö°'];
            customClass = 'confetti-neon';
            break;
          case 'bubble':
            confettiEmojis = ['ü´ß', 'ü´ß', 'ü´ß', 'ü´ß', 'ü´ß', 'ü´ß', 'ü´ß', 'ü´ß'];
            customClass = 'confetti-bubble';
            break;
          case 'smoke':
            confettiEmojis = ['üí®', 'üå´Ô∏è', '‚òÅÔ∏è', 'üå´Ô∏è', 'üí®', 'üå´Ô∏è', '‚òÅÔ∏è', 'üå´Ô∏è'];
            customClass = 'confetti-smoke';
            break;
          case 'crystal':
            confettiEmojis = ['üíé', 'üíç', 'üëë', '‚öúÔ∏è', 'üî∑', 'üî∂', 'üí†', 'üî∏'];
            customClass = 'confetti-crystal';
            break;
          case 'earthquake':
            confettiEmojis = ['üåã', 'üí•', '‚ö°', 'üî•', 'üí¢', 'üí´', '‚ú®', 'üå™Ô∏è'];
            customClass = 'confetti-earthquake';
            // Add screen shake
            document.body.style.animation = 'shake 0.5s ease';
            setTimeout(() => document.body.style.animation = '', 500);
            break;
          case 'ghost':
            confettiEmojis = ['üëª', 'üíÄ', 'üéÉ', 'ü¶á', 'üï∑Ô∏è', 'üï∏Ô∏è', 'üåô', '‚ö∞Ô∏è'];
            customClass = 'confetti-ghost';
            break;
          case 'laser':
            confettiEmojis = ['üî¥', 'üü¢', 'üîµ', 'üü°', 'üü£', 'üü†', '‚ö™', '‚ö´'];
            customClass = 'confetti-laser';
            break;
          case 'flower':
            confettiEmojis = ['üå∏', 'üå∫', 'üåª', 'üåπ', 'üå∑', 'üåπ', 'üåº', 'üåª'];
            customClass = 'confetti-flower';
            break;
          case 'wave':
            confettiEmojis = ['üåä', 'üíß', 'üí¶', 'üåä', 'üíß', 'üí¶', 'üåä', 'üíß'];
            customClass = 'confetti-wave';
            break;
          case 'pixel':
            confettiEmojis = ['üéÆ', 'üïπÔ∏è', 'üëæ', 'üéØ', 'üé≤', 'üé∞', 'üïπÔ∏è', 'üéÆ'];
            customClass = 'confetti-pixel';
            break;
          case 'aurora':
            confettiEmojis = ['üåå', 'üå†', '‚ú®', 'üí´', 'üåü', '‚≠ê', 'üåà', 'üéÜ'];
            customClass = 'confetti-aurora';
            break;
          case 'tornado':
            confettiEmojis = ['üå™Ô∏è', 'üå™Ô∏è', 'üå™Ô∏è', 'üå™Ô∏è', 'üå™Ô∏è', 'üå™Ô∏è', 'üå™Ô∏è', 'üå™Ô∏è'];
            customClass = 'confetti-tornado';
            break;
          case 'magic':
            confettiEmojis = ['ü™Ñ', '‚ú®', 'üîÆ', 'üí´', 'üåü', '‚≠ê', 'üíé', 'üéÜ'];
            customClass = 'confetti-magic';
            break;
          case 'retro':
            confettiEmojis = ['üìº', 'üì∫', 'üéûÔ∏è', 'üìª', 'üì∑', 'üìπ', 'üé•', 'üìΩÔ∏è'];
            customClass = 'confetti-retro';
            break;
          case 'disco':
            confettiEmojis = ['üï∫', 'üíÉ', 'üéâ', 'üéä', 'üéà', 'üé∂', 'üé§', 'üéß'];
            customClass = 'confetti-disco';
            break;
          case 'zen':
            confettiEmojis = ['üßò', 'üå∏', 'üçÉ', 'üåø', 'üå±', 'üçÄ', 'üåæ', 'üåæ'];
            customClass = 'confetti-zen';
            break;
          case 'carnival':
            confettiEmojis = ['üé°', 'üé¢', 'üé†', 'üé™', 'üé≠', 'üé®', 'üéØ', 'üé≤'];
            customClass = 'confetti-carnival';
            break;
          case 'cyber':
            confettiEmojis = ['ü§ñ', 'üëæ', 'üíª', 'üñ•Ô∏è', '‚å®Ô∏è', 'üñ±Ô∏è', 'üì±', 'üíæ'];
            customClass = 'confetti-cyber';
            break;
          case 'nature':
            confettiEmojis = ['üçÉ', 'üåø', 'üçÄ', 'üå±', 'üåæ', 'üçÅ', 'üçÇ', 'üçÉ'];
            customClass = 'confetti-nature';
            break;
          case 'space':
            confettiEmojis = ['üöÄ', 'üõ∏', 'üëΩ', 'üåå', 'üå†', 'ü™ê', '‚≠ê', 'üåü'];
            customClass = 'confetti-space';
            break;
          case 'golden':
            confettiEmojis = ['üèÜ', 'ü•á', 'üëë', 'üí∞', 'üíé', 'üèÖ', 'üéñÔ∏è', '‚≠ê'];
            customClass = 'confetti-golden';
            break;
          case 'shadow':
            confettiEmojis = ['üåë', 'üåö', 'üåÉ', 'üåÉ', 'üåÉ', 'üåÉ', 'üåÉ', 'üåÉ'];
            customClass = 'confetti-shadow';
            break;
          case 'ice':
            confettiEmojis = ['üßä', '‚ùÑÔ∏è', 'üå®Ô∏è', '‚õÑ', '‚òÉÔ∏è', 'ü•∂', '‚õ∏Ô∏è', 'üéø'];
            customClass = 'confetti-ice';
            break;
          case 'storm':
            confettiEmojis = ['‚õàÔ∏è', 'üå©Ô∏è', '‚ö°', 'üå™Ô∏è', 'üí•', 'üî•', 'üí®', 'üåä'];
            customClass = 'confetti-storm';
            break;
          case 'candy':
            confettiEmojis = ['üç≠', 'üç¨', 'üç´', 'üç©', 'üç™', 'üßÅ', 'üéÇ', 'üç∞'];
            customClass = 'confetti-candy';
            break;
          case 'royal':
            confettiEmojis = ['üëë', 'üè∞', 'üë∏', 'ü§¥', 'üèÜ', 'üéñÔ∏è', '‚öúÔ∏è', 'üëë'];
            customClass = 'confetti-royal';
            break;
          case 'minimal':
            confettiEmojis = ['‚ö™', '‚ö´', 'üî≥', 'üî≤', '‚¨ú', '‚¨õ', '‚óªÔ∏è', '‚óºÔ∏è'];
            particleCount = 15;
            customClass = 'confetti-minimal';
            break;
          case 'chaos':
            // Random emojis for chaos mode
            const allEmojis = ['üéâ', 'üéä', 'üî•', '‚ö°', 'üåà', 'ü¶Ñ', 'üçï', 'üéÆ', 'üöÄ', 'üëΩ', 'üçî', 'üé®', 'üé≠', 'üé™', 'üé∞'];
            confettiEmojis = Array.from({length: 8}, () => allEmojis[Math.floor(Math.random() * allEmojis.length)]);
            customClass = 'confetti-chaos';
            break;
        }
      }
      
      for (let i = 0; i < particleCount; i++) {
        const confetti = document.createElement('div');
        confetti.className = customClass;
        confetti.textContent = confettiEmojis[Math.floor(Math.random() * confettiEmojis.length)];
        // Use viewport center for full-screen effect
        confetti.style.left = `${Math.random() * window.innerWidth}px`;
        confetti.style.top = `${Math.random() * window.innerHeight}px`;
        confetti.style.animationDelay = `${i * 0.05}s`;
        document.body.appendChild(confetti);
        
        setTimeout(() => confetti.remove(), 3000);
      }
    }
    
    function addCoins(amount, element) {
      playCoinsSound();
      let finalAmount = amount;
      if (gameState.currentPlayer === 'white' && gameState.whiteDoubleCoinsActive) {
        finalAmount = amount * 2;
      } else if (gameState.currentPlayer === 'black' && gameState.blackDoubleCoinsActive) {
        finalAmount = amount * 2;
      }
      
      if (gameState.currentPlayer === 'white') {
        gameState.whiteCoins += finalAmount;
      } else {
        gameState.blackCoins += finalAmount;
      }
      
      const coinDisplay = document.getElementById('coin-count');
      coinDisplay.textContent = gameState.currentPlayer === 'white' ? gameState.whiteCoins : gameState.blackCoins;
      coinDisplay.classList.add('coin-pulse');
      setTimeout(() => coinDisplay.classList.remove('coin-pulse'), 500);
      
      if (element) {
        const rect = element.getBoundingClientRect();
        for (let i = 0; i < 3; i++) {
          const coin = document.createElement('div');
          coin.className = 'coin-float';
          coin.textContent = 'ü™ô';
          coin.style.left = `${rect.left + Math.random() * rect.width}px`;
          coin.style.top = `${rect.top + rect.height / 2}px`;
          coin.style.animationDelay = `${i * 0.1}s`;
          document.body.appendChild(coin);
          
          setTimeout(() => coin.remove(), 1500);
        }
      }
      
      // Save progress locally
      savePlayerProgress();
    }

    function movePiece(fromRow, fromCol, toRow, toCol) {
      console.log('üéØ movePiece called:', fromRow, fromCol, 'to', toRow, toCol);
      const piece = gameState.board[fromRow][fromCol];
      const captured = gameState.board[toRow][toCol];
      
      console.log('üéÆ Move details:');
      console.log('  - Piece:', piece);
      console.log('  - Captured:', captured);
      console.log('  - Current player before move:', gameState.currentPlayer);
      
      gameState.moveHistory.push({
        from: { row: fromRow, col: fromCol, piece: piece },
        to: { row: toRow, col: toCol, captured: captured },
        whiteInCheck: gameState.whiteInCheck,
        blackInCheck: gameState.blackInCheck
      });
      
      const fromSquare = document.querySelector(`[data-row="${fromRow}"][data-col="${fromCol}"]`);
      const toSquare = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"]`);
      
      // Check for pawn promotion
      const pieceType = piece.toLowerCase();
      const isPawn = pieceType === '‚ôü' || pieceType === '‚ôô';
      const promotionRow = isWhitePiece(piece) ? 0 : 7;
      
      if (isPawn && toRow === promotionRow) {
        // Show promotion modal
        showPromotionModal(toRow, toCol, piece, captured, fromSquare, toSquare);
        return;
      }
      
      // Update board
      gameState.board[toRow][toCol] = piece;
      gameState.board[fromRow][fromCol] = '';
      
      // Handle captured piece
      if (captured) {
        const capturedPiece = toSquare.querySelector('.piece');
        if (capturedPiece) {
          capturedPiece.classList.add('piece-captured');
        }
        
        createSparkles(toSquare, 8);
        
        let coinReward = 5;
        const capturedType = captured.toLowerCase();
        if (capturedType === '‚ôõ' || capturedType === '‚ôï') coinReward = 20;
        else if (capturedType === '‚ôú' || capturedType === '‚ôñ') coinReward = 15;
        else if (capturedType === '‚ôù' || capturedType === '‚ôó') coinReward = 12;
        else if (capturedType === '‚ôû' || capturedType === '‚ôò') coinReward = 12;
        else if (capturedType === '‚ôö' || capturedType === '‚ôî') coinReward = 50;
        
        addCoins(coinReward, toSquare);
        
        if (isWhitePiece(captured)) {
          gameState.blackCaptured.push(captured);
        } else {
          gameState.whiteCaptured.push(captured);
        }
        
        toSquare.classList.add('capture-animation');
        
        if (captured === '‚ôî' || captured === '‚ôö') {
          gameState.gameOver = true;
          console.log('üëë King captured! Game over set to true. Confetti will show in 600ms.');
          // Only show confetti if game is actually over (king captured), not just in check
          setTimeout(() => {
            if (gameState.gameOver) {
              console.log('üéä King capture confetti triggered - Game over:', gameState.gameOver);
              createConfetti(toSquare);
            } else {
              console.log('üö´ King capture confetti cancelled - Game over was false');
            }
          }, 600);
          playGameOverSound();
        }
      } else if (piece.toLowerCase() !== '‚ôü') {
        playMoveSound();
        toSquare.classList.add('square-flash');
        addCoins(1, toSquare);
      }
      
      const movingPiece = fromSquare.querySelector('.piece');
      if (movingPiece) {
        movingPiece.classList.add('piece-moving');
      }
      
      // Handle power-up turn reductions
      if (gameState.currentPlayer === 'white' && gameState.whiteDoubleCoinsActive) {
        gameState.whiteDoubleCoinsMovesLeft--;
        if (gameState.whiteDoubleCoinsMovesLeft <= 0) {
          gameState.whiteDoubleCoinsActive = false;
        }
      } else if (gameState.currentPlayer === 'black' && gameState.blackDoubleCoinsActive) {
        gameState.blackDoubleCoinsMovesLeft--;
        if (gameState.blackDoubleCoinsMovesLeft <= 0) {
          gameState.blackDoubleCoinsActive = false;
        }
      }
      
      if (gameState.currentPlayer === 'white' && gameState.whiteKnightBoostActive) {
        gameState.whiteKnightBoostMovesLeft--;
        if (gameState.whiteKnightBoostMovesLeft <= 0) {
          gameState.whiteKnightBoostActive = false;
        }
      } else if (gameState.currentPlayer === 'black' && gameState.blackKnightBoostActive) {
        gameState.blackKnightBoostMovesLeft--;
        if (gameState.blackKnightBoostMovesLeft <= 0) {
          gameState.blackKnightBoostActive = false;
        }
      }
      
      setTimeout(() => {
        if (!gameState.timeWarpActive) {
          if (gameState.freezeActive) {
            gameState.freezeActive = false;
          } else {
            gameState.currentPlayer = gameState.currentPlayer === 'white' ? 'black' : 'white';
          }
        } else {
          // Time Warp effect: undo freeze and switch turns normally
          gameState.timeWarpActive = false;
          if (gameState.freezeActive) {
            gameState.freezeActive = false;
          }
          gameState.currentPlayer = gameState.currentPlayer === 'white' ? 'black' : 'white';
        }
        
        gameState.selectedSquare = null;
        gameState.lastMove = { toRow, toCol };
        
        detectCheck();
        
        // Safety check for king capture (covers edge cases)
        if (!gameState.gameOver) {
          checkForKingCapture();
        }
        
        renderBoard();
        updatePowerUpButtons();
        
        // Update server if in online mode
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
        
        setTimeout(() => {
          gameState.lastMove = null;
        }, 400);
      }, 500);
    }
    
    function showPromotionModal(toRow, toCol, piece, captured, fromSquare, toSquare) {
      playModalOpenSound();
      
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
        background: rgba(0,0,0,0.9); z-index: 3000; 
        display: flex; align-items: center; justify-content: center;
      `;
      
      const isWhite = isWhitePiece(piece);
      const pieces = isWhite ? ['‚ôï', '‚ôñ', '‚ôó', '‚ôò'] : ['‚ôõ', '‚ôú', '‚ôù', '‚ôû'];
      const names = ['Queen', 'Rook', 'Bishop', 'Knight'];
      
      modal.innerHTML = `
        <div style="background: #1e293b; border-radius: 16px; padding: 32px; max-width: 500px;">
          <h2 style="font-size: 28px; font-weight: bold; color: #f1f5f9; margin-bottom: 24px; text-align: center;">
            üéâ Pawn Promotion! üéâ
          </h2>
          <p style="color: #cbd5e1; margin-bottom: 24px; text-align: center;">
            Your pawn has reached the end! Choose a piece to promote to:
          </p>
          <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px;">
            ${pieces.map((pieceChar, index) => `
              <button id="promote-${index}" 
                      style="padding: 20px; border-radius: 12px; background: rgba(255,255,255,0.1); 
                             border: 2px solid #475569; color: #f1f5f9; font-size: 24px; 
                             cursor: pointer; transition: all 0.2s; display: flex; flex-direction: column; 
                             align-items: center; gap: 8px;"
                      onmouseover="this.style.background='#475569'; this.style.transform='scale(1.05)'"
                      onmouseout="this.style.background='rgba(255,255,255,0.1)'; this.style.transform='scale(1)'">
                <span>${pieceChar}</span>
                <span style="font-size: 14px;">${names[index]}</span>
              </button>
            `).join('')}
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      // Store promotion data globally for access - make sure we get the actual from position
      const fromRow = parseInt(fromSquare.dataset.row);
      const fromCol = parseInt(fromSquare.dataset.col);
      
      window.currentPromotion = { 
        toRow: parseInt(toRow), 
        toCol: parseInt(toCol), 
        piece: piece, 
        captured: captured, 
        fromRow: fromRow,
        fromCol: fromCol,
        fromSquare: fromSquare, 
        toSquare: toSquare, 
        modal: modal 
      };
      
      // Add event listeners to buttons
      pieces.forEach((pieceChar, index) => {
        const button = document.getElementById(`promote-${index}`);
        if (button) {
          button.addEventListener('click', () => {
            playButtonSound();
            console.log('Promotion button clicked:', pieceChar, 'to position', toRow, toCol);
            promotePawn(toRow, toCol, pieceChar, captured);
          });
        }
      });
    }
    
    // Make promotePawn globally accessible
    window.promotePawn = function(toRow, toCol, newPiece, captured) {
      playPromotionSound();
      console.log('promotePawn called with:', toRow, toCol, newPiece, captured);
      console.log('currentPromotion data:', window.currentPromotion);
      
      const promotion = window.currentPromotion;
      if (!promotion) {
        console.error('No promotion data found!');
        return;
      }
      
      // Validate this is actually a pawn promotion
      const piece = promotion.piece;
      const isPawn = piece.toLowerCase() === '‚ôü' || piece.toLowerCase() === '‚ôô';
      const promotionRow = isWhitePiece(piece) ? 0 : 7;
      
      if (!isPawn || promotion.toRow !== promotionRow) {
        console.warn('‚ùå Invalid promotion attempt - not a pawn or not at promotion row');
        console.log('  - Piece:', piece, 'isPawn:', isPawn);
        console.log('  - Promotion row:', promotionRow, 'actual row:', promotion.toRow);
        return; // Don't proceed if this isn't a valid pawn promotion
      }
      
      console.log('‚úÖ Valid pawn promotion confirmed');
      
      // Remove modal immediately
      promotion.modal.remove();
      
      // Use the stored promotion data instead of parameters
      const fromRow = promotion.fromRow;
      const fromCol = promotion.fromCol;
      const toRowFinal = promotion.toRow;
      const toColFinal = promotion.toCol;
      
      console.log('Moving from', fromRow, fromCol, 'to', toRowFinal, toColFinal);
      console.log('Board before move:', gameState.board[fromRow][fromCol], '->', gameState.board[toRowFinal][toColFinal]);
      
      // Clear the original pawn position
      gameState.board[fromRow][fromCol] = '';
      // Place the new piece at the target position (replacing the captured piece)
      gameState.board[toRowFinal][toColFinal] = newPiece;
      
      console.log('Board after move:', gameState.board[fromRow][fromCol], '->', gameState.board[toRowFinal][toColFinal]);
      
      // Update the move history
      gameState.moveHistory.push({
        from: { row: fromRow, col: fromCol, piece: promotion.piece },
        to: { row: toRowFinal, col: toColFinal, captured: captured, promoted: newPiece },
        whiteInCheck: gameState.whiteInCheck,
        blackInCheck: gameState.blackInCheck
      });
      
      // Handle captured piece - add to captured list
      if (captured) {
        playCaptureSound();
        if (isWhitePiece(captured)) {
          gameState.blackCaptured.push(captured);
        } else {
          gameState.whiteCaptured.push(captured);
        }
      }
      
      // Special celebration for pawn promotion (only for human players AND only if this was actually a valid promotion)
      if (gameState.mode !== 'ai' && gameState.currentPlayer === 'white' && isPawn && promotion.toRow === promotionRow) {
        console.log('üéä Valid human pawn promotion confetti triggered - Game over:', gameState.gameOver);
        createConfetti(document.querySelector(`[data-row="${toRowFinal}"][data-col="${toColFinal}"]`));
      } else {
        console.log('üö´ No promotion confetti - Invalid promotion or AI move');
      }
      addCoins(10, document.querySelector(`[data-row="${toRowFinal}"][data-col="${toColFinal}"]`)); // Bonus coins for promotion
      
      // Handle capture rewards
      if (captured) {
        let coinReward = 5;
        const capturedType = captured.toLowerCase();
        if (capturedType === '‚ôõ' || capturedType === '‚ôï') coinReward = 20;
        else if (capturedType === '‚ôú' || capturedType === '‚ôñ') coinReward = 15;
        else if (capturedType === '‚ôù' || capturedType === '‚ôó') coinReward = 12;
        else if (capturedType === '‚ôû' || capturedType === '‚ôò') coinReward = 12;
        else if (capturedType === '‚ôö' || capturedType === '‚ôî') coinReward = 50;
        
        addCoins(coinReward, document.querySelector(`[data-row="${toRowFinal}"][data-col="${toColFinal}"]`));
      }
      
      // Check for game over (if king was captured)
      if (captured === '‚ôî' || captured === '‚ôö') {
        gameState.gameOver = true;
        playGameOverSound();
      }
      
      // Switch turns
      console.log('üîÑ About to switch turns...');
      console.log('  - Current player before switch:', gameState.currentPlayer);
      console.log('  - timeWarpActive:', gameState.timeWarpActive);
      console.log('  - freezeActive:', gameState.freezeActive);
      
      if (!gameState.timeWarpActive) {
        if (gameState.freezeActive) {
          gameState.freezeActive = false;
          console.log('‚ùÑÔ∏è Freeze deactivated, turn not switched');
        } else {
          gameState.currentPlayer = gameState.currentPlayer === 'white' ? 'black' : 'white';
          console.log('üîÑ Turn switched to:', gameState.currentPlayer);
        }
      } else {
        gameState.timeWarpActive = false;
        console.log('‚è∞ Time Warp deactivated');
      }
      
      console.log('  - Current player after switch:', gameState.currentPlayer);
      
      gameState.selectedSquare = null;
      gameState.lastMove = { toRow: toRowFinal, toCol: toColFinal };
      
      // Clear promotion data
      window.currentPromotion = null;
      
      console.log('About to render board...');
      
      // Update the board display
      detectCheck();
      renderBoard();
      updatePowerUpButtons();
      
      // Update server if in online mode
      if (gameState.mode === 'online') {
        updateGameStateOnServer();
      }
      
      // Trigger AI move if in AI mode and it's AI's turn
      console.log('üîç CHECKING AI TRIGGER IN movePiece:');
      console.log('  - gameState.mode:', gameState.mode);
      console.log('  - gameState.currentPlayer:', gameState.currentPlayer);
      console.log('  - gameState.gameOver:', gameState.gameOver);
      console.log('  - Should trigger?', gameState.mode === 'ai' && gameState.currentPlayer === 'black' && !gameState.gameOver);
      
      if (gameState.mode === 'ai' && gameState.currentPlayer === 'black' && !gameState.gameOver && !gameState.freezeActive) {
        console.log('ü§ñ AI TRIGGERED FROM movePiece! About to call makeAIMoveOnBoard()');
        makeAIMoveOnBoard();
      } else {
        console.log('üö´ AI NOT TRIGGERED IN movePiece - Mode:', gameState.mode, 'Player:', gameState.currentPlayer, 'GameOver:', gameState.gameOver, 'Frozen:', gameState.freezeActive);
      }
      
      setTimeout(() => {
        gameState.lastMove = null;
      }, 400);
    }
    
    function executeMove(fromRow, fromCol, toRow, toCol, piece, captured, fromSquare, toSquare) {
      // Check if this was a pawn promotion
      const wasPromotion = (piece === '‚ôï' || piece === '‚ôñ' || piece === '‚ôó' || piece === '‚ôò' || 
                          piece === '‚ôõ' || piece === '‚ôú' || piece === '‚ôù' || piece === '‚ôû');
      
      if (wasPromotion) {
        // Special celebration for pawn promotion
        console.log('üéä Pawn promotion confetti triggered - Game over:', gameState.gameOver);
        createConfetti(toSquare);
        addCoins(10, toSquare); // Bonus coins for promotion
        playPromotionSound(); // Add promotion sound
      }
      
      // Handle captures first (including promotion captures)
      if (captured) {
        playCaptureSound();
        const capturedPiece = toSquare.querySelector('.piece');
        if (capturedPiece) {
          capturedPiece.classList.add('piece-captured');
        }
        
        createSparkles(toSquare, 8);
        
        let coinReward = 5;
        const capturedType = captured.toLowerCase();
        if (capturedType === '‚ôõ' || capturedType === '‚ôï') coinReward = 20;
        else if (capturedType === '‚ôú' || capturedType === '‚ôñ') coinReward = 15;
        else if (capturedType === '‚ôù' || capturedType === '‚ôó') coinReward = 12;
        else if (capturedType === '‚ôû' || capturedType === '‚ôò') coinReward = 12;
        else if (capturedType === '‚ôö' || capturedType === '‚ôî') coinReward = 50;
        
        addCoins(coinReward, toSquare);
        
        if (isWhitePiece(captured)) {
          gameState.blackCaptured.push(captured);
        } else {
          gameState.whiteCaptured.push(captured);
        }
        
        toSquare.classList.add('capture-animation');
        
        if (captured === '‚ôî' || captured === '‚ôö') {
          gameState.gameOver = true;
          console.log('üëë King captured! Game over set to true. Confetti will show in 600ms.');
          // Only show confetti if game is actually over (king captured), not just in check
          setTimeout(() => {
            if (gameState.gameOver) {
              console.log('üéä King capture confetti triggered - Game over:', gameState.gameOver);
              createConfetti(toSquare);
            } else {
              console.log('üö´ King capture confetti cancelled - Game over was false');
            }
          }, 600);
          playGameOverSound();
        }
      } else if (!wasPromotion) {
        playMoveSound();
        toSquare.classList.add('square-flash');
        addCoins(1, toSquare);
      }
      
      const movingPiece = fromSquare.querySelector('.piece');
      if (movingPiece) {
        movingPiece.classList.add('piece-moving');
      }
      
      if (gameState.currentPlayer === 'white' && gameState.whiteDoubleCoinsActive) {
        gameState.whiteDoubleCoinsMovesLeft--;
        if (gameState.whiteDoubleCoinsMovesLeft <= 0) {
          gameState.whiteDoubleCoinsActive = false;
        }
      } else if (gameState.currentPlayer === 'black' && gameState.blackDoubleCoinsActive) {
        gameState.blackDoubleCoinsMovesLeft--;
        if (gameState.blackDoubleCoinsMovesLeft <= 0) {
          gameState.blackDoubleCoinsActive = false;
        }
      }
      
      if (gameState.currentPlayer === 'white' && gameState.whiteKnightBoostActive) {
        gameState.whiteKnightBoostMovesLeft--;
        if (gameState.whiteKnightBoostMovesLeft <= 0) {
          gameState.whiteKnightBoostActive = false;
        }
      } else if (gameState.currentPlayer === 'black' && gameState.blackKnightBoostActive) {
        gameState.blackKnightBoostMovesLeft--;
        if (gameState.blackKnightBoostMovesLeft <= 0) {
          gameState.blackKnightBoostActive = false;
        }
      }
      
      setTimeout(() => {
        // Update board state - the captured piece is already handled by the captured parameter
        gameState.board[toRow][toCol] = piece;
        gameState.board[fromRow][fromCol] = '';
        
        if (!gameState.timeWarpActive) {
          if (gameState.freezeActive) {
            gameState.freezeActive = false;
          } else {
            gameState.currentPlayer = gameState.currentPlayer === 'white' ? 'black' : 'white';
          }
        } else {
          // Time Warp effect: undo freeze and switch turns normally
          gameState.timeWarpActive = false;
          if (gameState.freezeActive) {
            gameState.freezeActive = false;
          }
          gameState.currentPlayer = gameState.currentPlayer === 'white' ? 'black' : 'white';
        }
        
        // Trigger AI move if in AI mode and it's now AI's turn
        if (gameState.mode === 'ai' && gameState.currentPlayer === 'black' && !gameState.gameOver) {
          setTimeout(() => {
            if (!aiThinking) {
              makeAIMoveOnBoard();
            }
          }, 500);
        }
        
        gameState.selectedSquare = null;
        gameState.lastMove = { toRow, toCol };
        
        // Handle invisibility turn countdown
        if (gameState.whiteInvisibilityActive) {
          gameState.whiteInvisibilityTurnsLeft--;
          if (gameState.whiteInvisibilityTurnsLeft <= 0) {
            gameState.whiteInvisibilityActive = false;
            gameState.whiteInvisibilityTurnsLeft = 0;
          }
        }
        if (gameState.blackInvisibilityActive) {
          gameState.blackInvisibilityTurnsLeft--;
          if (gameState.blackInvisibilityTurnsLeft <= 0) {
            gameState.blackInvisibilityActive = false;
            gameState.blackInvisibilityTurnsLeft = 0;
          }
        }
        
        detectCheck();
        
        // Safety check for king capture (covers edge cases)
        if (!gameState.gameOver) {
          checkForKingCapture();
        }
        
        renderBoard();
        updatePowerUpButtons();
        
        // Update server if in online mode
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
        
        // Trigger AI move if in AI mode and it's AI's turn
        console.log('üîç CHECKING AI TRIGGER:');
        console.log('  - gameState.mode:', gameState.mode);
        console.log('  - gameState.currentPlayer:', gameState.currentPlayer);
        console.log('  - gameState.gameOver:', gameState.gameOver);
        console.log('  - Should trigger?', gameState.mode === 'ai' && gameState.currentPlayer === 'black' && !gameState.gameOver);
        
        if (gameState.mode === 'ai' && gameState.currentPlayer === 'black' && !gameState.gameOver) {
          console.log('ü§ñ AI TRIGGERED! About to call makeAIMoveOnBoard()');
          makeAIMoveOnBoard();
        } else {
          console.log('üö´ AI NOT TRIGGERED - Mode:', gameState.mode, 'Player:', gameState.currentPlayer, 'GameOver:', gameState.gameOver);
        }
        
        setTimeout(() => {
          gameState.lastMove = null;
        }, 400);
      }, 500);
    }

    function renderBoard() {
      const config = defaultConfig;
      const board = document.getElementById('board');
      board.innerHTML = '';
      
      const theme = boardThemes[gameState.currentTheme];
      
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          const square = document.createElement('div');
          square.className = 'square flex items-center justify-center text-5xl cursor-pointer';
          square.style.width = '80px';
          square.style.height = '80px';
          square.dataset.row = row;
          square.dataset.col = col;
          
          const isLight = (row + col) % 2 === 0;
          square.style.backgroundColor = isLight ? theme.light : theme.dark;
          
          const piece = gameState.board[row][col];
          if (piece) {
            // Check if this piece should be hidden due to invisibility
            let shouldHidePiece = false;
            
            // Handle invisibility - show/hide based on who is viewing
            if (gameState.mode === 'online') {
              // In online games, each player sees their own pieces normally
              // and opponent's invisible pieces as ghosts
              if (gameState.playerColor === 'white') {
                // White player viewing
                if (isBlackPiece(piece) && gameState.blackInvisibilityActive) {
                  // Black pieces are invisible, show as ghost to white player
                  shouldHidePiece = true;
                }
              } else if (gameState.playerColor === 'black') {
                // Black player viewing
                if (isWhitePiece(piece) && gameState.whiteInvisibilityActive) {
                  // White pieces are invisible, show as ghost to black player
                  shouldHidePiece = true;
                }
              }
            } else if (gameState.mode === 'ai') {
              // In AI games, human player sees AI's invisible pieces as ghosts
              if (isBlackPiece(piece) && gameState.blackInvisibilityActive) {
                shouldHidePiece = true;
              }
            } else {
              // In local games, show based on current turn
              if (isWhitePiece(piece) && gameState.whiteInvisibilityActive && gameState.currentPlayer === 'black') {
                shouldHidePiece = true;
              } else if (isBlackPiece(piece) && gameState.blackInvisibilityActive && gameState.currentPlayer === 'white') {
                shouldHidePiece = true;
              }
            }
            
            if (shouldHidePiece) {
              // Show invisibility indicator instead of the piece
              const pieceSpan = document.createElement('span');
              pieceSpan.textContent = 'üëª';
              pieceSpan.className = 'piece invisible-piece';
              pieceSpan.style.opacity = '0.3';
              pieceSpan.style.fontSize = '24px';
              square.appendChild(pieceSpan);
            } else {
              const pieceSpan = document.createElement('span');
              
              const whiteSkinData = skins[gameState.whiteCurrentSkin] || skins['default'];
              const blackSkinData = skins[gameState.blackCurrentSkin] || skins['default'];
              const pieceIndex = whitePieces.indexOf(piece);
              const blackPieceIndex = blackPieces.indexOf(piece);
              
              if (pieceIndex !== -1 && whiteSkinData && whiteSkinData.white) {
                pieceSpan.textContent = whiteSkinData.white[pieceIndex];
                pieceSpan.className = 'piece white-piece';
              } else if (blackPieceIndex !== -1 && blackSkinData && blackSkinData.black) {
              pieceSpan.textContent = blackSkinData.black[blackPieceIndex];
              pieceSpan.className = 'piece black-piece';
            } else {
              pieceSpan.textContent = piece;
              pieceSpan.className = 'piece';
            }
            
            pieceSpan.draggable = true;
            
            if (gameState.lastMove && gameState.lastMove.toRow === row && gameState.lastMove.toCol === col) {
              pieceSpan.classList.add('piece-appear');
            }
            
            square.appendChild(pieceSpan);
            }
          }
          
          if (piece === '‚ôî' && gameState.whiteInCheck) {
            square.classList.add('king-in-check');
          } else if (piece === '‚ôö' && gameState.blackInCheck) {
            square.classList.add('king-in-check');
          }
          
          if (gameState.freezeActive && 
              ((gameState.currentPlayer === 'white' && piece && isBlackPiece(piece)) ||
               (gameState.currentPlayer === 'black' && piece && isWhitePiece(piece)))) {
            square.classList.add('frozen-square');
          }
          
          if (gameState.teleportMode) {
            square.classList.add('teleport-mode');
          }
          
          if (gameState.bombMode && piece &&
              ((gameState.currentPlayer === 'white' && isBlackPiece(piece)) ||
               (gameState.currentPlayer === 'black' && isWhitePiece(piece)))) {
            square.classList.add('bomb-target');
          }
          
          if (gameState.lightningMode && piece &&
              ((gameState.currentPlayer === 'white' && isBlackPiece(piece)) ||
               (gameState.currentPlayer === 'black' && isWhitePiece(piece)))) {
            square.classList.add('lightning-target');
          }
          
          square.addEventListener('click', handleSquareClick);
          board.appendChild(square);
        }
      }
      
      renderLabels();
      updateStatus();
    }

    function renderLabels() {
      const config = defaultConfig;
      const baseSize = config.font_size;
      const customFont = config.font_family;
      const baseFontStack = 'system-ui, -apple-system, sans-serif';
      
      const columns = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
      const rows = ['8', '7', '6', '5', '4', '3', '2', '1'];
      
      const topLabels = document.getElementById('top-labels');
      const bottomLabels = document.getElementById('bottom-labels');
      const leftLabels = document.getElementById('left-labels');
      const rightLabels = document.getElementById('right-labels');
      
      topLabels.innerHTML = '';
      bottomLabels.innerHTML = '';
      leftLabels.innerHTML = '';
      rightLabels.innerHTML = '';
      
      columns.forEach(col => {
        const topLabel = document.createElement('div');
        topLabel.textContent = col;
        topLabel.style.color = config.text_color;
        topLabel.style.fontFamily = `${customFont}, ${baseFontStack}`;
        topLabel.style.fontSize = `${baseSize}px`;
        topLabel.style.width = '80px';
        topLabel.style.display = 'flex';
        topLabel.style.alignItems = 'center';
        topLabel.style.justifyContent = 'center';
        topLabels.appendChild(topLabel);
        
        const bottomLabel = document.createElement('div');
        bottomLabel.textContent = col;
        bottomLabel.style.color = config.text_color;
        bottomLabel.style.fontFamily = `${customFont}, ${baseFontStack}`;
        bottomLabel.style.fontSize = `${baseSize}px`;
        bottomLabel.style.width = '80px';
        bottomLabel.style.display = 'flex';
        bottomLabel.style.alignItems = 'center';
        bottomLabel.style.justifyContent = 'center';
        bottomLabels.appendChild(bottomLabel);
      });
      
      rows.forEach(row => {
        const leftLabel = document.createElement('div');
        leftLabel.textContent = row;
        leftLabel.style.color = config.text_color;
        leftLabel.style.fontFamily = `${customFont}, ${baseFontStack}`;
        leftLabel.style.fontSize = `${baseSize}px`;
        leftLabel.style.height = '80px';
        leftLabel.style.display = 'flex';
        leftLabel.style.alignItems = 'center';
        leftLabel.style.justifyContent = 'center';
        leftLabels.appendChild(leftLabel);
        
        const rightLabel = document.createElement('div');
        rightLabel.textContent = row;
        rightLabel.style.color = config.text_color;
        rightLabel.style.fontFamily = `${customFont}, ${baseFontStack}`;
        rightLabel.style.fontSize = `${baseSize}px`;
        rightLabel.style.height = '80px';
        rightLabel.style.display = 'flex';
        rightLabel.style.alignItems = 'center';
        rightLabel.style.justifyContent = 'center';
        rightLabels.appendChild(rightLabel);
      });
    }

    function handleSquareClick(e) {
      console.log('üñ±Ô∏è SQUARE CLICKED!');
      if (gameState.gameOver) {
        console.log('üö´ Game over - ignoring click');
        return;
      }
      
      console.log('üéÆ Game mode:', gameState.mode, 'Current player:', gameState.currentPlayer);
      
      if (gameState.mode === 'online') {
        const isOurTurn = (gameState.playerColor === 'white' && gameState.currentPlayer === 'white') ||
                          (gameState.playerColor === 'black' && gameState.currentPlayer === 'black');
        if (!isOurTurn && !gameState.bombMode && !gameState.swapMode) {
          console.log('üö´ Not our turn in online mode');
          return;
        }
      }
      
      const square = e.currentTarget;
      const row = parseInt(square.dataset.row);
      const col = parseInt(square.dataset.col);
      const piece = gameState.board[row][col];
      
      if (gameState.bombMode) {
        if (piece && ((gameState.currentPlayer === 'white' && isBlackPiece(piece)) ||
                      (gameState.currentPlayer === 'black' && isWhitePiece(piece)))) {
          square.querySelector('.piece').classList.add('piece-captured');
          createSparkles(square, 10);
          
          gameState.board[row][col] = '';
          if (isWhitePiece(piece)) {
            gameState.blackCaptured.push(piece);
          } else {
            gameState.whiteCaptured.push(piece);
          }
          
          // Check if king was captured - end game
          checkForKingCapture();
          
          gameState.bombMode = false;
          setTimeout(() => {
            renderBoard();
            if (gameState.mode === 'online') {
              updateGameStateOnServer();
            }
          }, 600);
        }
        return;
      }
      
      if (gameState.laserMode) {
        // Laser targeting: ask user to choose horizontal or vertical, then choose line
        const isHorizontal = confirm('Laser Targeting: Click OK for Horizontal laser, Cancel for Vertical laser');
        const line = isHorizontal ? row : col;
        
        console.log(`Laser Beam: ${isHorizontal ? 'Horizontal' : 'Vertical'} line ${line}`);
        
        let removedPieces = 0;
        for (let i = 0; i < 8; i++) {
          const targetRow = isHorizontal ? row : i;
          const targetCol = isHorizontal ? i : col;
          const targetPiece = gameState.board[targetRow][targetCol];
          
          if (targetPiece) {
            // Only remove opponent pieces (not own pieces or kings)
            const isOpponentPiece = 
              (gameState.currentPlayer === 'white' && isBlackPiece(targetPiece)) ||
              (gameState.currentPlayer === 'black' && isWhitePiece(targetPiece));
            
            if (isOpponentPiece && targetPiece !== '‚ôî' && targetPiece !== '‚ôö') {
              gameState.board[targetRow][targetCol] = '';
              removedPieces++;
              
              // Visual effect for removed piece
              const targetSquare = document.querySelector(`[data-row="${targetRow}"][data-col="${targetCol}"]`);
              if (targetSquare) {
                createExplosionEffect(targetSquare);
              }
            }
          }
        }
        
        gameState.laserMode = false;
        renderBoard();
        sendPowerUpNotification(`Laser Beam üî¥ - Removed ${removedPieces} pieces!`);
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
        return;
      }
      
      if (gameState.megaBombMode) {
        // Mega Bomb targeting: explode in 3x3 area around clicked square
        console.log(`Mega Bomb: Center at (${row}, ${col})`);
        
        let destroyedPieces = 0;
        for (let bombRow = Math.max(0, row - 1); bombRow <= Math.min(7, row + 1); bombRow++) {
          for (let bombCol = Math.max(0, col - 1); bombCol <= Math.min(7, col + 1); bombCol++) {
            const targetPiece = gameState.board[bombRow][bombCol];
            if (targetPiece) {
              // Only destroy opponent pieces (not own pieces or kings)
              const isOpponentPiece = 
                (gameState.currentPlayer === 'white' && isBlackPiece(targetPiece)) ||
                (gameState.currentPlayer === 'black' && isWhitePiece(targetPiece));
              
              if (isOpponentPiece && targetPiece !== '‚ôî' && targetPiece !== '‚ôö') {
                gameState.board[bombRow][bombCol] = '';
                destroyedPieces++;
                
                // Visual effect for destroyed piece
                const targetSquare = document.querySelector(`[data-row="${bombRow}"][data-col="${bombCol}"]`);
                if (targetSquare) {
                  createExplosionEffect(targetSquare);
                }
              }
            }
          }
        }
        
        // Create big explosion at center
        createExplosionEffect(square);
        createSparkles(square, 20);
        
        gameState.megaBombMode = false;
        renderBoard();
        sendPowerUpNotification(`Mega Bomb üí• - Destroyed ${destroyedPieces} pieces!`);
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
        return;
      }
      
      if (gameState.tornadoMode) {
        // Tornado targeting: sweep all pieces in 3x3 area
        console.log(`Tornado: Center at (${row}, ${col})`);
        
        let sweptPieces = 0;
        
        // Check 3x3 area around clicked square
        for (let r = Math.max(0, row - 1); r <= Math.min(7, row + 1); r++) {
          for (let c = Math.max(0, col - 1); c <= Math.min(7, col + 1); c++) {
            const targetPiece = gameState.board[r][c];
            if (targetPiece) {
              // Only sweep opponent pieces (not own pieces or kings)
              const isOpponentPiece = 
                (gameState.currentPlayer === 'white' && isBlackPiece(targetPiece)) ||
                (gameState.currentPlayer === 'black' && isWhitePiece(targetPiece));
              
              if (isOpponentPiece && targetPiece !== '‚ôî' && targetPiece !== '‚ôö') {
                gameState.board[r][c] = '';
                sweptPieces++;
                
                // Visual effect - tornado spiral with spinning animation
                const targetSquare = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                if (targetSquare) {
                  targetSquare.style.animation = 'tornadoSpin 1s ease-out';
                  createExplosionEffect(targetSquare);
                  createSparkles(targetSquare, 8);
                }
              }
            }
          }
        }
        
        // Create tornado effect at center
        createExplosionEffect(square);
        createSparkles(square, 25);
        
        // Create spiral tornado effect
        for (let i = 0; i < 8; i++) {
          const spiral = document.createElement('div');
          spiral.textContent = 'üå™Ô∏è';
          spiral.style.cssText = `
            position: fixed;
            left: ${square.getBoundingClientRect().left + square.offsetWidth / 2}px;
            top: ${square.getBoundingClientRect().top + square.offsetHeight / 2}px;
            font-size: 30px;
            z-index: 9999;
            pointer-events: none;
            animation: tornadoSpin ${1 + i * 0.1}s ease-out forwards;
            transform-origin: center;
          `;
          document.body.appendChild(spiral);
          setTimeout(() => spiral.remove(), 2000);
        }
        
        gameState.tornadoMode = false;
        renderBoard();
        sendPowerUpNotification(`Tornado üå™Ô∏è - Swept away ${sweptPieces} pieces!`);
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
        return;
      }
      
      if (gameState.swapMode) {
        if (!gameState.swapFirstPiece) {
          if (piece && ((gameState.currentPlayer === 'white' && isWhitePiece(piece)) ||
                        (gameState.currentPlayer === 'black' && isBlackPiece(piece)))) {
            gameState.swapFirstPiece = { row, col, piece };
            square.classList.add('selected');
          }
        } else {
          if (piece && ((gameState.currentPlayer === 'white' && isWhitePiece(piece)) ||
                        (gameState.currentPlayer === 'black' && isBlackPiece(piece)))) {
            const firstRow = gameState.swapFirstPiece.row;
            const firstCol = gameState.swapFirstPiece.col;
            const firstPiece = gameState.swapFirstPiece.piece;
            
            gameState.board[firstRow][firstCol] = piece;
            gameState.board[row][col] = firstPiece;
            
            gameState.swapMode = false;
            gameState.swapFirstPiece = null;
            renderBoard();
            if (gameState.mode === 'online') {
              updateGameStateOnServer();
            }
          }
        }
        return;
      }
      
      if (gameState.lightningMode) {
        // Lightning Strike: Strike from clicked position outward in a cross pattern
        if (piece && ((gameState.currentPlayer === 'white' && isBlackPiece(piece)) ||
                      (gameState.currentPlayer === 'black' && isWhitePiece(piece)))) {
          console.log(`Lightning Strike: Center at (${row}, ${col})`);
          
          let struckPieces = 0;
          
          // Strike in cross pattern: up, down, left, right from center
          const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
          
          for (let dist = 0; dist < 8; dist++) {
            for (const [dRow, dCol] of directions) {
              const targetRow = row + (dRow * dist);
              const targetCol = col + (dCol * dist);
              
              if (targetRow >= 0 && targetRow < 8 && targetCol >= 0 && targetCol < 8) {
                const targetPiece = gameState.board[targetRow][targetCol];
                
                if (targetPiece) {
                  // Only strike opponent pieces (not own pieces or kings)
                  const isOpponentPiece = 
                    (gameState.currentPlayer === 'white' && isBlackPiece(targetPiece)) ||
                    (gameState.currentPlayer === 'black' && isWhitePiece(targetPiece));
                  
                  if (isOpponentPiece && targetPiece !== '‚ôî' && targetPiece !== '‚ôö') {
                    gameState.board[targetRow][targetCol] = '';
                    struckPieces++;
                    
                    // Visual effect for struck piece
                    const targetSquare = document.querySelector(`[data-row="${targetRow}"][data-col="${targetCol}"]`);
                    if (targetSquare) {
                      createExplosionEffect(targetSquare);
                    }
                  }
                }
              }
            }
          }
          
          // Create lightning effect at center and animate bolts outward
          createLightningBoltEffect(square, row, col, directions, struckPieces);
          
          gameState.lightningMode = false;
          renderBoard();
          sendPowerUpNotification(`Lightning Strike ‚ö° - Struck ${struckPieces} pieces!`);
          
          if (gameState.mode === 'online') {
            updateGameStateOnServer();
          }
        }
        return;
      }
      
      if (gameState.teleportMode) {
        if (!gameState.teleportPiece) {
          if (piece && ((gameState.currentPlayer === 'white' && isWhitePiece(piece)) ||
                        (gameState.currentPlayer === 'black' && isBlackPiece(piece)))) {
            gameState.teleportPiece = { row, col };
            square.classList.add('selected');
          }
        } else {
          const fromRow = gameState.teleportPiece.row;
          const fromCol = gameState.teleportPiece.col;
          const target = gameState.board[row][col];
          
          if ((gameState.currentPlayer === 'white' && !isWhitePiece(target)) ||
              (gameState.currentPlayer === 'black' && !isBlackPiece(target))) {
            movePiece(fromRow, fromCol, row, col);
          }
        }
        return;
      }
      
      document.querySelectorAll('.square').forEach(s => {
        s.classList.remove('selected', 'highlight');
      });
      
      if (gameState.selectedSquare) {
        const [fromRow, fromCol] = gameState.selectedSquare;
        
        if (row === fromRow && col === fromCol) {
          gameState.selectedSquare = null;
          return;
        }
        
        console.log('üéØ Checking move validation:');
        console.log('  - From:', fromRow, fromCol, 'To:', row, col);
        console.log('  - canMovePiece:', canMovePiece(fromRow, fromCol, row, col));
        console.log('  - Mode check:', gameState.mode === 'ai');
        console.log('  - Turn check:', gameState.currentPlayer === 'white');
        console.log('  - Combined check:', (gameState.mode === 'ai' && gameState.currentPlayer === 'white') || (gameState.mode !== 'ai'));
        
        if (canMovePiece(fromRow, fromCol, row, col) && 
            ((gameState.mode === 'ai' && gameState.currentPlayer === 'white') ||  // In AI mode, only allow moves on white's turn
             (gameState.mode !== 'ai'))) {  // In other modes, use normal turn validation
          console.log('‚úÖ Move validated - calling movePiece()');
          movePiece(fromRow, fromCol, row, col);
          
          // FORCE AI TO MOVE IMMEDIATELY IN AI MODE
          if (gameState.mode === 'ai') {
            console.log('ü§ñ FORCING AI MOVE AFTER WHITE MOVE!');
            setTimeout(() => {
              console.log('üéØ AI FORCE TRIGGER - Setting current player to black and calling AI...');
              gameState.currentPlayer = 'black';
              // Only trigger AI if not frozen
              if (!gameState.freezeActive) {
                makeAIMoveOnBoard();
              } else {
                console.log('ü•∂ AI NOT TRIGGERED - AI is frozen');
              }
            }, 500); // Small delay to let the move complete
          }
          return;
        }
        
        console.log('‚ùå Move validation failed');
        // Invalid move - play error sound
        playErrorSound();
        gameState.selectedSquare = null;
      }
      
      if (piece && 
          ((gameState.mode === 'ai' && isWhitePiece(piece)) ||  // In AI mode, player can only select white pieces
           (gameState.mode !== 'ai' && gameState.currentPlayer === 'white' && isWhitePiece(piece)) ||
           (gameState.mode !== 'ai' && gameState.currentPlayer === 'black' && isBlackPiece(piece)))) {
        playSelectSound();
        gameState.selectedSquare = [row, col];
        square.classList.add('selected');
        
        const pieceElement = square.querySelector('.piece');
        if (pieceElement) {
          pieceElement.classList.add('piece-wiggle');
          setTimeout(() => pieceElement.classList.remove('piece-wiggle'), 300);
        }
        
        const hasVision = (gameState.currentPlayer === 'white' && gameState.whiteVisionActive) ||
                          (gameState.currentPlayer === 'black' && gameState.blackVisionActive);
        if (hasVision || true) {
          for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
              if (canMovePiece(row, col, r, c)) {
                const targetSquare = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                targetSquare.classList.add('highlight');
              }
            }
          }
        }
      }
    }

    function updateStatus() {
      const config = defaultConfig;
      const baseSize = config.font_size;
      const customFont = config.font_family;
      const baseFontStack = 'system-ui, -apple-system, sans-serif';
      
      const currentPlayerDiv = document.getElementById('current-player');
      currentPlayerDiv.style.color = config.text_color;
      currentPlayerDiv.style.fontFamily = `${customFont}, ${baseFontStack}`;
      currentPlayerDiv.style.fontSize = `${baseSize * 1.25}px`;
      
      const whiteCapturesDiv = document.getElementById('white-captures');
      whiteCapturesDiv.style.color = config.text_color;
      whiteCapturesDiv.style.fontFamily = `${customFont}, ${baseFontStack}`;
      whiteCapturesDiv.style.fontSize = `${baseSize * 1.125}px`;
      
      const blackCapturesDiv = document.getElementById('black-captures');
      blackCapturesDiv.style.color = config.text_color;
      blackCapturesDiv.style.fontFamily = `${customFont}, ${baseFontStack}`;
      blackCapturesDiv.style.fontSize = `${baseSize * 1.125}px`;
      
      const statusDiv = document.getElementById('game-status');
      statusDiv.style.color = config.text_color;
      statusDiv.style.fontFamily = `${customFont}, ${baseFontStack}`;
      statusDiv.style.fontSize = `${baseSize * 1.25}px`;
      
      if (gameState.gameOver) {
        const winner = gameState.currentPlayer === 'white' ? config.player_black_label : config.player_white_label;
        statusDiv.textContent = `üéä ${winner} wins! üéä`;
        statusDiv.classList.add('celebration-text');
        currentPlayerDiv.textContent = '';
      } else {
        const playerLabel = gameState.currentPlayer === 'white' ? config.player_white_label : config.player_black_label;
        const emoji = gameState.currentPlayer === 'white' ? '‚ö™' : '‚ö´';
        let turnText = `${emoji} ${playerLabel}'s turn`;
        
        if (gameState.mode === 'online') {
          const isOurTurn = (gameState.playerColor === 'white' && gameState.currentPlayer === 'white') ||
                            (gameState.playerColor === 'black' && gameState.currentPlayer === 'black');
          if (isOurTurn) {
            turnText += ' (Your Turn)';
          } else {
            turnText += ' (Opponent\'s Turn)';
          }
        } else if (gameState.mode === 'ai') {
          if (gameState.currentPlayer === 'white') {
            turnText += ' (Your Turn)';
          } else {
            turnText += ' (AI Thinking...)';
          }
        }
        
        if (gameState.freezeActive) {
          turnText += ' ‚ùÑ (FROZEN)';
        }
        if (gameState.bombMode) {
          turnText += ' üí£ (BOMB MODE)';
        }
        if (gameState.swapMode) {
          turnText += ' üîÑ (SWAP MODE)';
        }
        
        currentPlayerDiv.textContent = turnText;
        
        if ((gameState.currentPlayer === 'white' && gameState.whiteInCheck) || 
            (gameState.currentPlayer === 'black' && gameState.blackInCheck)) {
          statusDiv.textContent = '‚ö† CHECK! ‚ö†';
          statusDiv.style.color = '#ef4444';
        } else {
          statusDiv.textContent = '';
          statusDiv.style.color = config.text_color;
        }
      }
      
      whiteCapturesDiv.textContent = `${config.player_white_label} captured: ${gameState.whiteCaptured.join(' ')}`;
      blackCapturesDiv.textContent = `${config.player_black_label} captured: ${gameState.blackCaptured.join(' ')}`;
    }

    function updatePowerUpButtons() {
      console.log('updatePowerUpButtons called');
      console.log('Current player:', gameState.currentPlayer);
      console.log('White power-ups:', gameState.whitePowerUps);
      console.log('Black power-ups:', gameState.blackPowerUps);
      
      // Check if DOM is ready
      const gameArea = document.getElementById('game-area');
      console.log('Game area exists:', !!gameArea);
      console.log('Game area display:', gameArea ? gameArea.style.display : 'N/A');
      
      Object.keys(powerUpsData).forEach(powerupId => {
        const btn = document.getElementById(`${powerupId.replace('_', '-')}-btn`);
        const countSpan = document.getElementById(`${powerupId.replace('_', '-')}-count`);
        
        if (!btn || !countSpan) {
          console.log(`Missing elements for ${powerupId}: btn=${!!btn}, count=${!!countSpan}`);
          return;
        }
        
        const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
        const count = currentPowerUps[powerupId] || 0;
        
        console.log(`Updating ${powerupId}: count=${count}`);
        countSpan.textContent = count;
        
        let canUse = count > 0 && !gameState.gameOver && !gameState.disablePowerups;
        
        if (gameState.mode === 'online') {
          const isOurTurn = (gameState.playerColor === 'white' && gameState.currentPlayer === 'white') ||
                            (gameState.playerColor === 'black' && gameState.currentPlayer === 'black');
          canUse = canUse && isOurTurn;
        } else if (gameState.mode === 'ai') {
          // In AI mode, only allow power-ups on white's turn (player's turn)
          canUse = canUse && gameState.currentPlayer === 'white';
        }
        
        if (powerupId === 'undo') {
          canUse = canUse && gameState.moveHistory.length > 0;
        } else if (powerupId === 'shield') {
          const shieldActive = gameState.currentPlayer === 'white' ? gameState.whiteShieldActive : gameState.blackShieldActive;
          canUse = canUse && !shieldActive;
        } else if (powerupId === 'double_coins') {
          const doubleActive = gameState.currentPlayer === 'white' ? gameState.whiteDoubleCoinsActive : gameState.blackDoubleCoinsActive;
          canUse = canUse && !doubleActive;
        } else if (powerupId === 'freeze') {
          canUse = canUse && !gameState.freezeActive;
        } else if (powerupId === 'knight_boost') {
          const boostActive = gameState.currentPlayer === 'white' ? gameState.whiteKnightBoostActive : gameState.blackKnightBoostActive;
          canUse = canUse && !boostActive;
        } else if (powerupId === 'vision') {
          const visionActive = gameState.currentPlayer === 'white' ? gameState.whiteVisionActive : gameState.blackVisionActive;
          canUse = canUse && !visionActive;
        } else if (powerupId === 'swap') {
          canUse = canUse && !gameState.swapMode;
        } else if (powerupId === 'bomb') {
          canUse = canUse && !gameState.bombMode;
        } else if (powerupId === 'time_warp') {
          canUse = canUse && !gameState.timeWarpActive;
        } else if (powerupId === 'lightning') {
          canUse = canUse && !gameState.lightningMode;
        } else if (powerupId === 'clone') {
          canUse = canUse && !gameState.cloneMode;
        } else if (powerupId === 'magnet') {
          canUse = canUse && !gameState.magnetMode;
        } else if (powerupId === 'poison') {
          canUse = canUse && !gameState.poisonMode;
        } else if (powerupId === 'shield_wall') {
          const shieldWallActive = gameState.currentPlayer === 'white' ? gameState.whiteShieldWallActive : gameState.blackShieldWallActive;
          canUse = canUse && !shieldWallActive;
        } else if (powerupId === 'speed_boost') {
          const speedBoostActive = gameState.currentPlayer === 'white' ? gameState.whiteSpeedBoostActive : gameState.blackSpeedBoostActive;
          canUse = canUse && !speedBoostActive;
        } else if (powerupId === 'invisibility') {
          const invisibilityActive = gameState.currentPlayer === 'white' ? gameState.whiteInvisibilityActive : gameState.blackInvisibilityActive;
          canUse = canUse && !invisibilityActive;
        } else if (powerupId === 'earthquake') {
          canUse = canUse && !gameState.gameOver;
        } else if (powerupId === 'blizzard') {
          canUse = canUse && !gameState.blizzardActive;
        } else if (powerupId === 'laser') {
          canUse = canUse && !gameState.laserMode;
        } else if (powerupId === 'mirror') {
          canUse = canUse && !gameState.gameOver;
        } else if (powerupId === 'tornado') {
          canUse = canUse && !gameState.tornadoMode;
        } else if (powerupId === 'gravity') {
          canUse = canUse && !gameState.gameOver;
        } else if (powerupId === 'phoenix') {
          canUse = canUse && !gameState.gameOver;
        } else if (powerupId === 'time_freeze') {
          canUse = canUse && !gameState.gameOver;
        } else if (powerupId === 'coin_rain') {
          canUse = canUse && !gameState.gameOver;
        } else if (powerupId === 'power_steal') {
          canUse = canUse && !gameState.gameOver;
        } else if (powerupId === 'mega_bomb') {
          canUse = canUse && !gameState.megaBombMode;
        } else if (powerupId === 'royal_guard') {
          const royalGuardActive = gameState.currentPlayer === 'white' ? gameState.whiteRoyalGuardActive : gameState.blackRoyalGuardActive;
          canUse = canUse && !royalGuardActive;
        } else if (powerupId === 'lucky_charm') {
          const luckyCharmActive = gameState.currentPlayer === 'white' ? gameState.whiteLuckyCharmActive : gameState.blackLuckyCharmActive;
          canUse = canUse && !luckyCharmActive;
        } else if (powerupId === 'chaos') {
          canUse = canUse && !gameState.gameOver;
        }
        
        console.log(`${powerupId} canUse: ${canUse}`);
        
        if (canUse) {
          btn.classList.add('available');
        } else {
          btn.classList.remove('available');
        }
      });
      
      console.log('updatePowerUpButtons completed');
    }
    
    // Function to update power-up buttons when game area becomes visible
    function updatePowerUpButtonsWhenVisible() {
      const gameArea = document.getElementById('game-area');
      if (gameArea && gameArea.style.display !== 'none') {
        console.log('Game area is visible, updating power-up buttons');
        updatePowerUpButtons();
      } else {
        console.log('Game area not visible, scheduling update');
        setTimeout(updatePowerUpButtonsWhenVisible, 100);
      }
    }
    
    // Helper function to check and update power-ups when needed
    function ensurePowerUpButtonsUpdated() {
      if (document.getElementById('game-area').style.display !== 'none') {
        updatePowerUpButtons();
      }
    }
    // Enhanced save function that works in iframes
    function savePlayerProgress() {
      // Check if we're in an iframe (Google Sites embedding)
      if (window.self !== window.top) {
        // We're in an iframe, use server storage instead of localStorage
        saveToServer();
      } else {
        // We're not in an iframe, use localStorage
        try {
          const playerData = {
            whiteCoins: gameState.whiteCoins,
            blackCoins: gameState.blackCoins,
            whitePowerUps: gameState.whitePowerUps,
            blackPowerUps: gameState.blackPowerUps,
            whiteUnlockedSkins: gameState.whiteUnlockedSkins,
            blackUnlockedSkins: gameState.blackUnlockedSkins,
            whiteCurrentSkin: gameState.whiteCurrentSkin,
            blackCurrentSkin: gameState.blackCurrentSkin,
            unlockedThemes: gameState.unlockedThemes,
            currentTheme: gameState.currentTheme,
            currentEffect: gameState.currentEffect,
            purchasedEffects: Object.keys(effects).filter(effectId => effects[effectId].purchased),
            unlockedSoundPacks: gameState.unlockedSoundPacks,
            currentSoundPack: gameState.currentSoundPack,
            playerName: gameState.playerName,
            lastSaved: new Date().toISOString()
          };
          
          localStorage.setItem('chessPlayerProgress', JSON.stringify(playerData));
          
          // Also save a backup
          localStorage.setItem('chessPlayerProgress_Backup', JSON.stringify(playerData));
          
          console.log('Progress saved to localStorage:', playerData);
        } catch (error) {
          console.error('Failed to save to localStorage:', error);
          // Fallback to server storage
          saveToServer();
        }
      }
    }
    
    // Server-based save function for iframe environments
    function saveToServer() {
      if (!ONLINE_STORAGE_CONFIG.provider || !gameState.playerName) {
        console.log('Cannot save to server: missing storage config or player name');
        showNotification('‚ö†Ô∏è Please configure online storage to save progress in embedded mode');
        return;
      }
      
      const playerData = {
        whiteCoins: gameState.whiteCoins,
        blackCoins: gameState.blackCoins,
        whitePowerUps: gameState.whitePowerUps,
        blackPowerUps: gameState.blackPowerUps,
        whiteUnlockedSkins: gameState.whiteUnlockedSkins,
        blackUnlockedSkins: gameState.blackUnlockedSkins,
        whiteCurrentSkin: gameState.whiteCurrentSkin,
        blackCurrentSkin: gameState.blackCurrentSkin,
        unlockedThemes: gameState.unlockedThemes,
        currentTheme: gameState.currentTheme,
        currentEffect: gameState.currentEffect,
        purchasedEffects: Object.keys(effects).filter(effectId => effects[effectId].purchased),
        playerName: gameState.playerName,
        lastSaved: new Date().toISOString(),
        isPlayerProgress: true // Flag to distinguish from game data
      };
      
      // Use player name as the key for their progress
      const progressKey = `player_${gameState.playerName.replace(/[^a-zA-Z0-9]/g, '_')}`;
      
      onlineStorageHandler.save(progressKey, playerData).then(result => {
        if (result.isOk) {
          console.log('Progress saved to server:', playerData);
          showNotification('üíæ Progress saved to server!');
        } else {
          console.error('Failed to save to server:', result.error);
          showNotification('‚ùå Failed to save progress');
        }
      }).catch(error => {
        console.error('Error saving to server:', error);
        showNotification('‚ùå Error saving progress');
      });
    }
    
    function loadPlayerProgress() {
      // Check if we're in an iframe (Google Sites embedding)
      if (window.self !== window.top) {
        // We're in an iframe, try to load from server
        loadFromServer();
      } else {
        // We're not in an iframe, try to load from localStorage
        try {
          const savedData = localStorage.getItem('chessPlayerProgress');
          if (savedData) {
            const playerData = JSON.parse(savedData);
            
            console.log('Loading player data from localStorage:', playerData);
            console.log('White power-ups loaded:', playerData.whitePowerUps);
            
            // Load player progress
            if (playerData.whiteCoins !== undefined) gameState.whiteCoins = playerData.whiteCoins;
            if (playerData.blackCoins !== undefined) gameState.blackCoins = playerData.blackCoins;
            if (playerData.whitePowerUps) gameState.whitePowerUps = { ...defaultPowerUps, ...playerData.whitePowerUps };
            if (playerData.blackPowerUps) gameState.blackPowerUps = { ...defaultPowerUps, ...playerData.blackPowerUps };
            if (playerData.whiteUnlockedSkins) gameState.whiteUnlockedSkins = playerData.whiteUnlockedSkins;
            if (playerData.blackUnlockedSkins) gameState.blackUnlockedSkins = playerData.blackUnlockedSkins;
            if (playerData.whiteCurrentSkin) gameState.whiteCurrentSkin = playerData.whiteCurrentSkin;
            if (playerData.blackCurrentSkin) gameState.blackCurrentSkin = playerData.blackCurrentSkin;
            if (playerData.unlockedThemes) gameState.unlockedThemes = playerData.unlockedThemes;
            if (playerData.currentTheme) gameState.currentTheme = playerData.currentTheme;
            if (playerData.currentEffect) gameState.currentEffect = playerData.currentEffect;
            if (playerData.purchasedEffects) {
              playerData.purchasedEffects.forEach(effectId => {
                if (effects[effectId]) effects[effectId].purchased = true;
              });
            }
            if (playerData.unlockedSoundPacks) gameState.unlockedSoundPacks = playerData.unlockedSoundPacks;
            if (playerData.currentSoundPack) gameState.currentSoundPack = playerData.currentSoundPack;
            if (playerData.playerName) gameState.playerName = playerData.playerName;
            
            console.log('Player progress loaded from localStorage successfully!');
            updatePowerUpButtons();
            renderBoard();
          } else {
            console.log('No saved player data found in localStorage');
          }
        } catch (error) {
          console.error('Failed to load from localStorage:', error);
          // Fallback to server storage
          loadFromServer();
        }
      }
    }
    
    // Server-based load function for iframe environments
    function loadFromServer() {
      if (!ONLINE_STORAGE_CONFIG.provider || !gameState.playerName) {
        console.log('Cannot load from server: missing storage config or player name');
        return;
      }
      
      // Use player name as the key for their progress
      const progressKey = `player_${gameState.playerName.replace(/[^a-zA-Z0-9]/g, '_')}`;
      
      onlineStorageHandler.get(progressKey).then(result => {
        if (result.isOk && result.data) {
          const playerData = result.data;
          
          // Only load if it's actually player progress data
          if (playerData.isPlayerProgress) {
            console.log('Loading player data from server:', playerData);
            
            // Load player progress
            if (playerData.whiteCoins !== undefined) gameState.whiteCoins = playerData.whiteCoins;
            if (playerData.blackCoins !== undefined) gameState.blackCoins = playerData.blackCoins;
            if (playerData.whitePowerUps) gameState.whitePowerUps = { ...defaultPowerUps, ...playerData.whitePowerUps };
            if (playerData.blackPowerUps) gameState.blackPowerUps = { ...defaultPowerUps, ...playerData.blackPowerUps };
            if (playerData.whiteUnlockedSkins) gameState.whiteUnlockedSkins = playerData.whiteUnlockedSkins;
            if (playerData.blackUnlockedSkins) gameState.blackUnlockedSkins = playerData.blackUnlockedSkins;
            if (playerData.whiteCurrentSkin) gameState.whiteCurrentSkin = playerData.whiteCurrentSkin;
            if (playerData.blackCurrentSkin) gameState.blackCurrentSkin = playerData.blackCurrentSkin;
            if (playerData.unlockedThemes) gameState.unlockedThemes = playerData.unlockedThemes;
            if (playerData.currentTheme) gameState.currentTheme = playerData.currentTheme;
            if (playerData.currentEffect) gameState.currentEffect = playerData.currentEffect;
            if (playerData.purchasedEffects) {
              playerData.purchasedEffects.forEach(effectId => {
                if (effects[effectId]) effects[effectId].purchased = true;
              });
            }
            if (playerData.unlockedSoundPacks) gameState.unlockedSoundPacks = playerData.unlockedSoundPacks;
            if (playerData.currentSoundPack) gameState.currentSoundPack = playerData.currentSoundPack;
            
            console.log('Player progress loaded from server successfully!');
            showNotification('üì• Progress loaded from server!');
            updatePowerUpButtons();
            renderBoard();
          } else {
            console.log('Found data but it\'s not player progress');
          }
        } else {
          console.log('No saved player data found on server');
        }
      }).catch(error => {
        console.error('Error loading from server:', error);
        showNotification('‚ùå Error loading progress');
      });
    }
    
    function clearAllLocalData() {
      try {
        localStorage.removeItem('chessPlayerProgress');
        localStorage.removeItem('chessPlayerProgress_Backup');
        console.log('Local data cleared');
      } catch (error) {
        console.error('Error clearing local data:', error);
      }
    }
    
    function playPowerUpSound() {
      // Magical power-up sound
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
      oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.05); // E5
      oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.1); // G5
      
      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.3);
    }
    
    // Power-up specific sound functions
    function playLightningSound() {
      // Thunder sound with low rumble and high crack
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      // Low rumble
      const rumble = audioContext.createOscillator();
      const rumbleGain = audioContext.createGain();
      rumble.connect(rumbleGain);
      rumbleGain.connect(audioContext.destination);
      rumble.frequency.setValueAtTime(60, audioContext.currentTime); // Low B
      rumble.type = 'sawtooth';
      rumbleGain.gain.setValueAtTime(0.4, audioContext.currentTime);
      rumbleGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.8);
      
      // High crack
      const crack = audioContext.createOscillator();
      const crackGain = audioContext.createGain();
      crack.connect(crackGain);
      crackGain.connect(audioContext.destination);
      crack.frequency.setValueAtTime(2000, audioContext.currentTime); // High B
      crack.type = 'square';
      crackGain.gain.setValueAtTime(0.3, audioContext.currentTime);
      crackGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
      
      rumble.start(audioContext.currentTime);
      rumble.stop(audioContext.currentTime + 0.8);
      crack.start(audioContext.currentTime + 0.05);
      crack.stop(audioContext.currentTime + 0.15);
    }
    
    function playMegaBombSound() {
      // Deep explosion with multiple layers
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      // Deep boom
      const boom = audioContext.createOscillator();
      const boomGain = audioContext.createGain();
      boom.connect(boomGain);
      boomGain.connect(audioContext.destination);
      boom.frequency.setValueAtTime(40, audioContext.currentTime); // Very low E
      boom.type = 'sawtooth';
      boomGain.gain.setValueAtTime(0.5, audioContext.currentTime);
      boomGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1.2);
      
      // Mid explosion
      const mid = audioContext.createOscillator();
      const midGain = audioContext.createGain();
      mid.connect(midGain);
      midGain.connect(audioContext.destination);
      mid.frequency.setValueAtTime(150, audioContext.currentTime); // Low D
      mid.type = 'square';
      midGain.gain.setValueAtTime(0.3, audioContext.currentTime);
      midGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.6);
      
      // High crackle
      const crackle = audioContext.createOscillator();
      const crackleGain = audioContext.createGain();
      crackle.connect(crackleGain);
      crackleGain.connect(audioContext.destination);
      crackle.frequency.setValueAtTime(800, audioContext.currentTime); // High G
      crackle.type = 'sawtooth';
      crackleGain.gain.setValueAtTime(0.2, audioContext.currentTime);
      crackleGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
      
      boom.start(audioContext.currentTime);
      boom.stop(audioContext.currentTime + 1.2);
      mid.start(audioContext.currentTime + 0.1);
      mid.stop(audioContext.currentTime + 0.6);
      crackle.start(audioContext.currentTime + 0.05);
      crackle.stop(audioContext.currentTime + 0.3);
    }
    
    function playTornadoSound() {
      // Swirling wind sound
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      const wind = audioContext.createOscillator();
      const windGain = audioContext.createGain();
      wind.connect(windGain);
      windGain.connect(audioContext.destination);
      wind.type = 'sawtooth';
      
      // Create swirling effect with frequency modulation
      wind.frequency.setValueAtTime(200, audioContext.currentTime);
      wind.frequency.linearRampToValueAtTime(400, audioContext.currentTime + 0.2);
      wind.frequency.linearRampToValueAtTime(150, audioContext.currentTime + 0.4);
      wind.frequency.linearRampToValueAtTime(350, audioContext.currentTime + 0.6);
      wind.frequency.linearRampToValueAtTime(100, audioContext.currentTime + 0.8);
      
      windGain.gain.setValueAtTime(0, audioContext.currentTime);
      windGain.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.1);
      windGain.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.7);
      windGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.8);
      
      wind.start(audioContext.currentTime);
      wind.stop(audioContext.currentTime + 0.8);
    }
    
    function playLaserSound() {
      // High-energy laser beam sound
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      const laser = audioContext.createOscillator();
      const laserGain = audioContext.createGain();
      laser.connect(laserGain);
      laserGain.connect(audioContext.destination);
      laser.type = 'square';
      
      // Rising pitch for charging
      laser.frequency.setValueAtTime(400, audioContext.currentTime);
      laser.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.2);
      
      laserGain.gain.setValueAtTime(0, audioContext.currentTime);
      laserGain.gain.linearRampToValueAtTime(0.4, audioContext.currentTime + 0.1);
      laserGain.gain.linearRampToValueAtTime(0.4, audioContext.currentTime + 0.3);
      laserGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.4);
      
      laser.start(audioContext.currentTime);
      laser.stop(audioContext.currentTime + 0.4);
    }
    
    function playShieldSound() {
      // Magical shield activation sound
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      const shield = audioContext.createOscillator();
      const shieldGain = audioContext.createGain();
      shield.connect(shieldGain);
      shieldGain.connect(audioContext.destination);
      shield.type = 'sine';
      
      // Ascending chime
      shield.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
      shield.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
      shield.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G5
      shield.frequency.setValueAtTime(1046.5, audioContext.currentTime + 0.3); // C6
      
      shieldGain.gain.setValueAtTime(0, audioContext.currentTime);
      shieldGain.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.05);
      shieldGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
      
      shield.start(audioContext.currentTime);
      shield.stop(audioContext.currentTime + 0.5);
    }
    
    function playFreezeSound() {
      // Ice crystallization sound
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      const freeze = audioContext.createOscillator();
      const freezeGain = audioContext.createGain();
      freeze.connect(freezeGain);
      freezeGain.connect(audioContext.destination);
      freeze.type = 'triangle';
      
      // Descending crystalline notes
      freeze.frequency.setValueAtTime(800, audioContext.currentTime); // High G
      freeze.frequency.setValueAtTime(600, audioContext.currentTime + 0.1); // High D
      freeze.frequency.setValueAtTime(400, audioContext.currentTime + 0.2); // High G
      freeze.frequency.setValueAtTime(300, audioContext.currentTime + 0.3); // High D
      
      freezeGain.gain.setValueAtTime(0.2, audioContext.currentTime);
      freezeGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
      
      freeze.start(audioContext.currentTime);
      freeze.stop(audioContext.currentTime + 0.4);
    }
    
    function playBombSound() {
      // Classic bomb explosion
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      const explosion = audioContext.createOscillator();
      const explosionGain = audioContext.createGain();
      explosion.connect(explosionGain);
      explosionGain.connect(audioContext.destination);
      explosion.type = 'sawtooth';
      
      explosion.frequency.setValueAtTime(100, audioContext.currentTime); // Low G
      explosion.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.1); // Drop to lower
      
      explosionGain.gain.setValueAtTime(0.4, audioContext.currentTime);
      explosionGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
      
      explosion.start(audioContext.currentTime);
      explosion.stop(audioContext.currentTime + 0.5);
    }
    
    function playCoinsSound() {
      // Satisfying coin collection sound
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.setValueAtTime(800, audioContext.currentTime); // G5
      oscillator.frequency.setValueAtTime(1000, audioContext.currentTime + 0.05); // B6
      oscillator.frequency.setValueAtTime(1200, audioContext.currentTime + 0.1); // D6
      
      gainNode.gain.setValueAtTime(0.25, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.4);
    }
    
    function playBuySound() {
      // Purchase confirmation sound
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // A4
      oscillator.frequency.setValueAtTime(554.37, audioContext.currentTime + 0.05); // C#5
      oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
      
      gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.3);
    }
    
    function playIntroSound() {
      // Epic intro sound - but only play after user interaction
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      // Create multiple oscillators for a rich chord
      const oscillators = [];
      const gainNode = audioContext.createGain();
      
      // Root chord frequencies (C major 7th)
      const frequencies = [130.81, 164.81, 196.00, 246.94]; // C3, E3, G3, B3
      
      frequencies.forEach((freq, index) => {
        const osc = audioContext.createOscillator();
        const oscGain = audioContext.createGain();
        
        osc.connect(oscGain);
        oscGain.connect(gainNode);
        
        osc.frequency.setValueAtTime(freq, audioContext.currentTime);
        oscGain.gain.setValueAtTime(0.15, audioContext.currentTime);
        oscGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 2);
        
        // Stagger the start times for a dramatic effect
        osc.start(audioContext.currentTime + index * 0.1);
        osc.stop(audioContext.currentTime + 2);
        
        oscillators.push(osc);
      });
      
      // Add a majestic sweep
      const sweepOsc = audioContext.createOscillator();
      const sweepGain = audioContext.createGain();
      
      sweepOsc.connect(sweepGain);
      sweepGain.connect(gainNode);
      
      sweepOsc.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
      sweepOsc.frequency.exponentialRampToValueAtTime(261.63, audioContext.currentTime + 1.5); // C4
      
      sweepGain.gain.setValueAtTime(0, audioContext.currentTime);
      sweepGain.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.2);
      sweepGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1.8);
      
      sweepOsc.start(audioContext.currentTime);
      sweepOsc.stop(audioContext.currentTime + 2);
      
      gainNode.connect(audioContext.destination);
      
      console.log('Intro sound played successfully');
    }
    
    // Add intro sound to first user interaction
    let introSoundPlayed = false;
    function playIntroSoundOnce() {
      if (!introSoundPlayed) {
        introSoundPlayed = true;
        playIntroSound();
      }
    }
    
    // AI Chess Engine Functions
    function getPieceValue(piece) {
      if (!piece) return 0;
      const pieceType = piece.toLowerCase();
      const values = {
        '‚ôü': 1, '‚ôô': 1,  // Pawn
        '‚ôû': 3, '‚ôò': 3,  // Knight
        '‚ôù': 3, '‚ôó': 3,  // Bishop
        '‚ôú': 5, '‚ôñ': 5,  // Rook
        '‚ôõ': 9, '‚ôï': 9,  // Queen
        '‚ôö': 1000, '‚ôî': 1000  // King
      };
      return values[pieceType] || 0;
    }
    
    function evaluateBoard(board) {
      let score = 0;
      
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          const piece = board[row][col];
          if (!piece) continue;
          
          const pieceValue = getPieceValue(piece);
          const positionBonus = getPositionBonus(piece, row, col);
          
          if (isBlackPiece(piece)) {
            score += pieceValue + positionBonus;
          } else {
            score -= pieceValue + positionBonus;
          }
        }
      }
      
      return score;
    }
    
    function getPositionBonus(piece, row, col) {
      const pieceType = piece.toLowerCase();
      const centerBonus = [3, 4].includes(row) && [3, 4].includes(col) ? 0.5 : 0;
      const advancementBonus = pieceType === '‚ôü' ? (7 - row) * 0.1 : 0;
      const backRankBonus = (pieceType === '‚ôú' || pieceType === '‚ôõ') && row === 0 ? 0.3 : 0;
      
      return centerBonus + advancementBonus + backRankBonus;
    }
    
    function getAllValidMoves(board, player) {
      const moves = [];
      
      console.log('Getting valid moves for player:', player);
      console.log('Board state:', board);
      
      for (let fromRow = 0; fromRow < 8; fromRow++) {
        for (let fromCol = 0; fromCol < 8; fromCol++) {
          const piece = board[fromRow][fromCol];
          if (!piece) continue;
          
          if ((player === 'black' && isBlackPiece(piece)) || 
              (player === 'white' && isWhitePiece(piece))) {
            
            console.log(`Checking moves for ${piece} at (${fromRow},${fromCol})`);
            let pieceMoves = 0;
            
            for (let toRow = 0; toRow < 8; toRow++) {
              for (let toCol = 0; toCol < 8; toCol++) {
                if (canPieceMoveTo(piece, fromRow, fromCol, toRow, toCol)) {
                  // Check if this move would leave the king in check
                  const testBoard = board.map(row => [...row]);
                  testBoard[toRow][toCol] = piece;
                  testBoard[fromRow][fromCol] = '';
                  
                  if (!wouldBeInCheck(testBoard, player)) {
                    moves.push({ fromRow, fromCol, toRow, toCol, piece });
                    pieceMoves++;
                  }
                }
              }
            }
            
            console.log(`Found ${pieceMoves} valid moves for ${piece} at (${fromRow},${fromCol})`);
          }
        }
      }
      
      console.log('Found', moves.length, 'valid moves for', player);
      return moves;
    }
    
    function makeAIMove(board, fromRow, fromCol, toRow, toCol) {
      const newBoard = board.map(row => [...row]);
      const piece = newBoard[fromRow][fromCol];
      const captured = newBoard[toRow][toCol];
      
      newBoard[toRow][toCol] = piece;
      newBoard[fromRow][fromCol] = '';
      
      return { board: newBoard, captured };
    }
    
    function minimax(board, depth, alpha, beta, maximizingPlayer) {
      if (depth === 0) {
        return { score: evaluateBoard(board) };
      }
      
      const player = maximizingPlayer ? 'black' : 'white';
      const moves = getAllValidMoves(board, player);
      
      if (moves.length === 0) {
        return { score: evaluateBoard(board) };
      }
      
      let bestMove = null;
      let bestScore = maximizingPlayer ? -Infinity : Infinity;
      
      for (const move of moves) {
        const result = makeAIMove(board, move.fromRow, move.fromCol, move.toRow, move.toCol);
        const evaluation = minimax(result.board, depth - 1, alpha, beta, !maximizingPlayer);
        
        if (maximizingPlayer) {
          if (evaluation.score > bestScore) {
            bestScore = evaluation.score;
            bestMove = move;
          }
          alpha = Math.max(alpha, bestScore);
        } else {
          if (evaluation.score < bestScore) {
            bestScore = evaluation.score;
            bestMove = move;
          }
          beta = Math.min(beta, bestScore);
        }
        
        if (beta <= alpha) {
          break; // Alpha-beta pruning
        }
      }
      
      return { score: bestScore, move: bestMove };
    }
    
    function getBestMove() {
      const depth = gameState.aiDifficulty === 'easy' ? 1 : 
                   gameState.aiDifficulty === 'medium' ? 2 : 3;
      
      console.log('Getting best move with depth:', depth, 'difficulty:', gameState.aiDifficulty);
      console.log('Current board state:', gameState.board);
      console.log('Current player:', gameState.currentPlayer);
      
      // First, let's see if AI has any valid moves at all
      const allMoves = getAllValidMoves(gameState.board, 'black');
      console.log('All valid moves for black:', allMoves);
      console.log('Number of valid moves:', allMoves.length);
      
      if (allMoves.length === 0) {
        console.log('No valid moves found for AI - possible checkmate/stalemate');
        return null;
      }
      
      const result = minimax(gameState.board, depth, -Infinity, Infinity, true);
      console.log('Minimax result:', result);
      return result.move;
    }
    
    // Manual AI test function - call from console with: testAI()
    function testAI() {
      console.log('üß™ MANUAL AI TEST STARTED');
      console.log('Current game state:');
      console.log('  - Mode:', gameState.mode);
      console.log('  - Current player:', gameState.currentPlayer);
      console.log('  - AI difficulty:', gameState.aiDifficulty);
      console.log('  - Game over:', gameState.gameOver);
      
      // Force AI mode for testing
      gameState.mode = 'ai';
      gameState.currentPlayer = 'black';
      gameState.gameOver = false;
      
      console.log('üîß Forced AI mode - now triggering AI move...');
      makeAIMoveOnBoard();
    }
    
    // Make test function available globally
    window.testAI = testAI;
    
    // Emergency function to close all modals and restore input
    function closeAllModals() {
      console.log('üö® Closing all modals to restore input...');
      
      // List of all modal IDs
      const modalIds = [
        'join-modal',
        'public-lobby-modal', 
        'help-modal',
        'shop-modal',
        'admin-modal',
        'skins-modal',
        'settings-modal',
        'ai-modal'
      ];
      
      // Close all modals
      modalIds.forEach(id => {
        const modal = document.getElementById(id);
        if (modal) {
          modal.style.display = 'none';
          console.log(`Closed modal: ${id}`);
        }
      });
      
      // Remove any active elements that might have focus
      if (document.activeElement) {
        document.activeElement.blur();
      }
      
      // Clear any alerts (though we can't programmatically close browser alerts)
      console.log('‚úÖ All modals closed. If you still can\'t type, there might be a browser alert dialog - press Enter or Escape to close it.');
    }

    // Make it available globally
    window.closeAllModals = closeAllModals;

    // Also add keyboard shortcut to close modals (Escape key)
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') {
        closeAllModals();
      }
    });

    console.log('üîß Emergency modal closer loaded. Press ESC or call closeAllModals() if you can\'t type.');

    // Simple test function
    function simpleTest() {
      console.log('üéØ SIMPLE TEST WORKING!');
      alert('JavaScript is working! Click OK to continue.');
    }
    window.simpleTest = simpleTest;
    
    // Basic test - check if console is working
    console.log('üß™ CONSOLE TEST - If you see this, JavaScript is working');
    console.log('üß™ testAI function available:', typeof window.testAI);
    console.log('üß™ simpleTest function available:', typeof window.simpleTest);
    
    // Global Public Lobby Configuration - Firebase
    const GLOBAL_LOBBY_CONFIG = {
      // Your actual Firebase configuration
      apiKey: "AIzaSyBMy2MS8UUxrxui_QdLwG_r5C6GhUy4pvM",
      authDomain: "new-chess-game-cc325.firebaseapp.com",
      databaseURL: "https://new-chess-game-cc325-default-rtdb.firebaseio.com",
      projectId: "new-chess-game-cc325",
      storageBucket: "new-chess-game-cc325.firebasestorage.app",
      messagingSenderId: "641864406456",
      appId: "1:641864406456:web:be77c86068509de3212b4d",
      measurementId: "G-TQ97LB2J04",
      refreshInterval: 5000 // Refresh every 5 seconds (fallback)
    };
    
    // Initialize Firebase
    let globalLobbyInterval = null;
    let lastGlobalUpdate = 0;
    let removedGames = new Set(); // Track games that were manually removed
    
    // Initialize Firebase
    function initializeFirebase() {
      try {
        // Check if Firebase is already loaded and initialized
        if (typeof firebase !== 'undefined' && !firebase.apps.length) {
          // Initialize Firebase with your config
          firebase.initializeApp(GLOBAL_LOBBY_CONFIG);
          firebaseDatabase = firebase.database();
          
          // Initialize Analytics (optional)
          if (typeof firebase.analytics !== 'undefined') {
            firebase.analytics();
          }
          
          console.log('üî• Firebase initialized successfully with your project: new-chess-game-cc325');
          console.log('üî• Database URL:', GLOBAL_LOBBY_CONFIG.databaseURL);
          return true;
        } else if (typeof firebase !== 'undefined' && firebase.apps.length > 0) {
          // Firebase already initialized, just get the database
          firebaseDatabase = firebase.database();
          console.log('üî• Firebase already initialized, using existing instance');
          return true;
        } else {
          console.warn('üî• Firebase not loaded - falling back to localStorage');
          return false;
        }
      } catch (error) {
        console.error('üî• Firebase initialization error:', error);
        return false;
      }
    }
    
    // Global Lobby Firebase Functions
    async function fetchGlobalGames() {
      try {
        if (!firebaseDatabase) {
          console.log('üî• Firebase not available, using localStorage fallback');
          const storedGames = localStorage.getItem('publicGames');
          const games = storedGames ? JSON.parse(storedGames) : [];
          console.log('üî• Loaded from localStorage fallback:', games);
          return games;
        }
        
        console.log('üî• Fetching global games from Firebase...');
        console.log('üî• Firebase database reference:', firebaseDatabase);
        
        const snapshot = await firebaseDatabase.ref('publicGames').once('value');
        const games = snapshot.val() || [];
        
        console.log('üî• Firebase snapshot:', snapshot);
        console.log('üî• Games from Firebase:', games);
        console.log('üî• Games type:', typeof games);
        console.log('üî• Is array?', Array.isArray(games));
        
        return Array.isArray(games) ? games : [];
      } catch (error) {
        console.error('üî• Error fetching global games from Firebase:', error);
        console.log('üî• Falling back to localStorage');
        // Fallback to localStorage
        const storedGames = localStorage.getItem('publicGames');
        const games = storedGames ? JSON.parse(storedGames) : [];
        console.log('üî• Loaded from localStorage fallback:', games);
        return games;
      }
    }
    
    async function updateGlobalGames(games) {
      try {
        if (!firebaseDatabase) {
          console.log('üî• Firebase not available, using localStorage fallback');
          localStorage.setItem('publicGames', JSON.stringify(games));
          return { success: true };
        }
        
        console.log('üî• Updating global games in Firebase:', games.length, 'games');
        await firebaseDatabase.ref('publicGames').set(games);
        console.log('üî• Global games updated in Firebase successfully');
        return { success: true };
      } catch (error) {
        console.error('üî• Error updating global games in Firebase:', error);
        // Fallback to localStorage
        localStorage.setItem('publicGames', JSON.stringify(games));
        return { success: false, error: error.message };
      }
    }
    
    function startGlobalLobbySync() {
      console.log('üî• Starting global lobby sync with Firebase...');
      
      // Ensure removedGames is initialized
      if (typeof removedGames === 'undefined') {
        console.log('üî• removedGames not initialized in startGlobalLobbySync, initializing now');
        removedGames = new Set();
      }
      
      // Ensure publicGames is initialized
      if (typeof publicGames === 'undefined') {
        console.log('üî• publicGames not initialized in startGlobalLobbySync, initializing now');
        publicGames = [];
      }
      
      // Clear any existing interval
      if (globalLobbyInterval) {
        clearInterval(globalLobbyInterval);
      }
      
      // Initialize Firebase if not already done
      if (!firebaseDatabase) {
        initializeFirebase();
      }
      
      // Set up real-time listener if Firebase is available
      if (firebaseDatabase) {
        console.log('üî• Setting up real-time Firebase listener');
        firebaseDatabase.ref('publicGames').on('value', (snapshot) => {
          const games = snapshot.val() || [];
          console.log('üî• Real-time update received:', games.length, 'games');
          
          // Convert to array if needed
          let gamesArray = Array.isArray(games) ? games : (games ? Object.values(games) : []);
          
          // Ensure publicGames is initialized before filtering
          if (typeof publicGames === 'undefined') {
            console.log('üî• publicGames not initialized in Firebase listener, initializing now');
            publicGames = [];
          }
          
          // Ensure removedGames is initialized before filtering
          if (typeof removedGames === 'undefined') {
            console.log('üî• removedGames not initialized in Firebase listener, initializing now');
            removedGames = new Set();
          }
          
          // Filter out removed games and expired/full games
          publicGames = gamesArray.filter(game => {
            // Skip if this game was manually removed
            if (removedGames.has(game.id)) {
              console.log('üî• Skipping removed game:', game.id);
              return false;
            }
            
            // Remove games that are older than 30 minutes or full
            const gameAge = Date.now() - (game.timestamp || 0);
            const isExpired = gameAge > 30 * 60 * 1000; // 30 minutes
            const isFull = game.players === '2/2';
            
            return !isExpired && !isFull;
          });
          
          console.log('üî• Filtered publicGames:', publicGames.length, 'active games');
          
          // Update localStorage for backup
          localStorage.setItem('publicGames', JSON.stringify(publicGames));
          
          // Render the games
          renderPublicGames();
        });
      } else {
        // Fallback to polling if Firebase is not available
        console.log('üî• Firebase not available, using polling fallback');
        loadGlobalPublicGames();
        globalLobbyInterval = setInterval(() => {
          loadGlobalPublicGames();
        }, GLOBAL_LOBBY_CONFIG.refreshInterval);
      }
    }
    
    function stopGlobalLobbySync() {
      console.log('üî• Stopping global lobby sync');
      if (globalLobbyInterval) {
        clearInterval(globalLobbyInterval);
        globalLobbyInterval = null;
      }
      
      // Remove Firebase listener
      if (firebaseDatabase) {
        firebaseDatabase.ref('publicGames').off();
      }
    }
    
    async function loadGlobalPublicGames() {
      console.log('üî• Loading global public games...');
      
      // Ensure removedGames is initialized
      if (typeof removedGames === 'undefined') {
        console.log('üî• removedGames not initialized in loadGlobalPublicGames, initializing now');
        removedGames = new Set();
      }
      
      // Ensure publicGames is initialized
      if (typeof publicGames === 'undefined') {
        console.log('üî• publicGames not initialized in loadGlobalPublicGames, initializing now');
        publicGames = [];
      }
      
      try {
        const globalGames = await fetchGlobalGames();
        
        // Update local games array with global data
        publicGames = Array.isArray(globalGames) ? globalGames.filter(game => {
          // Remove games that are older than 30 minutes or full
          const gameAge = Date.now() - (game.timestamp || 0);
          const isExpired = gameAge > 30 * 60 * 1000; // 30 minutes
          const isFull = game.players === '2/2';
          
          return !isExpired && !isFull;
        }) : [];
        
        console.log('üî• Loaded', publicGames.length, 'active global games');
        
        // Update localStorage for backup
        localStorage.setItem('publicGames', JSON.stringify(publicGames));
        
        // Render the games
        renderPublicGames();
        
      } catch (error) {
        console.error('üî• Error loading global games:', error);
        // Fallback to localStorage
        loadPublicGames();
      }
    }
    
    async function addGlobalGame(gameData) {
      console.log('üî• Adding game to global lobby:', gameData.name);
      console.log('üî• Game data:', JSON.stringify(gameData, null, 2));
      
      // Ensure removedGames is initialized
      if (typeof removedGames === 'undefined') {
        console.log('üî• removedGames not initialized, initializing now');
        removedGames = new Set();
      }
      
      // Ensure publicGames is initialized
      if (typeof publicGames === 'undefined') {
        console.log('üî• publicGames not initialized, initializing now');
        publicGames = [];
      }
      
      try {
        // Add timestamp
        gameData.timestamp = Date.now();
        
        // Get current global games
        const globalGames = await fetchGlobalGames();
        console.log('üî• Current global games from Firebase:', globalGames);
        console.log('üî• Type of globalGames:', typeof globalGames);
        console.log('üî• Is array?', Array.isArray(globalGames));
        
        // Ensure we have an array to work with - EXTRA SAFETY
        let gamesArray = [];
        
        console.log('üî• Processing globalGames:', globalGames);
        console.log('üî• globalGames is null:', globalGames === null);
        console.log('üî• globalGames is undefined:', globalGames === undefined);
        
        if (globalGames === null || globalGames === undefined) {
          console.log('üî• globalGames is null/undefined, using empty array');
          gamesArray = [];
        } else if (Array.isArray(globalGames)) {
          console.log('üî• globalGames is already an array');
          gamesArray = [...globalGames]; // Create a copy to avoid reference issues
        } else if (globalGames && typeof globalGames === 'object') {
          console.log('üî• globalGames is an object, converting to array');
          gamesArray = Object.values(globalGames);
        } else {
          console.log('üî• globalGames is unexpected type:', typeof globalGames, 'using empty array');
          gamesArray = [];
        }
        
        // FINAL SAFETY CHECK - Ensure gamesArray is actually an array
        if (!Array.isArray(gamesArray)) {
          console.error('üî• CRITICAL: gamesArray is not an array after processing! Type:', typeof gamesArray);
          gamesArray = [];
        }
        
        console.log('üî• FINAL gamesArray:', gamesArray);
        console.log('üî• FINAL gamesArray type:', typeof gamesArray);
        console.log('üî• FINAL gamesArray isArray:', Array.isArray(gamesArray));
        console.log('üî• FINAL gamesArray length:', gamesArray.length);
        console.log('üî• FINAL gamesArray constructor:', gamesArray.constructor.name);
        
        console.log('üî• gamesArray before push:', gamesArray);
        console.log('üî• gamesArray length before push:', gamesArray.length);
        console.log('üî• About to push gameData:', gameData);
        
        // Add new game - WITH EXTRA SAFETY
        try {
          if (!Array.isArray(gamesArray)) {
            throw new Error('gamesArray is not an array before push!');
          }
          gamesArray.push(gameData);
          console.log('‚úÖ Push successful!');
        } catch (pushError) {
          console.error('‚ùå Push failed:', pushError);
          // Fallback: create new array with gameData
          gamesArray = [gameData];
          console.log('‚úÖ Created new array with gameData as fallback');
        }
        
        console.log('üî• Games after adding new game:', gamesArray.length, 'total games');
        console.log('üî• gamesArray after push:', gamesArray);
        
        // Update Firebase with new games array - WITH FALLBACK
        let updateResult;
        try {
          updateResult = await updateGlobalGames(gamesArray);
          console.log('üî• Firebase update result:', updateResult);
        } catch (firebaseError) {
          console.error('üî• Firebase update failed, using localStorage fallback:', firebaseError);
          // Fallback to localStorage
          localStorage.setItem('publicGames', JSON.stringify(gamesArray));
          updateResult = { success: false, error: 'Used localStorage fallback' };
        }
        
        console.log('üî• Final update result:', updateResult);
        
        // Update local publicGames array
        publicGames = gamesArray.filter(game => {
          const gameAge = Date.now() - (game.timestamp || 0);
          const isExpired = gameAge > 30 * 60 * 1000;
          const isFull = game.players === '2/2';
          return !isExpired && !isFull;
        });
        
        console.log('üî• Updated local publicGames:', publicGames.length, 'active games');
        
        // Render the updated games list
        renderPublicGames();
        
        console.log('üî• Game successfully added to global lobby');
        return { isOk: true };
        
      } catch (error) {
        console.error('üî• Error adding game to global lobby:', error);
        console.error('üî• Error stack:', error.stack);
        console.error('üî• Error details:', {
          message: error.message,
          name: error.name,
          toString: error.toString()
        });
        return { isOk: false, error: error.message };
      }
    }
    
    async function removeGlobalGame(gameId) {
      console.log('üî• Removing game from global lobby:', gameId);
      
      // Ensure removedGames is initialized
      if (typeof removedGames === 'undefined') {
        console.log('üî• removedGames not initialized, initializing now');
        removedGames = new Set();
      }
      
      // Ensure publicGames is initialized
      if (typeof publicGames === 'undefined') {
        console.log('üî• publicGames not initialized, initializing now');
        publicGames = [];
      }
      
      try {
        // Add to removed set to prevent re-adding via sync
        removedGames.add(gameId);
        console.log('üî• Added game to removed set:', gameId);
        
        // Get current global games
        const globalGames = await fetchGlobalGames();
        console.log('üî• Current global games for removal:', globalGames);
        
        // Ensure we have an array to work with
        let gamesArray = [];
        if (Array.isArray(globalGames)) {
          gamesArray = globalGames;
        } else if (globalGames && typeof globalGames === 'object') {
          // Convert object to array if needed
          gamesArray = Object.values(globalGames);
        } else {
          console.log('üî• No existing games to remove from');
          gamesArray = [];
        }
        
        // Remove the game
        const originalLength = gamesArray.length;
        const updatedGames = gamesArray.filter(game => game.id !== gameId);
        console.log('üî• Games before removal:', originalLength, 'after removal:', updatedGames.length);
        
        // Update global storage
        await updateGlobalGames(updatedGames);
        
        // Update local array
        publicGames = updatedGames.filter(game => {
          const gameAge = Date.now() - (game.timestamp || 0);
          const isExpired = gameAge > 30 * 60 * 1000;
          const isFull = game.players === '2/2';
          return !isExpired && !isFull;
        });
        
        // Render the updated games list
        renderPublicGames();
        
        console.log('üî• Game removed from global lobby successfully');
        return { isOk: true };
        
      } catch (error) {
        console.error('üî• Error removing game from global lobby:', error);
        // Fallback to localStorage
        savePublicGamesToStorage();
        return { isOk: false, error: error.message };
      }
    }
    
    function loadPublicGames() {
      console.log('üåç Loading public games...');
      
      // Ensure publicGames is initialized
      if (typeof publicGames === 'undefined') {
        console.log('üåç publicGames not initialized in loadPublicGames, initializing now');
        publicGames = [];
      }
      
      console.log('üåç Current publicGames array before load:', publicGames);
      
      // Load games from localStorage for cross-tab visibility
      try {
        const storedGames = localStorage.getItem('publicGames');
        if (storedGames) {
          publicGames = JSON.parse(storedGames);
          console.log('üåç Loaded', publicGames.length, 'games from localStorage');
        } else {
          publicGames = [];
          console.log('üåç No games in localStorage, starting fresh');
        }
      } catch (error) {
        console.error('üåç Error loading games from localStorage:', error);
        publicGames = [];
      }
      
      renderPublicGames();
    }
    
    function savePublicGamesToStorage() {
      // Ensure publicGames is initialized
      if (typeof publicGames === 'undefined') {
        console.log('üåç publicGames not initialized in savePublicGamesToStorage, initializing now');
        publicGames = [];
      }
      
      try {
        localStorage.setItem('publicGames', JSON.stringify(publicGames));
        console.log('üåç Saved', publicGames.length, 'games to localStorage');
      } catch (error) {
        console.error('üåç Error saving games to localStorage:', error);
      }
    }
    
    // Listen for storage events to update games list in real-time across tabs
    window.addEventListener('storage', (e) => {
      if (e.key === 'publicGames') {
        console.log('üåç Storage event detected, refreshing games list...');
        loadPublicGames();
      }
    });
    
    // Declare publicGames array - this was missing!
    let publicGames = [];
    
    function renderPublicGames() {
      // Ensure publicGames is initialized
      if (typeof publicGames === 'undefined') {
        console.log('üéÆ publicGames not initialized in renderPublicGames, initializing now');
        publicGames = [];
      }
      
      const gamesList = document.getElementById('public-games-list');
      console.log('üéÆ renderPublicGames called with', publicGames.length, 'games');
      console.log('üéÆ Games array:', publicGames);
      
      if (publicGames.length === 0) {
        gamesList.innerHTML = `
          <div style="text-align: center; color: rgba(255,255,255,0.7); padding: 20px;">
            <div style="font-size: 24px; margin-bottom: 8px;">üåç</div>
            <div>No global games available</div>
            <div style="font-size: 12px; margin-top: 8px;">Be the first to create a game!</div>
          </div>
        `;
        console.log('üéÆ No games to display, showing empty message');
        return;
      }
      
      gamesList.innerHTML = '';
      console.log('üéÆ Rendering', publicGames.length, 'games to the list');
      
      publicGames.forEach((game, index) => {
        console.log(`üéÆ Rendering game ${index + 1}:`, game);
        const gameDiv = document.createElement('div');
        
        const gameAge = Date.now() - (game.timestamp || 0);
        const ageMinutes = Math.floor(gameAge / 60000);
        const ageText = ageMinutes < 1 ? 'Just now' : `${ageMinutes}m ago`;
        
        const isFull = game.players === '2/2';
        const isOld = gameAge > 20 * 60 * 1000; // 20 minutes
        
        gameDiv.style.cssText = `
          background: rgba(255,255,255,0.1);
          padding: 16px;
          border-radius: 12px;
          margin-bottom: 12px;
          cursor: ${isFull ? 'not-allowed' : 'pointer'};
          transition: all 0.2s;
          border: 2px solid transparent;
          opacity: ${isFull ? '0.5' : '1'};
        `;
        
        if (isOld) {
          gameDiv.style.borderColor = 'rgba(239, 68, 68, 0.5)';
        }
        
        const joinButtonDisabled = isFull ? 'disabled' : '';
        const joinButtonStyle = isFull ? 
          'padding: 8px 16px; border-radius: 8px; border: none; background: #6b7280; color: white; font-weight: bold; cursor: not-allowed; font-size: 12px;' :
          'padding: 8px 16px; border-radius: 8px; border: none; background: #10b981; color: white; font-weight: bold; cursor: pointer; font-size: 12px;';
        const joinButtonText = isFull ? 'Full' : 'Join';
        
        gameDiv.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
            <div style="flex: 1;">
              <div style="color: white; font-weight: bold; font-size: 16px; margin-bottom: 4px;">
                ${game.name} ${isFull ? 'üîí' : 'üéÆ'}
              </div>
              <div style="color: rgba(255,255,255,0.8); font-size: 14px; margin-bottom: 4px;">
                Host: ${game.host} ${game.guest ? `vs ${game.guest}` : ''}
              </div>
              <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
                <span style="color: rgba(255,255,255,0.7); font-size: 12px;">
                  ${game.powerups === true ? '‚ö° Power-ups' : '‚ôüÔ∏è Classic'}
                </span>
                <span style="color: rgba(255,255,255,0.7); font-size: 12px;">
                  üë• ${game.players}
                </span>
                <span style="color: rgba(255,255,255,0.7); font-size: 12px;">
                  üïê ${ageText}
                </span>
                ${isOld ? '<span style="color: #ef4444; font-size: 12px;">‚ö†Ô∏è Old</span>' : ''}
              </div>
            </div>
            <div style="text-align: right;">
              <button onclick="${!isFull ? `joinPublicGame('${game.id}')` : ''}" ${joinButtonDisabled} style="${joinButtonStyle}"
                onmouseover="this.style.background='${isFull ? '#6b7280' : '#059669'}'"
                onmouseout="this.style.background='${isFull ? '#6b7280' : '#10b981'}'"
              >${joinButtonText}</button>
            </div>
          </div>
        `;
        
        gameDiv.onmouseover = () => {
          if (!isFull) {
            gameDiv.style.background = 'rgba(255,255,255,0.2)';
            gameDiv.style.borderColor = '#10b981';
          }
        };
        
        gameDiv.onmouseout = () => {
          if (!isFull) {
            gameDiv.style.background = 'rgba(255,255,255,0.1)';
            gameDiv.style.borderColor = 'transparent';
          }
        };
        
        gamesList.appendChild(gameDiv);
      });
    }
    
    // Create public game (using working regular room code)
    document.getElementById('create-public-game-btn').addEventListener('click', async () => {
      const playerName = document.getElementById('public-player-name').value.trim();
      const gameName = document.getElementById('public-game-name').value.trim();
      
      if (!playerName) {
        alert('Please enter your name!');
        return;
      }
      
      if (!gameName) {
        alert('Please enter a game name!');
        return;
      }
      
      try {
        // Initialize storage if not already done
        if ((ONLINE_STORAGE_CONFIG.provider === 'jsonbin' && !ONLINE_STORAGE_CONFIG.jsonbinApiKey) ||
            (ONLINE_STORAGE_CONFIG.provider === 'googlesheets' && (!ONLINE_STORAGE_CONFIG.googlesheets.spreadsheetId || !ONLINE_STORAGE_CONFIG.googlesheets.apiKey)) ||
            (ONLINE_STORAGE_CONFIG.provider === 'firebase' && (!ONLINE_STORAGE_CONFIG.firebase.apiKey || !ONLINE_STORAGE_CONFIG.firebase.databaseURL))) {
          throw new Error('Online storage not configured. Please configure storage in the Admin panel.');
        }
        
        document.getElementById('create-public-game-btn').disabled = true;
        document.getElementById('create-public-game-btn').textContent = 'Creating...';
        
        // Ensure Firebase is initialized if using Firebase
        if (ONLINE_STORAGE_CONFIG.provider === 'firebase') {
          console.log('Initializing Firebase for public game creation...');
          try {
            const initialized = await initOnlineStorage();
            console.log('Firebase initialized:', initialized);
            if (!initialized) {
              throw new Error('Failed to initialize Firebase');
            }
          } catch (initError) {
            console.error('Firebase initialization error:', initError);
            throw new Error('Firebase initialization failed: ' + initError.message);
          }
        }
        
        // Generate a unique room code (but don't show it to user)
        const roomCode = 'game_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        
        // Check if power-ups are disabled (check the button state properly)
        const powerupsOffBtn = document.getElementById('create-powerups-off-btn');
        const powerupsOnBtn = document.getElementById('create-powerups-on-btn');
        const disablePowerups = powerupsOffBtn && powerupsOffBtn.style.background === 'rgb(16, 185, 129)';
        
        console.log('Power-ups disabled:', disablePowerups);
        console.log('Power-ups off button style:', powerupsOffBtn ? powerupsOffBtn.style.background : 'not found');
        
        const roomData = {
          room_code: roomCode,
          host_player: playerName,
          guest_player: '',
          current_player: 'white',
          game_over: false,
          white_in_check: false,
          black_in_check: false,
          last_update: Date.now(),
          host_coins: 0,
          guest_coins: 0,
          host_powerups: JSON.stringify(gameState.whitePowerUps),
          guest_powerups: JSON.stringify(gameState.blackPowerUps),
          disable_powerups: disablePowerups,
          game_state_data: serializeGameState(),
          game_mode: 'public',
          game_name: gameName
        };
        
        console.log('Creating room with data:', roomData);
        const result = await onlineStorageHandler.create(roomData);
        console.log('Room creation result:', result);
        
        if (result.isOk) {
          // Add to global lobby
          const newGame = {
            id: roomCode,
            name: gameName,
            host: playerName,
            powerups: !roomData.disable_powerups,
            players: '1/2',
            timestamp: Date.now()
          };
          addGlobalGame(newGame);
          
          gameState.mode = 'online';
          gameState.playerRole = 'host';
          gameState.playerName = playerName;
          gameState.playerColor = 'white'; // Host is always white
          gameState.roomCode = roomCode;
          gameState.game_mode = 'public';
          
          // Initialize timer values to prevent NaN
          gameState.whiteTime = 600; // 10 minutes
          gameState.blackTime = 600;
          gameState.timerEnabled = true;
          gameState.timerRunning = false;
          
          // Close public lobby modal and show game
          document.getElementById('public-lobby-modal').style.display = 'none';
          document.getElementById('mode-selection').style.display = 'none';
          document.getElementById('online-options').style.display = 'none';
          document.getElementById('game-area').style.display = 'block';
          
          // Hide power-ups section if disabled
          const disablePowerups = roomData.disable_powerups;
          gameState.disablePowerups = disablePowerups; // Set the game state flag
          if (disablePowerups) {
            const powerupsSection = document.getElementById('powerups-section');
            if (powerupsSection) {
              powerupsSection.style.display = 'none';
            }
            const toggleBtn = document.getElementById('toggle-powerups-btn');
            if (toggleBtn) {
              toggleBtn.style.display = 'none';
            }
          }
          
          // Show End Game button for online games
          document.getElementById('end-game-btn').style.display = 'block';
          
          // Play room created sound
          playRoomCreatedSound();
          
          // Enable timer and chat
          enableOnlineFeatures();
          
          // Start syncing for this room (using working Firebase listener)
          startDataSync();
          
          // Show multiplayer status
          document.getElementById('multiplayer-status').style.display = 'block';
          document.getElementById('room-code-display').textContent = `Public Game: ${gameName}`;
          document.getElementById('player-role').textContent = 'Host (White)';
          document.getElementById('opponent-status').textContent = 'Waiting for player...';
          
          resetGame();
        } else {
          document.getElementById('create-public-game-btn').disabled = false;
          document.getElementById('create-public-game-btn').textContent = 'Create Game';
          alert('Failed to create game: ' + (result.error || 'Unknown error'));
        }
      } catch (error) {
        console.error('Error creating public game:', error);
        document.getElementById('create-public-game-btn').disabled = false;
        document.getElementById('create-public-game-btn').textContent = 'Create Game';
        alert('Error creating game: ' + (error.message || 'Unknown error'));
      }
    });
    
    function joinPublicGame(gameId) {
      const playerName = document.getElementById('join-player-name').value.trim();
      const game = publicGames.find(g => g.id === gameId);
      
      if (!playerName) {
        alert('Please enter your name!');
        return;
      }
      
      if (!game) {
        alert('Game not found! It may have been closed or filled.');
        return;
      }
      
      // Check if game is full
      if (game.players === '2/2') {
        alert('This game is already full! Please choose another game.');
        return;
      }
      
      try {
        // Initialize storage if not already done
        if ((ONLINE_STORAGE_CONFIG.provider === 'jsonbin' && !ONLINE_STORAGE_CONFIG.jsonbinApiKey) ||
            (ONLINE_STORAGE_CONFIG.provider === 'googlesheets' && (!ONLINE_STORAGE_CONFIG.googlesheets.spreadsheetId || !ONLINE_STORAGE_CONFIG.googlesheets.apiKey)) ||
            (ONLINE_STORAGE_CONFIG.provider === 'firebase' && (!ONLINE_STORAGE_CONFIG.firebase.apiKey || !ONLINE_STORAGE_CONFIG.firebase.databaseURL))) {
          throw new Error('Online storage not configured. Please configure storage in the Admin panel.');
        }
        
        // Update game players in global lobby
        game.players = '2/2';
        game.guest = playerName;
        
        // Update global lobby
        removeGlobalGame(gameId); // Remove from available games since it's full
        
        // Refresh the games list to show updated player count
        renderPublicGames();
        
        // Join the game using the room code
        joinRoom(gameId, playerName);
        
        // Close the public lobby modal
        document.getElementById('public-lobby-modal').style.display = 'none';
        
      } catch (error) {
        console.error('Error joining public game:', error);
        alert('Error joining game: ' + error.message);
      }
    }
    
    function makeAIMoveOnBoard() {
      console.log('üö® AI MOVE FUNCTION CALLED! üö®');
      console.log('AI move triggered - current player:', gameState.currentPlayer, 'game over:', gameState.gameOver);
      console.log('AI power-up awareness - checking active power-ups...');
      console.log('White power-ups:', gameState.whitePowerUps);
      console.log('Black power-ups:', gameState.blackPowerUps);
      console.log('Active effects:', {
        freezeActive: gameState.freezeActive,
        lightningMode: gameState.lightningMode,
        magnetMode: gameState.magnetMode,
        poisonMode: gameState.poisonMode,
        cloneMode: gameState.cloneMode,
        invisibilityActive: gameState.whiteInvisibilityActive || gameState.blackInvisibilityActive
      });
      
      if (gameState.gameOver || gameState.currentPlayer !== 'black') {
        console.log('AI move blocked - not AI turn or game over');
        return;
      }

      // Check if AI is frozen - don't move if frozen
      if (gameState.freezeActive) {
        console.log('AI move blocked - AI is frozen');
        return;
      }

      // Use Double Coins if AI has few coins
      if (gameState.blackPowerUps.double_coins > 0 && gameState.blackCoins < 10) {
        console.log('AI decided to use Double Coins!');
        useDoubleCoins();
        return;
      }

      // Use Freeze if AI is in a bad position
      if (gameState.blackPowerUps.freeze > 0 && isKingInCheck('black') && !gameState.freezeActive) {
        console.log('AI decided to use Freeze!');
        useFreeze();
        return;
      }

      // Use Hint if AI is struggling
      if (gameState.blackPowerUps.hint > 0 && Math.random() > 0.7) {
        console.log('AI decided to use Hint!');
        useHint();
        // Continue with regular move after getting hint
      }
      
      setTimeout(() => {
        console.log('AI thinking...');
        
        // First, check if AI is in checkmate or stalemate BEFORE trying to move
        const isInCheck = isKingInCheck('black');
        console.log('AI is in check:', isInCheck);
        
        // Check if AI has any valid moves at all
        const allMoves = getAllValidMoves(gameState.board, 'black');
        console.log('AI has', allMoves.length, 'valid moves');
        
        if (allMoves.length === 0) {
          console.log('AI has no valid moves - checking checkmate/stalemate');
          if (isInCheck) {
            console.log('AI is in checkmate - White wins!');
            gameState.gameOver = true;
            playGameOverSound();
            alert('Checkmate! White wins!');
            return;
          } else {
            console.log('AI is in stalemate - Draw!');
            gameState.gameOver = true;
            playGameOverSound();
            alert('Stalemate! Draw!');
            return;
          }
        }
        
        // If AI is in check, try to find an escape move first
        if (isInCheck) {
          console.log('AI is in check - looking for escape moves...');
          let escapeMove = null;
          
          // Get all valid moves that would get AI out of check
          const validMoves = getAllValidMoves(gameState.board, 'black');
          console.log('AI has', validMoves.length, 'valid escape moves to check');
          
          if (validMoves.length > 0) {
            // Use the first valid escape move
            escapeMove = validMoves[0];
            console.log('Found escape move:', escapeMove);
          }
          
          if (escapeMove) {
            console.log('AI using escape move to get out of check - Game over should be false:', gameState.gameOver);
            // Make sure gameOver is false before executing escape move
            gameState.gameOver = false;
            const piece = gameState.board[escapeMove.fromRow][escapeMove.fromCol];
            const captured = gameState.board[escapeMove.toRow][escapeMove.toCol];
            const fromSquare = document.querySelector(`[data-row="${escapeMove.fromRow}"][data-col="${escapeMove.fromCol}"]`);
            const toSquare = document.querySelector(`[data-row="${escapeMove.toRow}"][data-col="${escapeMove.toCol}"]`);
            
            if (fromSquare && toSquare) {
              executeMove(escapeMove.fromRow, escapeMove.fromCol, escapeMove.toRow, escapeMove.toCol, piece, captured, fromSquare, toSquare);
            } else {
              console.error('AI escape move failed - could not find squares');
            }
            return;
          } else {
            console.log('AI cannot escape check - checkmate! White wins!');
            gameState.gameOver = true;
            playGameOverSound();
            alert('Checkmate! White wins!');
            return;
          }
        }
        
        // If not in check or can escape, make normal move
        const bestMove = getBestMove();
        console.log('Best move found:', bestMove);

        if (bestMove) {
          const { fromRow, fromCol, toRow, toCol } = bestMove;
          const piece = gameState.board[fromRow][fromCol];
          const captured = gameState.board[toRow][toCol];

          console.log('AI moving from', fromRow, fromCol, 'to', toRow, toCol, 'piece:', piece, 'captured:', captured);

          const fromSquare = document.querySelector(`[data-row="${fromRow}"][data-col="${fromCol}"]`);
          const toSquare = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"]`);

          if (fromSquare && toSquare) {
            executeMove(fromRow, fromCol, toRow, toCol, piece, captured, fromSquare, toSquare);
          } else {
            console.error('AI move failed - could not find squares');
          }
        } else {
          console.log('AI could not find a move but should have had moves - this should not happen');
          // As a fallback, end the game
          gameState.gameOver = true;
          playGameOverSound();
          alert('Game ended - AI could not make a move');
        }
      }, 1000);
    }
    
    // Helper function for AI to count white pieces
    function countWhitePieces() {
      let count = 0;
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          if (isWhitePiece(gameState.board[row][col])) {
            count++;
          }
        }
      }
      return count;
    }
    
    // Power-up functions
    function useLightning() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.lightning > 0 && !gameState.gameOver && !gameState.lightningMode) {
        playLightningSound();
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.lightning--;
        } else {
          gameState.blackPowerUps.lightning--;
        }
        
        // Enter lightning targeting mode
        gameState.lightningMode = true;
        renderBoard();
        updatePowerUpButtons();
        
        // Check for combos
        checkCombo("Lightning Strike ‚ö°");
        
        // Send notification to other player
        sendPowerUpNotification("Lightning Strike ‚ö° - Targeting mode activated!");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function useUndo() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.undo > 0 && gameState.moveHistory.length > 0 && !gameState.gameOver) {
        playPowerUpSound();
        const lastMove = gameState.moveHistory.pop();
        
        gameState.board[lastMove.from.row][lastMove.from.col] = lastMove.from.piece;
        gameState.board[lastMove.to.row][lastMove.to.col] = lastMove.to.captured || '';
        
        if (lastMove.to.captured) {
          if (isWhitePiece(lastMove.to.captured)) {
            gameState.blackCaptured.pop();
          } else {
            gameState.whiteCaptured.pop();
          }
        }
        
        gameState.currentPlayer = gameState.currentPlayer === 'white' ? 'black' : 'white';
        gameState.whiteInCheck = lastMove.whiteInCheck;
        gameState.blackInCheck = lastMove.blackInCheck;
        
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.undo--;
        } else {
          gameState.blackPowerUps.undo--;
        }
        renderBoard();
        updatePowerUpButtons();
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function useHint() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.hint > 0 && !gameState.gameOver) {
        playPowerUpSound();
        // Find a good move and highlight it
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            const piece = gameState.board[row][col];
            if (piece && 
                ((gameState.currentPlayer === 'white' && isWhitePiece(piece)) ||
                 (gameState.currentPlayer === 'black' && isBlackPiece(piece)))) {
              for (let toRow = 0; toRow < 8; toRow++) {
                for (let toCol = 0; toCol < 8; toCol++) {
                  if (canMovePiece(row, col, toRow, toCol)) {
                    const square = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"]`);
                    square.classList.add('hint-pulse');
                    setTimeout(() => square.classList.remove('hint-pulse'), 2000);
                    
                    if (gameState.currentPlayer === 'white') {
                      gameState.whitePowerUps.hint--;
                    } else {
                      gameState.blackPowerUps.hint--;
                    }
                    updatePowerUpButtons();
                    
                    // Save progress locally
                    savePlayerProgress();
                    return;
                  }
                }
              }
            }
          }
        }
      }
    }
    
    // Combo System - Special effects when power-ups are combined
    let comboTracker = {
      lastPowerUp: null,
      lastPowerUpTime: 0,
      comboCount: 0,
      activeCombo: null
    };
    
    function checkCombo(powerUpName) {
      const now = Date.now();
      const timeSinceLastPowerUp = now - comboTracker.lastPowerUpTime;
      
      // Reset combo if too much time passed
      if (timeSinceLastPowerUp > 5000) { // 5 seconds window
        comboTracker.comboCount = 0;
        comboTracker.activeCombo = null;
      }
      
      // Check for specific combos
      let comboActivated = false;
      
      // Shield + Bomb = Bomb Shield
      if ((comboTracker.lastPowerUp === 'Shield üõ°Ô∏è' && powerUpName === 'Bomb üí£') ||
          (comboTracker.lastPowerUp === 'Bomb üí£' && powerUpName === 'Shield üõ°Ô∏è')) {
        activateCombo('Bomb Shield', 'üõ°Ô∏èüí£', 'Bomb explodes but you\'re protected!');
        comboActivated = true;
      }
      
      // Lightning + Freeze = Electric Freeze
      if ((comboTracker.lastPowerUp === 'Lightning Strike ‚ö°' && powerUpName === 'Freeze ‚ùÑÔ∏è') ||
          (comboTracker.lastPowerUp === 'Freeze ‚ùÑÔ∏è' && powerUpName === 'Lightning Strike ‚ö°')) {
        activateCombo('Electric Freeze', '‚ö°‚ùÑÔ∏è', 'Lightning strikes frozen enemies for double damage!');
        comboActivated = true;
      }
      
      // Laser + Tornado = Laser Tornado
      if ((comboTracker.lastPowerUp === 'Laser Beam üî¥' && powerUpName === 'Tornado üå™Ô∏è') ||
          (comboTracker.lastPowerUp === 'Tornado üå™Ô∏è' && powerUpName === 'Laser Beam üî¥')) {
        activateCombo('Laser Tornado', 'üî¥üå™Ô∏è', 'Spinning laser beam destroys everything in path!');
        comboActivated = true;
      }
      
      // Mega Bomb + Lightning = Nuclear Strike
      if ((comboTracker.lastPowerUp === 'Mega Bomb üí•' && powerUpName === 'Lightning Strike ‚ö°') ||
          (comboTracker.lastPowerUp === 'Lightning Strike ‚ö°' && powerUpName === 'Mega Bomb üí•')) {
        activateCombo('Nuclear Strike', 'üí•‚ö°', 'Massive explosion with electrical storm!');
        comboActivated = true;
      }
      
      // Shield Wall + Royal Guard = Fortress
      if ((comboTracker.lastPowerUp === 'Shield Wall üè∞' && powerUpName === 'Royal Guard ‚öîÔ∏è') ||
          (comboTracker.lastPowerUp === 'Royal Guard ‚öîÔ∏è' && powerUpName === 'Shield Wall üè∞')) {
        activateCombo('Fortress', 'üè∞‚öîÔ∏è', 'Impenetrable fortress defense for 3 turns!');
        comboActivated = true;
      }
      
      // Freeze + Time Warp = Time Freeze
      if ((comboTracker.lastPowerUp === 'Freeze ‚ùÑÔ∏è' && powerUpName === 'Time Warp ‚è±Ô∏è') ||
          (comboTracker.lastPowerUp === 'Time Warp ‚è±Ô∏è' && powerUpName === 'Freeze ‚ùÑÔ∏è')) {
        activateCombo('Time Freeze', '‚è∞‚ùÑÔ∏è', 'Freezes opponent for 2 extra turns!');
        comboActivated = true;
      }
      
      // Shield + Bomb = Bomb Shield
      if ((comboTracker.lastPowerUp === 'Shield üõ°Ô∏è' && powerUpName === 'Bomb üí£') ||
          (comboTracker.lastPowerUp === 'Bomb üí£' && powerUpName === 'Shield üõ°Ô∏è')) {
        activateCombo('Bomb Shield', 'üõ°Ô∏èüí£', 'Bomb protects your pieces for 1 turn!');
        comboActivated = true;
      }
      
      // Knight Boost + Vision = Ghost Knight
      if ((comboTracker.lastPowerUp === 'Knight Boost üê¥' && powerUpName === 'Vision üëÅÔ∏è') ||
          (comboTracker.lastPowerUp === 'Vision üëÅÔ∏è' && powerUpName === 'Knight Boost üê¥')) {
        activateCombo('Ghost Knight', 'üëªüê¥', 'Knights can move through pieces for 3 turns!');
        comboActivated = true;
      }
      
      // Double Coins + Swap = Coin Swap
      if ((comboTracker.lastPowerUp === 'Double Coins üí∞' && powerUpName === 'Swap üîÑ') ||
          (comboTracker.lastPowerUp === 'Swap üîÑ' && powerUpName === 'Double Coins üí∞')) {
        activateCombo('Coin Swap', 'üí∞üîÑ', 'Swap pieces and gain 20 coins!');
        comboActivated = true;
      }
      
      // Triple Power-Up Combo - only for specific combinations
      // Removed the generic "Power Surge" combo that was triggering on every 3rd power-up
      
      // Update tracker
      comboTracker.lastPowerUp = powerUpName;
      comboTracker.lastPowerUpTime = now;
      if (comboActivated) {
        comboTracker.comboCount = 0;
      } else {
        comboTracker.comboCount++;
      }
    }
    
    function activateCombo(comboName, comboIcon, comboDescription) {
      comboTracker.activeCombo = {
        name: comboName,
        icon: comboIcon,
        description: comboDescription,
        startTime: Date.now()
      };
      
      // Show combo notification
      showComboNotification(comboName, comboIcon, comboDescription);
      
      // Apply combo effects
      applyComboEffect(comboName);
      
      // Send combo notification to other player in online games
      if (gameState.mode === 'online') {
        sendComboNotification(comboName, comboIcon);
      }
    }
    
    function showComboNotification(comboName, comboIcon, comboDescription) {
      // Create combo notification element
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px 30px;
        border-radius: 15px;
        font-size: 24px;
        font-weight: bold;
        z-index: 3000;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        animation: comboPopup 2s ease-in-out;
        text-align: center;
      `;
      notification.innerHTML = `
        <div style="font-size: 36px; margin-bottom: 10px;">${comboIcon}</div>
        <div style="margin-bottom: 5px;">${comboName} COMBO!</div>
        <div style="font-size: 14px; opacity: 0.9;">${comboDescription}</div>
      `;
      
      // Add animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes comboPopup {
          0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
          50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
          100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }
      `;
      document.head.appendChild(style);
      
      document.body.appendChild(notification);
      
      // Remove notification after animation
      setTimeout(() => {
        notification.remove();
        style.remove();
      }, 2000);
      
      // Play combo sound
      playComboSound();
    }
    
    function applyComboEffect(comboName) {
      switch(comboName) {
        case 'Time Freeze':
          gameState.freezeActive = true;
          gameState.freezeTurnsLeft = 2; // Extra 2 turns
          break;
          
        case 'Bomb Shield':
          gameState.bombShieldActive = true;
          gameState.bombShieldTurnsLeft = 1;
          break;
          
        case 'Electric Freeze':
          gameState.freezeActive = true;
          gameState.freezeTurnsLeft = 3; // Extra turns
          // Add extra damage effect
          gameState.electricFreezeActive = true;
          gameState.electricFreezeTurnsLeft = 2;
          break;
          
        case 'Laser Tornado':
          gameState.laserTornadoActive = true;
          gameState.laserTornadoTurnsLeft = 1;
          break;
          
        case 'Nuclear Strike':
          // Massive explosion effect
          createConfetti(document.body);
          // Destroy all opponent pieces except king
          for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
              const piece = gameState.board[row][col];
              if (piece && 
                  ((gameState.currentPlayer === 'white' && isBlackPiece(piece) && piece !== '‚ôö') ||
                   (gameState.currentPlayer === 'black' && isWhitePiece(piece) && piece !== '‚ôî'))) {
                gameState.board[row][col] = '';
                const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (square) createExplosionEffect(square);
              }
            }
          }
          renderBoard();
          break;
          
        case 'Fortress':
          gameState.fortressActive = true;
          gameState.fortressTurnsLeft = 3;
          // Activate both shield wall and royal guard
          if (gameState.currentPlayer === 'white') {
            gameState.whiteShieldWallActive = true;
            gameState.whiteShieldWallTurnsLeft = 3;
            gameState.whiteRoyalGuardActive = true;
            gameState.whiteRoyalGuardTurnsLeft = 3;
          } else {
            gameState.blackShieldWallActive = true;
            gameState.blackShieldWallTurnsLeft = 3;
            gameState.blackRoyalGuardActive = true;
            gameState.blackRoyalGuardTurnsLeft = 3;
          }
          break;
          
        case 'Ghost Knight':
          gameState.ghostKnightActive = true;
          gameState.ghostKnightTurnsLeft = 3;
          break;
          
        case 'Coin Swap':
          // Add bonus coins
          if (gameState.currentPlayer === 'white') {
            gameState.whiteCoins += 20;
          } else {
            gameState.blackCoins += 20;
          }
          document.getElementById('coin-count').textContent = getCurrentCoins();
          break;
          
        case 'Power Surge':
          gameState.powerSurgeActive = true;
          gameState.powerSurgeTurnsLeft = 2;
          break;
      }
    }
    
    function sendComboNotification(comboName, comboIcon) {
      if (gameState.mode === 'online' && gameState.roomCode) {
        const currentPlayerName = gameState.currentPlayer === 'white' ? 
          (gameState.playerColor === 'white' ? gameState.playerName : gameState.opponentName) :
          (gameState.playerColor === 'black' ? gameState.playerName : gameState.opponentName);
        
        const message = `üî• ${currentPlayerName} activated ${comboIcon} ${comboName} COMBO!`;
        
        // Add to chat messages as system notification
        if (!gameState.chatMessages) {
          gameState.chatMessages = [];
        }
        gameState.chatMessages.push({
          sender: 'System',
          message: message,
          timestamp: Date.now(),
          isSystem: true
        });
        
        // Update server with new chat message
        updateGameStateOnServer();
        
        // Render chat to show the notification
        renderChatMessages();
      }
    }
    
    function playComboSound() {
      // Create a special combo sound using existing sounds
      playPowerUpSound();
      setTimeout(() => playCoinsSound(), 100);
      setTimeout(() => playPowerUpSound(), 200);
    }
    
    function canKnightMove(absRowDiff, absColDiff) {
      return (absRowDiff === 2 && absColDiff === 1) || (absRowDiff === 1 && absColDiff === 2);
    }
    
    function canBishopMove(absRowDiff, absColDiff, fromRow, fromCol, toRow, toCol) {
      if (absRowDiff !== absColDiff) return false;
      return isPathClear(fromRow, fromCol, toRow, toCol);
    }
    
    function canRookMove(absRowDiff, absColDiff, fromRow, fromCol, toRow, toCol) {
      if (absRowDiff !== 0 && absColDiff !== 0) return false;
      return isPathClear(fromRow, fromCol, toRow, toCol);
    }
    
    function canQueenMove(absRowDiff, absColDiff, fromRow, fromCol, toRow, toCol) {
      return canBishopMove(absRowDiff, absColDiff, fromRow, fromCol, toRow, toCol) ||
             canRookMove(absRowDiff, absColDiff, fromRow, fromCol, toRow, toCol);
    }
    
    function canKingMove(piece, fromRow, fromCol, toRow, toCol, targetPiece) {
      const rowDiff = Math.abs(toRow - fromRow);
      const colDiff = Math.abs(toCol - fromCol);
      
      // Normal king move
      if (rowDiff <= 1 && colDiff <= 1) {
        return true;
      }
      
      // Castling
      if (rowDiff === 0 && colDiff === 2 && !targetPiece) {
        return canCastle(piece, fromRow, fromCol, toRow, toCol);
      }
      
      return false;
    }
    
    function canCastle(piece, fromRow, fromCol, toRow, toCol) {
      const isWhite = isWhitePiece(piece);
      const kingStartCol = 4;
      const rookStartCol = toCol > fromCol ? 7 : 0;
      
      // Check if king and rook are in starting positions
      if (fromCol !== kingStartCol) return false;
      if (gameState.board[fromRow][rookStartCol] !== (isWhite ? '‚ôñ' : '‚ôú')) return false;
      
      // Check if king or rook have moved
      if (hasKingMoved(isWhite) || hasRookMoved(isWhite, rookStartCol)) return false;
      
      // Check if king is in check
      if ((isWhite && gameState.whiteInCheck) || (!isWhite && gameState.blackInCheck)) return false;
      
      // Check if path is clear
      const direction = rookStartCol > kingStartCol ? 1 : -1;
      for (let col = kingStartCol + direction; col !== rookStartCol; col += direction) {
        if (gameState.board[fromRow][col]) return false;
      }
      
      // Check if king passes through or ends in check
      for (let col = kingStartCol; col !== toCol + direction; col += direction) {
        if (isSquareUnderAttack(fromRow, col, !isWhite)) return false;
      }
      
      return true;
    }
    
    function hasKingMoved(isWhite) {
      const kingPiece = isWhite ? '‚ôî' : '‚ôö';
      const startRow = isWhite ? 7 : 0;
      const startCol = 4;
      
      // Check if king is still in starting position
      return gameState.board[startRow][startCol] !== kingPiece;
    }
    
    function hasRookMoved(isWhite, rookCol) {
      const rookPiece = isWhite ? '‚ôñ' : '‚ôú';
      const startRow = isWhite ? 7 : 0;
      
      // Check if rook is still in starting position
      return gameState.board[startRow][rookCol] !== rookPiece;
    }
    
    function executeCastle(fromRow, fromCol, toRow, toCol) {
      const isWhite = isWhitePiece(gameState.board[fromRow][fromCol]);
      const rookStartCol = toCol > fromCol ? 7 : 0;
      const rookEndCol = toCol > fromCol ? toCol - 1 : toCol + 1;
      
      // Move king
      gameState.board[toRow][toCol] = gameState.board[fromRow][fromCol];
      gameState.board[fromRow][fromCol] = '';
      
      // Move rook
      gameState.board[fromRow][rookEndCol] = gameState.board[fromRow][rookStartCol];
      gameState.board[fromRow][rookStartCol] = '';
      
      // Add to move history
      gameState.moveHistory.push({
        from: { row: fromRow, col: fromCol, piece: gameState.board[toRow][toCol] },
        to: { row: toRow, col: toCol, captured: null, castled: true },
        whiteInCheck: gameState.whiteInCheck,
        blackInCheck: gameState.blackInCheck
      });
    }
    
    function executeEnPassant(fromRow, fromCol, toRow, toCol) {
      const isWhite = isWhitePiece(gameState.board[fromRow][fromCol]);
      const captureRow = fromRow;
      const captureCol = toCol;
      const capturedPiece = gameState.board[captureRow][captureCol];
      
      // Move pawn
      gameState.board[toRow][toCol] = gameState.board[fromRow][fromCol];
      gameState.board[fromRow][fromCol] = '';
      
      // Remove captured pawn
      gameState.board[captureRow][captureCol] = '';
      
      // Add to captured pieces
      if (isWhite) {
        gameState.blackCaptured.push(capturedPiece);
      } else {
        gameState.whiteCaptured.push(capturedPiece);
      }
      
      // Add to move history
      gameState.moveHistory.push({
        from: { row: fromRow, col: fromCol, piece: gameState.board[toRow][toCol] },
        to: { row: toRow, col: toCol, captured: capturedPiece, enPassant: true },
        whiteInCheck: gameState.whiteInCheck,
        blackInCheck: gameState.blackInCheck
      });
    }
    
    // NEW POWER-UP FUNCTIONS
    function useLightning() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      console.log('useLightning called, current player:', gameState.currentPlayer);
      console.log('Current power-ups before use:', currentPowerUps);
      console.log('Lightning count before use:', currentPowerUps.lightning);
      
      if (currentPowerUps.lightning > 0 && !gameState.gameOver) {
        playPowerUpSound();
        animatePowerUpButton('lightning-btn', 'lightning');
        
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.lightning--;
        } else {
          gameState.blackPowerUps.lightning--;
        }
        gameState.lightningMode = true;
        
        console.log('Lightning count after use:', currentPowerUps.lightning);
        console.log('White power-ups after lightning use:', gameState.whitePowerUps);
        console.log('Black power-ups after lightning use:', gameState.blackPowerUps);
        
        updatePowerUpButtons();
        checkCombo("Lightning Strike ‚ö°");
        sendPowerUpNotification("Lightning Strike ‚ö°");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      } else {
        console.log('Cannot use lightning - count is 0 or game is over');
      }
    }
    
    function useShield() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.shield > 0 && !gameState.gameOver) {
        playShieldSound();
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.shield--;
          gameState.whiteShieldActive = true;
          gameState.whiteShieldTurnsLeft = 3;
        } else {
          gameState.blackPowerUps.shield--;
          gameState.blackShieldActive = true;
          gameState.blackShieldTurnsLeft = 3;
        }
        updatePowerUpButtons();
        checkCombo("Shield üõ°Ô∏è");
        sendPowerUpNotification("Shield üõ°Ô∏è");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function useHeal() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.heal > 0 && !gameState.gameOver) {
        playPowerUpSound();
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.heal--;
        } else {
          gameState.blackPowerUps.heal--;
        }
        // Show heal modal to select piece to restore
        showHealModal();
        updatePowerUpButtons();
        checkCombo("Heal üíö");
        sendPowerUpNotification("Heal üíö");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function useClone() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.clone > 0 && !gameState.gameOver) {
        playPowerUpSound();
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.clone--;
        } else {
          gameState.blackPowerUps.clone--;
        }
        
        // Clone: Find a random piece and duplicate it
        const myPieces = [];
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            const piece = gameState.board[row][col];
            if (piece && 
                ((gameState.currentPlayer === 'white' && isWhitePiece(piece)) ||
                 (gameState.currentPlayer === 'black' && isBlackPiece(piece)))) {
              myPieces.push({ row, col, piece });
            }
          }
        }
        
        if (myPieces.length > 0) {
          const pieceToClone = myPieces[Math.floor(Math.random() * myPieces.length)];
          
          // Find an empty square to place the clone
          const emptySquares = [];
          for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
              if (!gameState.board[row][col]) {
                emptySquares.push({ row, col });
              }
            }
          }
          
          if (emptySquares.length > 0) {
            const targetSquare = emptySquares[Math.floor(Math.random() * emptySquares.length)];
            gameState.board[targetSquare.row][targetSquare.col] = pieceToClone.piece;
            
            // Visual effect
            const square = document.querySelector(`[data-row="${targetSquare.row}"][data-col="${targetSquare.col}"]`);
            if (square) {
              createSparkles(square, 15);
            }
            
            renderBoard();
            sendPowerUpNotification(`Clone üë• - Duplicated ${pieceToClone.piece}!`);
          } else {
            sendPowerUpNotification("Clone üë• - No empty squares available!");
          }
        } else {
          sendPowerUpNotification("Clone üë• - No pieces to clone!");
        }
        
        updatePowerUpButtons();
        checkCombo("Clone üë•");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function useMagnet() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.magnet > 0 && !gameState.gameOver) {
        playPowerUpSound();
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.magnet--;
        } else {
          gameState.blackPowerUps.magnet--;
        }
        
        // Magnet: Pull opponent pieces toward your pieces
        const opponentPieces = [];
        const myPieces = [];
        
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            const piece = gameState.board[row][col];
            if (piece) {
              if ((gameState.currentPlayer === 'white' && isBlackPiece(piece)) ||
                  (gameState.currentPlayer === 'black' && isWhitePiece(piece))) {
                opponentPieces.push({ row, col, piece });
              } else if ((gameState.currentPlayer === 'white' && isWhitePiece(piece)) ||
                        (gameState.currentPlayer === 'black' && isBlackPiece(piece))) {
                myPieces.push({ row, col, piece });
              }
            }
          }
        }
        
        let movedPieces = 0;
        opponentPieces.forEach(opponentPiece => {
          // Find nearest my piece
          let nearestMyPiece = null;
          let minDistance = Infinity;
          
          myPieces.forEach(myPiece => {
            const distance = Math.abs(opponentPiece.row - myPiece.row) + Math.abs(opponentPiece.col - myPiece.col);
            if (distance < minDistance) {
              minDistance = distance;
              nearestMyPiece = myPiece;
            }
          });
          
          if (nearestMyPiece && minDistance > 1) {
            // Move opponent piece one step closer
            let newRow = opponentPiece.row;
            let newCol = opponentPiece.col;
            
            if (opponentPiece.row < nearestMyPiece.row) newRow++;
            else if (opponentPiece.row > nearestMyPiece.row) newRow--;
            
            if (opponentPiece.col < nearestMyPiece.col) newCol++;
            else if (opponentPiece.col > nearestMyPiece.col) newCol--;
            
            // Check if target square is empty
            if (!gameState.board[newRow][newCol]) {
              gameState.board[opponentPiece.row][opponentPiece.col] = '';
              gameState.board[newRow][newCol] = opponentPiece.piece;
              movedPieces++;
              
              // Visual effect
              const square = document.querySelector(`[data-row="${newRow}"][data-col="${newCol}"]`);
              if (square) {
                createSparkles(square, 8);
              }
            }
          }
        });
        
        updatePowerUpButtons();
        renderBoard();
        checkCombo("Magnet üß≤");
        sendPowerUpNotification(`Magnet üß≤ - Pulled ${movedPieces} pieces closer!`);
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function usePoison() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.poison > 0 && !gameState.gameOver) {
        playPowerUpSound();
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.poison--;
        } else {
          gameState.blackPowerUps.poison--;
        }
        
        // Poison: Weaken random opponent pieces (mark them as poisoned)
        const opponentPieces = [];
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            const piece = gameState.board[row][col];
            if (piece && 
                ((gameState.currentPlayer === 'white' && isBlackPiece(piece)) ||
                 (gameState.currentPlayer === 'black' && isWhitePiece(piece)))) {
              opponentPieces.push({ row, col, piece });
            }
          }
        }
        
        let poisonedCount = 0;
        const piecesToPoison = Math.min(3, opponentPieces.length); // Poison up to 3 pieces
        
        for (let i = 0; i < piecesToPoison; i++) {
          const randomIndex = Math.floor(Math.random() * opponentPieces.length);
          const piece = opponentPieces.splice(randomIndex, 1)[0];
          
          // Mark piece as poisoned (we'll track this in gameState)
          if (!gameState.poisonedPieces) {
            gameState.poisonedPieces = [];
          }
          
          gameState.poisonedPieces.push({
            row: piece.row,
            col: piece.col,
            piece: piece.piece,
            turnsLeft: 3 // Poison lasts 3 turns
          });
          
          poisonedCount++;
          
          // Visual effect
          const square = document.querySelector(`[data-row="${piece.row}"][data-col="${piece.col}"]`);
          if (square) {
            square.style.filter = 'hue-rotate(120deg) brightness(0.7)';
            createSparkles(square, 10);
          }
        }
        
        updatePowerUpButtons();
        renderBoard();
        checkCombo("Poison ‚ò†Ô∏è");
        sendPowerUpNotification(`Poison ‚ò†Ô∏è - Poisoned ${poisonedCount} enemy pieces!`);
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function useShieldWall() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.shield_wall > 0 && !gameState.gameOver) {
        playPowerUpSound();
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.shield_wall--;
          gameState.whiteShieldWallActive = true;
          gameState.whiteShieldWallTurnsLeft = 1;
        } else {
          gameState.blackPowerUps.shield_wall--;
          gameState.blackShieldWallActive = true;
          gameState.blackShieldWallTurnsLeft = 1;
        }
        updatePowerUpButtons();
        checkCombo("Shield Wall üè∞");
        sendPowerUpNotification("Shield Wall üè∞");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function useSpeedBoost() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.speed_boost > 0 && !gameState.gameOver) {
        playPowerUpSound();
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.speed_boost--;
          gameState.whiteSpeedBoostActive = true;
          gameState.whiteSpeedBoostTurnsLeft = 1;
        } else {
          gameState.blackPowerUps.speed_boost--;
          gameState.blackSpeedBoostActive = true;
          gameState.blackSpeedBoostTurnsLeft = 1;
        }
        updatePowerUpButtons();
        checkCombo("Speed Boost üöÄ");
        sendPowerUpNotification("Speed Boost üöÄ");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function useInvisibility() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      
      // Check if it's our turn in online mode
      if (gameState.mode === 'online') {
        const isOurTurn = (gameState.playerColor === 'white' && gameState.currentPlayer === 'white') ||
                          (gameState.playerColor === 'black' && gameState.currentPlayer === 'black');
        if (!isOurTurn) {
          alert("You can only use power-ups on your turn!");
          return;
        }
      }
      
      if (currentPowerUps.invisibility > 0 && !gameState.gameOver) {
        playPowerUpSound();
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.invisibility--;
          // Make WHITE pieces invisible (your own pieces)
          gameState.whiteInvisibilityActive = true;
          gameState.whiteInvisibilityTurnsLeft = 3;
        } else {
          gameState.blackPowerUps.invisibility--;
          // Make BLACK pieces invisible (your own pieces)
          gameState.blackInvisibilityActive = true;
          gameState.blackInvisibilityTurnsLeft = 3;
        }
        updatePowerUpButtons();
        checkCombo("Invisibility üëª");
        sendPowerUpNotification("Invisibility üëª");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function useEarthquake() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.earthquake > 0 && !gameState.gameOver) {
        playPowerUpSound();
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.earthquake--;
        } else {
          gameState.blackPowerUps.earthquake--;
        }
        // Shuffle all pieces randomly
        shuffleAllPieces();
        updatePowerUpButtons();
        checkCombo("Earthquake üåã");
        sendPowerUpNotification("Earthquake üåã");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function useBlizzard() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.blizzard > 0 && !gameState.gameOver) {
        playPowerUpSound();
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.blizzard--;
          gameState.blizzardActive = true;
          gameState.blizzardTurnsLeft = 2;
        } else {
          gameState.blackPowerUps.blizzard--;
          gameState.blizzardActive = true;
          gameState.blizzardTurnsLeft = 2;
        }
        updatePowerUpButtons();
        checkCombo("Blizzard üå®Ô∏è");
        sendPowerUpNotification("Blizzard üå®Ô∏è");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function useLaser() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.laser > 0 && !gameState.gameOver && !gameState.laserMode) {
        playLaserSound();
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.laser--;
        } else {
          gameState.blackPowerUps.laser--;
        }
        
        // Enter laser targeting mode
        gameState.laserMode = true;
        renderBoard();
        updatePowerUpButtons();
        
        // Check for combos
        checkCombo("Laser Beam üî¥");
        
        // Send notification to other player
        sendPowerUpNotification("Laser Beam üî¥ - Targeting mode activated!");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function copyLastMove() {
      // Copy the opponent's last move
      if (gameState.moveHistory.length > 0) {
        const lastMove = gameState.moveHistory[gameState.moveHistory.length - 1];
        
        // Check if the last move was made by the opponent
        const wasOpponentMove = 
          (gameState.currentPlayer === 'white' && isBlackPiece(lastMove.from.piece)) ||
          (gameState.currentPlayer === 'black' && isWhitePiece(lastMove.from.piece));
        
        if (wasOpponentMove && lastMove.to) {
          // Try to make the same move the opponent just made
          const fromRow = lastMove.to.row;
          const fromCol = lastMove.to.col;
          const toRow = lastMove.from.row;
          const toCol = lastMove.from.col;
          
          const piece = gameState.board[fromRow][fromCol];
          
          if (piece && canMovePiece(fromRow, fromCol, toRow, toCol)) {
            const captured = gameState.board[toRow][toCol];
            const fromSquare = document.querySelector(`[data-row="${fromRow}"][data-col="${fromCol}"]`);
            const toSquare = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"]`);
            
            if (fromSquare && toSquare) {
              executeMove(fromRow, fromCol, toRow, toCol, piece, captured, fromSquare, toSquare);
              console.log('Mirror: Copied opponent move');
              return true;
            }
          }
        }
      }
      
      console.log('Mirror: No valid move to copy');
      return false;
    }
    
    function useMirror() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.mirror > 0 && !gameState.gameOver) {
        playPowerUpSound();
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.mirror--;
        } else {
          gameState.blackPowerUps.mirror--;
        }
        
        // Copy enemy's last move
        const success = copyLastMove();
        
        updatePowerUpButtons();
        checkCombo("Mirror ü™û");
        sendPowerUpNotification(success ? "Mirror ü™û - Move copied!" : "Mirror ü™û - No move to copy!");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function useTornado() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.tornado > 0 && !gameState.gameOver && !gameState.tornadoMode) {
        playTornadoSound();
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.tornado--;
        } else {
          gameState.blackPowerUps.tornado--;
        }
        
        // Enter tornado targeting mode
        gameState.tornadoMode = true;
        renderBoard();
        updatePowerUpButtons();
        
        // Check for combos
        checkCombo("Tornado üå™Ô∏è");
        
        // Send notification to other player
        sendPowerUpNotification("Tornado üå™Ô∏è - Targeting mode activated!");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function useBomb() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.bomb > 0 && !gameState.gameOver && !gameState.bombMode) {
        playBombSound();
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.bomb--;
        } else {
          gameState.blackPowerUps.bomb--;
        }
        
        // Enter bomb targeting mode
        gameState.bombMode = true;
        renderBoard();
        updatePowerUpButtons();
        
        // Check for combos
        checkCombo("Bomb üí£");
        
        // Send notification to other player
        sendPowerUpNotification("Bomb üí£ - Targeting mode activated!");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function useGravity() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.gravity > 0 && !gameState.gameOver) {
        playPowerUpSound();
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.gravity--;
        } else {
          gameState.blackPowerUps.gravity--;
        }
        // Make pieces fall to bottom
        applyGravity();
        updatePowerUpButtons();
        checkCombo("Gravity Flip üåç");
        sendPowerUpNotification("Gravity Flip üåç");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function usePhoenix() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.phoenix > 0 && !gameState.gameOver) {
        playPowerUpSound();
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.phoenix--;
          // Revive white queen
          revivePiece('white', '‚ôï');
        } else {
          gameState.blackPowerUps.phoenix--;
          // Revive black queen
          revivePiece('black', '‚ôõ');
        }
        updatePowerUpButtons();
        checkCombo("Phoenix Rise üî•");
        sendPowerUpNotification("Phoenix Rise üî•");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function useFreeze() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.freeze > 0 && !gameState.gameOver) {
        playFreezeSound();
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.freeze--;
        } else {
          gameState.blackPowerUps.freeze--;
        }
        // Freeze opponent for 1 turn
        gameState.freezeActive = true;
        updatePowerUpButtons();
        checkCombo("Freeze ‚ùÑÔ∏è");
        sendPowerUpNotification("Freeze ‚ùÑÔ∏è");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function useCoinRain() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.coin_rain > 0 && !gameState.gameOver) {
        playPowerUpSound();
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.coin_rain--;
          gameState.whiteCoins += 50;
        } else {
          gameState.blackPowerUps.coin_rain--;
          gameState.blackCoins += 50;
        }
        document.getElementById('coin-count').textContent = getCurrentCoins();
        updatePowerUpButtons();
        checkCombo("Coin Rain ü™ô");
        sendPowerUpNotification("Coin Rain ü™ô");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function usePowerSteal() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.power_steal > 0 && !gameState.gameOver) {
        playPowerUpSound();
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.power_steal--;
        } else {
          gameState.blackPowerUps.power_steal--;
        }
        // Steal random power-up
        stealRandomPowerUp();
        updatePowerUpButtons();
        checkCombo("Power Steal üé≠");
        sendPowerUpNotification("Power Steal üé≠");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function useMegaBomb() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.mega_bomb > 0 && !gameState.gameOver && !gameState.megaBombMode) {
        playMegaBombSound();
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.mega_bomb--;
        } else {
          gameState.blackPowerUps.mega_bomb--;
        }
        
        // Enter mega bomb targeting mode
        gameState.megaBombMode = true;
        renderBoard();
        updatePowerUpButtons();
        
        // Check for combos
        checkCombo("Mega Bomb üí•");
        
        // Send notification to other player
        sendPowerUpNotification("Mega Bomb üí• - Targeting mode activated!");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function useRoyalGuard() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.royal_guard > 0 && !gameState.gameOver) {
        playPowerUpSound();
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.royal_guard--;
          gameState.whiteRoyalGuardActive = true;
          gameState.whiteRoyalGuardTurnsLeft = 1;
        } else {
          gameState.blackPowerUps.royal_guard--;
          gameState.blackRoyalGuardActive = true;
          gameState.blackRoyalGuardTurnsLeft = 1;
        }
        updatePowerUpButtons();
        checkCombo("Royal Guard ‚öîÔ∏è");
        sendPowerUpNotification("Royal Guard ‚öîÔ∏è");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function useLuckyCharm() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.lucky_charm > 0 && !gameState.gameOver) {
        playPowerUpSound();
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.lucky_charm--;
          gameState.whiteLuckyCharmActive = true;
        } else {
          gameState.blackPowerUps.lucky_charm--;
          gameState.blackLuckyCharmActive = true;
        }
        updatePowerUpButtons();
        checkCombo("Lucky Charm üçÄ");
        sendPowerUpNotification("Lucky Charm üçÄ");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function useChaos() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.chaos > 0 && !gameState.gameOver) {
        playPowerUpSound();
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.chaos--;
        } else {
          gameState.blackPowerUps.chaos--;
        }
        // Apply random effect
        applyRandomEffect();
        updatePowerUpButtons();
        checkCombo("Chaos Roll üé≤");
        sendPowerUpNotification("Chaos Roll üé≤");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    // DEBUG: Test function to check save/load
    function testPowerUpSaveLoad() {
      console.log('=== TESTING POWER-UP SAVE/LOAD ===');
      
      // Show current state
      console.log('Current white power-ups:', gameState.whitePowerUps);
      console.log('Current black power-ups:', gameState.blackPowerUps);
      
      // Test saving
      console.log('\n--- TESTING SAVE ---');
      savePlayerProgress();
      
      // Get what's actually in localStorage
      const savedData = localStorage.getItem('chessPlayerProgress');
      const parsedData = JSON.parse(savedData);
      console.log('Data in localStorage:', parsedData);
      console.log('White power-ups in localStorage:', parsedData.whitePowerUps);
      console.log('Black power-ups in localStorage:', parsedData.blackPowerUps);
      
      // Test loading
      console.log('\n--- TESTING LOAD ---');
      loadPlayerProgress();
      
      console.log('White power-ups after load:', gameState.whitePowerUps);
      console.log('Black power-ups after load:', gameState.blackPowerUps);
      
      console.log('=== END TEST ===');
    }
    
    // Make test function available globally
    window.testPowerUpSaveLoad = testPowerUpSaveLoad;
    
    // DEBUG: Test function to manually change power-ups
    function testPowerUpChange() {
      console.log('=== TESTING POWER-UP CHANGE ===');
      
      // Change some power-up counts
      gameState.whitePowerUps.lightning = 1;
      gameState.whitePowerUps.heal = 1;
      gameState.blackPowerUps.phoenix = 1;
      
      console.log('After manual change:');
      console.log('White power-ups:', gameState.whitePowerUps);
      console.log('Black power-ups:', gameState.blackPowerUps);
      
      // Save
      savePlayerProgress();
      
      // Load
      loadPlayerProgress();
      
      console.log('After save/load cycle:');
      console.log('White power-ups:', gameState.whitePowerUps);
      console.log('Black power-ups:', gameState.blackPowerUps);
      
      console.log('=== END TEST ===');
    }
    
    // Make test function available globally
    window.testPowerUpChange = testPowerUpChange;
    function showHealModal() {
      // Simple heal - restore last captured piece
      const isWhite = gameState.currentPlayer === 'white';
      const capturedPieces = isWhite ? gameState.whiteCaptured : gameState.blackCaptured;
      
      if (capturedPieces.length > 0) {
        const pieceToRestore = capturedPieces.pop();
        const backRow = isWhite ? 0 : 7;
        let emptyCol = -1;
        
        // Find empty spot in back row
        for (let col = 0; col < 8; col++) {
          if (!gameState.board[backRow][col]) {
            emptyCol = col;
            break;
          }
        }
        
        if (emptyCol !== -1) {
          gameState.board[backRow][emptyCol] = pieceToRestore;
          renderBoard();
          createSparkles(document.querySelector(`[data-row="${backRow}"][data-col="${emptyCol}"]`), 10);
        }
      }
    }
    
    function shuffleAllPieces() {
      const allPieces = [];
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          if (gameState.board[row][col]) {
            allPieces.push(gameState.board[row][col]);
          }
        }
      }
      
      // Clear board
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          gameState.board[row][col] = '';
        }
      }
      
      // Place pieces randomly
      allPieces.forEach(piece => {
        let placed = false;
        while (!placed) {
          const row = Math.floor(Math.random() * 8);
          const col = Math.floor(Math.random() * 8);
          if (!gameState.board[row][col]) {
            gameState.board[row][col] = piece;
            placed = true;
          }
        }
      });
      
      renderBoard();
      createConfetti(document.body);
    }
    
    function applyGravity() {
      // Make pieces fall to bottom
      for (let col = 0; col < 8; col++) {
        const pieces = [];
        for (let row = 0; row < 8; row++) {
          if (gameState.board[row][col]) {
            pieces.push(gameState.board[row][col]);
            gameState.board[row][col] = '';
          }
        }
        
        // Place pieces at bottom
        let row = 7;
        pieces.forEach(piece => {
          gameState.board[row][col] = piece;
          row--;
        });
      }
      
      renderBoard();
    }
    
    function revivePiece(color, pieceType) {
      const backRow = color === 'white' ? 0 : 7;
      let emptyCol = -1;
      
      for (let col = 0; col < 8; col++) {
        if (!gameState.board[backRow][col]) {
          emptyCol = col;
          break;
        }
      }
      
      if (emptyCol !== -1) {
        gameState.board[backRow][emptyCol] = pieceType;
        renderBoard();
        createSparkles(document.querySelector(`[data-row="${backRow}"][data-col="${emptyCol}"]`), 15);
      }
    }
    
    function freezeTimer(seconds) {
      // Timer freeze implementation
      if (gameState.timerRunning) {
        gameState.timerFrozen = true;
        gameState.timerFrozenTimeLeft = seconds;
        
        const freezeInterval = setInterval(() => {
          gameState.timerFrozenTimeLeft--;
          if (gameState.timerFrozenTimeLeft <= 0) {
            gameState.timerFrozen = false;
            clearInterval(freezeInterval);
          }
        }, 1000);
      }
    }
    
    function stealRandomPowerUp() {
      const targetPowerUps = gameState.currentPlayer === 'white' ? gameState.blackPowerUps : gameState.whitePowerUps;
      const myPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      
      const powerUpKeys = Object.keys(targetPowerUps);
      if (powerUpKeys.length > 0) {
        const randomPowerUp = powerUpKeys[Math.floor(Math.random() * powerUpKeys.length)];
        if (targetPowerUps[randomPowerUp] > 0) {
          targetPowerUps[randomPowerUp]--;
          myPowerUps[randomPowerUp]++;
          updatePowerUpButtons();
        }
      }
    }
    
    function applyGravity() {
      // Make all pieces fall to the bottom of the board
      for (let col = 0; col < 8; col++) {
        const pieces = [];
        
        // Collect all pieces in this column from bottom to top
        for (let row = 7; row >= 0; row--) {
          if (gameState.board[row][col]) {
            pieces.push(gameState.board[row][col]);
            gameState.board[row][col] = ''; // Clear the square
          }
        }
        
        // Place pieces back at the bottom
        for (let i = 0; i < pieces.length; i++) {
          const targetRow = 7 - i; // Start from bottom
          gameState.board[targetRow][col] = pieces[i];
        }
      }
      
      // Visual effect - gravity animation
      const boardElement = document.getElementById('board');
      if (boardElement) {
        boardElement.style.animation = 'gravityFall 1s ease-in-out';
        setTimeout(() => {
          boardElement.style.animation = '';
        }, 1000);
      }
      
      renderBoard();
      console.log('Gravity Flip: All pieces fell to the bottom!');
    }
    
    function shuffleAllPieces() {
      // Shuffle all pieces randomly on the board
      const allPieces = [];
      
      // Collect all pieces
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          const piece = gameState.board[row][col];
          if (piece) {
            allPieces.push({ piece, row, col });
            gameState.board[row][col] = ''; // Clear the board
          }
        }
      }
      
      // Shuffle pieces
      for (let i = allPieces.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [allPieces[i], allPieces[j]] = [allPieces[j], allPieces[i]];
      }
      
      // Place shuffled pieces back on board
      allPieces.forEach(({ piece, row, col }) => {
        // Find a random empty square
        let placed = false;
        let attempts = 0;
        while (!placed && attempts < 100) {
          const randomRow = Math.floor(Math.random() * 8);
          const randomCol = Math.floor(Math.random() * 8);
          if (!gameState.board[randomRow][randomCol]) {
            gameState.board[randomRow][randomCol] = piece;
            placed = true;
          }
          attempts++;
        }
        
        // If couldn't find a random spot, try to place back in original spot
        if (!placed && !gameState.board[row][col]) {
          gameState.board[row][col] = piece;
        }
      });
      
      // Visual effect - earthquake shake
      const boardElement = document.getElementById('board');
      if (boardElement) {
        boardElement.style.animation = 'shake 0.5s';
        setTimeout(() => {
          boardElement.style.animation = '';
        }, 500);
      }
      
      renderBoard();
      console.log('Earthquake: All pieces shuffled!');
    }
    
    function copyLastMove() {
      // Copy opponent's last move
      if (gameState.moveHistory.length > 1) {
        const lastMove = gameState.moveHistory[gameState.moveHistory.length - 1];
        // Simple implementation - just give a hint
        const piece = lastMove.to.piece;
        if (piece) {
          // Add a hint effect
          const square = document.querySelector(`[data-row="${lastMove.from.row}"][data-col="${lastMove.from.col}"]`);
          if (square) {
            square.classList.add('hint-pulse');
            setTimeout(() => square.classList.remove('hint-pulse'), 2000);
          }
        }
      }
    }
    
    function applyRandomEffect() {
      const effects = [
        () => { gameState.currentPlayer = gameState.currentPlayer === 'white' ? 'black' : 'white'; },
        () => { addCoins(10, document.body); },
        () => { createConfetti(document.body); },
        () => { 
          // Random piece swap
          const pieces = [];
          for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
              if (gameState.board[row][col] && Math.random() < 0.1) {
                pieces.push({row, col, piece: gameState.board[row][col]});
              }
            }
          }
          
          if (pieces.length >= 2) {
            const [p1, p2] = pieces;
            gameState.board[p1.row][p1.col] = p2.piece;
            gameState.board[p2.row][p2.col] = p1.piece;
            renderBoard();
          }
        }
      ];
      
      const randomEffect = effects[Math.floor(Math.random() * effects.length)];
      randomEffect();
    }
    
    function checkForKingCapture() {
      // Only check for king capture if game is not already over
      if (gameState.gameOver) {
        return false;
      }
      
      // Don't check during AI turns at all - only check after human moves
      if (gameState.mode === 'ai' && gameState.currentPlayer === 'black') {
        return false;
      }
      
      const whiteKing = findKing(true);
      const blackKing = findKing(false);
      
      console.log('üîç King check - White king:', whiteKing, 'Black king:', blackKing);
      console.log('üîç Last move:', gameState.lastMove);
      
      // Only proceed if BOTH kings exist
      if (!whiteKing || !blackKing) {
        console.log('‚ö†Ô∏è Missing king detected, but this might be checkmate or stalemate');
        
        // Additional safety: only declare game over if the missing king was actually captured
        // This requires that the missing king was on the board in the previous move
        if (gameState.moveHistory.length > 1) {
          const previousMove = gameState.moveHistory[gameState.moveHistory.length - 2];
          const boardBeforeLastMove = gameState.board.map(row => [...row]);
          
          // Reconstruct board before last move to check if king was actually captured
          const fromRow = previousMove.from.row;
          const fromCol = previousMove.from.col;
          const toRow = previousMove.to.row;
          const toCol = previousMove.to.col;
          
          boardBeforeLastMove[fromRow][fromCol] = previousMove.from.piece;
          boardBeforeLastMove[toRow][toCol] = previousMove.to.captured || '';
          
          // Check if king existed before the last move
          let whiteKingExisted = false;
          let blackKingExisted = false;
          
          for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
              if (boardBeforeLastMove[row][col] === '‚ôî') whiteKingExisted = true;
              if (boardBeforeLastMove[row][col] === '‚ôö') blackKingExisted = true;
            }
          }
          
          // Only declare game over if king was actually captured (existed before, doesn't exist now)
          if (!whiteKing && whiteKingExisted && previousMove.to.captured === '‚ôî') {
            console.log('üëë White king was actually captured');
            gameState.gameOver = true;
            setTimeout(() => {
              const winner = gameState.currentPlayer === 'white' ? 'Black' : 'White';
              alert(`Game Over! ${winner} wins by capturing the White King! üëë`);
              createConfetti(document.body);
            }, 100);
            playGameOverSound();
            return true;
          }
          
          if (!blackKing && blackKingExisted && previousMove.to.captured === '‚ôö') {
            console.log('üëë Black king was actually captured');
            gameState.gameOver = true;
            setTimeout(() => {
              const winner = gameState.currentPlayer === 'white' ? 'White' : 'Black';
              alert(`Game Over! ${winner} wins by capturing the Black King! üëë`);
              createConfetti(document.body);
            }, 100);
            playGameOverSound();
            return true;
          }
        }
        
        console.log('üõ°Ô∏è King was not actually captured - no confetti');
        return false;
      }
      
      return false;
    }
    
    // Helper function to check if board is completely empty
    function isBoardEmpty() {
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          if (gameState.board[row][col]) {
            return false;
          }
        }
      }
      return true;
    }
    
    function sendPowerUpNotification(powerUpName) {
      if (gameState.mode === 'online' && gameState.roomCode) {
        const currentPlayerName = gameState.currentPlayer === 'white' ? 
          (gameState.playerColor === 'white' ? gameState.playerName : gameState.opponentName) :
          (gameState.playerColor === 'black' ? gameState.playerName : gameState.opponentName);
        
        const message = `‚ö° ${currentPlayerName} used ${powerUpName}!`;
        
        // Add to chat messages as system notification
        if (!gameState.chatMessages) {
          gameState.chatMessages = [];
        }
        gameState.chatMessages.push({
          sender: 'System',
          message: message,
          timestamp: Date.now(),
          isSystem: true
        });
        
        // Update server with new chat message
        updateGameStateOnServer();
        
        // Render chat to show the notification
        renderChatMessages();
      }
    }
    
    function useShield() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      const shieldActive = gameState.currentPlayer === 'white' ? gameState.whiteShieldActive : gameState.blackShieldActive;
      if (currentPowerUps.shield > 0 && !shieldActive && !gameState.gameOver) {
        playPowerUpSound();
        if (gameState.currentPlayer === 'white') {
          gameState.whiteShieldActive = true;
          gameState.whitePowerUps.shield--;
        } else {
          gameState.blackShieldActive = true;
          gameState.blackPowerUps.shield--;
        }
        updatePowerUpButtons();
        
        // Check for combos
        checkCombo("Shield üõ°Ô∏è");
        
        // Send notification to other player
        sendPowerUpNotification("Shield üõ°Ô∏è");
        
        // Save progress locally
        savePlayerProgress();
      }
    }
    
    function useDoubleCoins() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      const doubleActive = gameState.currentPlayer === 'white' ? gameState.whiteDoubleCoinsActive : gameState.blackDoubleCoinsActive;
      if (currentPowerUps.double_coins > 0 && !doubleActive && !gameState.gameOver) {
        playPowerUpSound();
        if (gameState.currentPlayer === 'white') {
          gameState.whiteDoubleCoinsActive = true;
          gameState.whiteDoubleCoinsMovesLeft = 5;
          gameState.whitePowerUps.double_coins--;
        } else {
          gameState.blackDoubleCoinsActive = true;
          gameState.blackDoubleCoinsMovesLeft = 5;
          gameState.blackPowerUps.double_coins--;
        }
        updatePowerUpButtons();
        
        // Check for combos
        checkCombo("Double Coins üí∞");
        
        // Send notification to other player
        sendPowerUpNotification("Double Coins üí∞");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function useFreeze() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.freeze > 0 && !gameState.freezeActive && !gameState.gameOver) {
        gameState.freezeActive = true;
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.freeze--;
        } else {
          gameState.blackPowerUps.freeze--;
        }
        renderBoard();
        updatePowerUpButtons();
        
        // Check for combos
        checkCombo("Freeze ‚ùÑÔ∏è");
        
        // Send notification to other player
        sendPowerUpNotification("Freeze ‚ùÑÔ∏è");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function useKnightBoost() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      const boostActive = gameState.currentPlayer === 'white' ? gameState.whiteKnightBoostActive : gameState.blackKnightBoostActive;
      if (currentPowerUps.knight_boost > 0 && !boostActive && !gameState.gameOver) {
        if (gameState.currentPlayer === 'white') {
          gameState.whiteKnightBoostActive = true;
          gameState.whiteKnightBoostMovesLeft = 3;
          gameState.whitePowerUps.knight_boost--;
        } else {
          gameState.blackKnightBoostActive = true;
          gameState.blackKnightBoostMovesLeft = 3;
          gameState.blackPowerUps.knight_boost--;
        }
        updatePowerUpButtons();
        
        // Check for combos
        checkCombo("Knight Boost üê¥");
        
        // Send notification to other player
        sendPowerUpNotification("Knight Boost üê¥");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function useVision() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      const visionActive = gameState.currentPlayer === 'white' ? gameState.whiteVisionActive : gameState.blackVisionActive;
      if (currentPowerUps.vision > 0 && !visionActive && !gameState.gameOver) {
        if (gameState.currentPlayer === 'white') {
          gameState.whiteVisionActive = true;
          gameState.whitePowerUps.vision--;
        } else {
          gameState.blackVisionActive = true;
          gameState.blackPowerUps.vision--;
        }
        updatePowerUpButtons();
        
        // Check for combos
        checkCombo("Vision üëÅÔ∏è");
        
        // Send notification to other player
        sendPowerUpNotification("Vision üëÅÔ∏è");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function useSwap() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.swap > 0 && !gameState.swapMode && !gameState.gameOver) {
        gameState.swapMode = true;
        gameState.swapFirstPiece = null;
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.swap--;
        } else {
          gameState.blackPowerUps.swap--;
        }
        renderBoard();
        updatePowerUpButtons();
        
        // Check for combos
        checkCombo("Swap üîÑ");
        
        // Send notification to other player
        sendPowerUpNotification("Swap üîÑ");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function useBomb() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.bomb > 0 && !gameState.bombMode && !gameState.gameOver) {
        gameState.bombMode = true;
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.bomb--;
        } else {
          gameState.blackPowerUps.bomb--;
        }
        renderBoard();
        updatePowerUpButtons();
        
        // Check for combos
        checkCombo("Bomb üí£");
        
        // Send notification to other player
        sendPowerUpNotification("Bomb üí£");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function useTimeWarp() {
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      if (currentPowerUps.time_warp > 0 && !gameState.timeWarpActive && !gameState.gameOver) {
        gameState.timeWarpActive = true;
        if (gameState.currentPlayer === 'white') {
          gameState.whitePowerUps.time_warp--;
        } else {
          gameState.blackPowerUps.time_warp--;
        }
        updatePowerUpButtons();
        
        // Check for combos
        checkCombo("Time Warp ‚è±Ô∏è");
        
        // Send notification to other player
        sendPowerUpNotification("Time Warp ‚è±Ô∏è");
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      }
    }
    
    function showGuestJoinedModal(guestName) {
      console.log('üéÆ MODAL: Attempting to show guest joined modal for:', guestName);
      const modal = document.getElementById('guest-joined-modal');
      const message = document.getElementById('guest-joined-message');
      
      if (!modal) {
        console.error('üéÆ MODAL: Modal element not found!');
        return;
      }
      
      if (!message) {
        console.error('üéÆ MODAL: Message element not found!');
        return;
      }
      
      message.textContent = `${guestName} has joined your game!\n\nThe game is starting now...`;
      modal.style.display = 'flex';
      console.log('üéÆ MODAL: Modal displayed successfully');
      playGameStartSound();
      
      // Auto-close after 5 seconds
      setTimeout(() => {
        closeGuestJoinedModal();
      }, 5000);
    }
    
    function closeGuestJoinedModal() {
      const modal = document.getElementById('guest-joined-modal');
      modal.style.display = 'none';
    }
    
    function resetGame() {
      const keepWhiteCoins = gameState.whiteCoins;
      const keepBlackCoins = gameState.blackCoins;
      const keepWhiteSkins = gameState.whiteUnlockedSkins;
      const keepBlackSkins = gameState.blackUnlockedSkins;
      const keepWhiteCurrentSkin = gameState.whiteCurrentSkin;
      const keepBlackCurrentSkin = gameState.blackCurrentSkin;
      const keepThemes = gameState.unlockedThemes;
      const keepCurrentTheme = gameState.currentTheme;
      const keepWhitePowerUps = gameState.whitePowerUps;
      const keepBlackPowerUps = gameState.blackPowerUps;
      const keepMode = gameState.mode;
      const keepRoomCode = gameState.roomCode;
      const keepPlayerRole = gameState.playerRole;
      const keepPlayerColor = gameState.playerColor;
      const keepPlayerName = gameState.playerName;
      const keepOpponentName = gameState.opponentName;
      const keepAIDifficulty = gameState.aiDifficulty;
      const keepCurrentGameRecord = gameState.currentGameRecord;
      
      gameState = {
        mode: keepMode,
        aiDifficulty: keepAIDifficulty,
        board: JSON.parse(JSON.stringify(initialBoard)),
        currentPlayer: 'white',
        selectedSquare: null,
        whiteCaptured: [],
        blackCaptured: [],
        gameOver: false,
        lastMove: null,
        whiteInCheck: false,
        blackInCheck: false,
        whiteCoins: keepWhiteCoins,
        blackCoins: keepBlackCoins,
        whiteUnlockedSkins: keepWhiteSkins,
        blackUnlockedSkins: keepBlackSkins,
        whiteCurrentSkin: keepWhiteCurrentSkin,
        blackCurrentSkin: keepBlackCurrentSkin,
        unlockedThemes: keepThemes,
        currentTheme: keepCurrentTheme,
        whitePowerUps: keepWhitePowerUps,
        blackPowerUps: keepBlackPowerUps,
        moveHistory: [],
        whiteShieldActive: false,
        blackShieldActive: false,
        whiteDoubleCoinsActive: false,
        blackDoubleCoinsActive: false,
        whiteDoubleCoinsMovesLeft: 0,
        blackDoubleCoinsMovesLeft: 0,
        freezeActive: false,
        whiteKnightBoostActive: false,
        blackKnightBoostActive: false,
        whiteKnightBoostMovesLeft: 0,
        blackKnightBoostMovesLeft: 0,
        whiteVisionActive: false,
        blackVisionActive: false,
        swapMode: false,
        swapFirstPiece: null,
        bombMode: false,
        laserMode: false,
        megaBombMode: false,
        lightningMode: false,
        tornadoMode: false,
        timeWarpActive: false,
        roomCode: keepRoomCode,
        playerRole: keepPlayerRole,
        playerColor: keepPlayerColor,
        playerName: keepPlayerName,
        opponentName: keepOpponentName,
        currentGameRecord: keepCurrentGameRecord
      };
      
      renderBoard();
      updatePowerUpButtons();
      
      if (gameState.mode === 'online') {
        updateGameStateOnServer();
      }
    }
    
    // Shop and admin functions
    function openShop() {
      playShopSound();
      const modal = document.getElementById('shop-modal');
      modal.style.display = 'block';
      modal.style.position = 'fixed';
      modal.style.top = '0';
      modal.style.left = '0';
      modal.style.width = '100%';
      modal.style.height = '100%';
      modal.style.zIndex = '1000';
      document.getElementById('shop-coin-count').textContent = getCurrentCoins();
      
      renderShopItems();
      
      // Add search event listeners
      const searchInput = document.getElementById('shop-search');
      searchInput.removeEventListener('input', handleSearch); // Remove any existing listener
      searchInput.addEventListener('input', handleSearch);
      searchInput.removeEventListener('keydown', handleSearchEnter); // Remove any existing Enter listener
      searchInput.addEventListener('keydown', handleSearchEnter);
    }
    
    function handleSearch(e) {
      filterShopItems(e.target.value);
    }
    
    function handleSearchEnter(e) {
      if (e.key === 'Enter') {
        filterShopItems(e.target.value);
      }
    }
    
    function renderShopItems() {
      renderBundlesShop();
      renderPowerUpsShop();
      renderSkinsShop();
      renderThemesShop();
      renderEffectsShop();
      renderSoundPacksShop();
    }
    
    // Search functionality
    function filterShopItems(searchTerm) {
      const term = searchTerm.toLowerCase().trim();
      console.log('Searching for:', term);
      
      // Get all shop items
      const allItems = document.querySelectorAll('#bundles-container > div, #powerups-container > div, #skins-container > div, #themes-container > div, #effects-container > div, #soundpacks-container > div');
      const allHeaders = document.querySelectorAll('#shop-content h3');
      
      // Hide all headers first
      allHeaders.forEach(header => {
        header.style.display = 'none';
      });
      
      // Show all items if search is empty
      if (term === '') {
        allItems.forEach(item => {
          item.style.display = '';
        });
        allHeaders.forEach(header => {
          header.style.display = '';
        });
        return;
      }
      
      // Track which sections have visible items
      const sectionVisibility = {
        'bundles': false,
        'powerups': false,
        'skins': false, 
        'themes': false,
        'effects': false,
        'soundpacks': false
      };
      
      // Filter items
      allItems.forEach(item => {
        const text = item.textContent.toLowerCase();
        const parentContainer = item.parentElement.id;
        
        if (text.includes(term)) {
          item.style.display = '';
          
          // Mark section as having visible items
          if (parentContainer === 'bundles-container') sectionVisibility.bundles = true;
          if (parentContainer === 'powerups-container') sectionVisibility.powerups = true;
          if (parentContainer === 'skins-container') sectionVisibility.skins = true;
          if (parentContainer === 'themes-container') sectionVisibility.themes = true;
          if (parentContainer === 'effects-container') sectionVisibility.effects = true;
          if (parentContainer === 'soundpacks-container') sectionVisibility.soundpacks = true;
          
          console.log('Match found:', text);
        } else {
          item.style.display = 'none';
        }
      });
      
      // Show headers for sections with visible items
      allHeaders.forEach(header => {
        const headerText = header.textContent.toLowerCase();
        if (headerText.includes('complete bundles') && sectionVisibility.bundles) {
          header.style.display = '';
        } else if (headerText.includes('power-ups') && sectionVisibility.powerups) {
          header.style.display = '';
        } else if (headerText.includes('skins') && sectionVisibility.skins) {
          header.style.display = '';
        } else if (headerText.includes('themes') && sectionVisibility.themes) {
          header.style.display = '';
        } else if (headerText.includes('effects') && sectionVisibility.effects) {
          header.style.display = '';
        } else if (headerText.includes('sound packs') && sectionVisibility.soundpacks) {
          header.style.display = '';
        }
      });
    }
    
    function renderPowerUpsShop() {
      const container = document.getElementById('powerups-container');
      container.innerHTML = '';
      
      Object.keys(powerUpsData).forEach(powerupId => {
        const powerup = powerUpsData[powerupId];
        const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
        const ownedCount = currentPowerUps[powerupId] || 0;
        
        const item = document.createElement('div');
        item.style.cssText = 'background: rgba(255,255,255,0.1); padding: 16px; border-radius: 12px; backdrop-filter: blur(10px);';
        item.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
            <div style="display: flex; align-items: center; gap: 12px;">
              <span style="font-size: 32px;">${powerup.icon}</span>
              <div>
                <div style="font-weight: bold; color: #f1f5f9; font-size: 18px;">${powerup.name}</div>
                <div style="color: #cbd5e1; font-size: 14px;">${powerup.description}</div>
              </div>
            </div>
            <div style="text-align: right;">
              <div style="color: #f1f5f9; font-weight: bold; font-size: 16px;">ü™ô ${powerup.cost}</div>
              <div style="color: #cbd5e1; font-size: 12px;">Owned: ${ownedCount}</div>
            </div>
          </div>
          <button onclick="buyPowerUp('${powerupId}')" style="width: 100%; padding: 8px; border-radius: 8px; background: #10b981; color: white; font-weight: bold; cursor: pointer; border: none;">Buy Power-up</button>
        `;
        container.appendChild(item);
      });
    }
    
    function renderSkinsShop() {
      const container = document.getElementById('skins-container');
      container.innerHTML = '';
      
      Object.keys(skins).forEach(skinId => {
        const skin = skins[skinId];
        const isUnlocked = gameState.currentPlayer === 'white' 
          ? gameState.whiteUnlockedSkins.includes(skinId)
          : gameState.blackUnlockedSkins.includes(skinId);
        const isCurrent = gameState.currentPlayer === 'white'
          ? gameState.whiteCurrentSkin === skinId
          : gameState.blackCurrentSkin === skinId;
        
        const item = document.createElement('div');
        item.style.cssText = 'background: rgba(255,255,255,0.1); padding: 16px; border-radius: 12px; backdrop-filter: blur(10px);';
        item.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
            <div>
              <div style="font-weight: bold; color: #f1f5f9; font-size: 18px;">${skin.name}</div>
              <div style="color: #cbd5e1; font-size: 14px;">${isUnlocked ? (isCurrent ? 'Currently Equipped' : 'Owned') : 'Not Owned'}</div>
            </div>
            <div style="color: #f1f5f9; font-weight: bold; font-size: 16px;">ü™ô ${skin.cost}</div>
          </div>
          <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 4px; margin-bottom: 12px; text-center;">
            ${skin.white.map(piece => `<div style="font-size: 20px;">${piece}</div>`).join('')}
          </div>
          ${!isUnlocked ? `<button onclick="buySkin('${skinId}')" style="width: 100%; padding: 8px; border-radius: 8px; background: #9333ea; color: white; font-weight: bold; cursor: pointer; border: none;">Buy Skin</button>` : 
            (isCurrent ? '<button disabled style="width: 100%; padding: 8px; border-radius: 8px; background: #6b7280; color: white; font-weight: bold; cursor: not-allowed; border: none;">Currently Equipped</button>' :
            `<button onclick="equipSkin('${skinId}')" style="width: 100%; padding: 8px; border-radius: 8px; background: #3b82f6; color: white; font-weight: bold; cursor: pointer; border: none;">Equip Skin</button>`)}
        `;
        container.appendChild(item);
      });
    }
    
    function renderThemesShop() {
      const container = document.getElementById('themes-container');
      container.innerHTML = '';
      
      Object.keys(boardThemes).forEach(themeId => {
        const theme = boardThemes[themeId];
        const isUnlocked = gameState.unlockedThemes.includes(themeId);
        const isCurrent = gameState.currentTheme === themeId;
        
        const item = document.createElement('div');
        item.style.cssText = 'background: rgba(255,255,255,0.1); padding: 16px; border-radius: 12px; backdrop-filter: blur(10px);';
        item.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
            <div>
              <div style="font-weight: bold; color: #f1f5f9; font-size: 18px;">${theme.name}</div>
              <div style="color: #cbd5e1; font-size: 14px;">${isUnlocked ? (isCurrent ? 'Currently Equipped' : 'Owned') : 'Not Owned'}</div>
            </div>
            <div style="color: #f1f5f9; font-weight: bold; font-size: 16px;">ü™ô ${theme.cost}</div>
          </div>
          <div style="display: flex; gap: 8px; margin-bottom: 12px;">
            <div style="width: 40px; height: 40px; background: ${theme.light}; border-radius: 4px;"></div>
            <div style="width: 40px; height: 40px; background: ${theme.dark}; border-radius: 4px;"></div>
          </div>
          ${!isUnlocked ? `<button onclick="buyTheme('${themeId}')" style="width: 100%; padding: 8px; border-radius: 8px; background: #9333ea; color: white; font-weight: bold; cursor: pointer; border: none;">Buy Theme</button>` : 
            (isCurrent ? '<button disabled style="width: 100%; padding: 8px; border-radius: 8px; background: #6b7280; color: white; font-weight: bold; cursor: not-allowed; border: none;">Currently Equipped</button>' :
            `<button onclick="equipTheme('${themeId}')" style="width: 100%; padding: 8px; border-radius: 8px; background: #3b82f6; color: white; font-weight: bold; cursor: pointer; border: none;">Equip Theme</button>`)}
        `;
        container.appendChild(item);
      });
    }
    
    function renderEffectsShop() {
      const container = document.getElementById('effects-container');
      container.innerHTML = '';
      
      Object.keys(effects).forEach(effectId => {
        const effect = effects[effectId];
        const isPurchased = effect.purchased;
        const isCurrent = gameState.currentEffect === effectId;
        
        const item = document.createElement('div');
        item.style.cssText = 'background: rgba(255,255,255,0.1); padding: 16px; border-radius: 12px; backdrop-filter: blur(10px);';
        item.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
            <div>
              <div style="font-weight: bold; color: #f1f5f9; font-size: 18px;">${effect.name}</div>
              <div style="color: #cbd5e1; font-size: 14px;">${effect.description}</div>
              <div style="color: #cbd5e1; font-size: 12px;">${isPurchased ? (isCurrent ? 'Currently Equipped' : 'Owned') : 'Not Purchased'}</div>
            </div>
            <div style="color: #f1f5f9; font-weight: bold; font-size: 16px;">ü™ô ${effect.cost}</div>
          </div>
          ${!isPurchased ? `<button onclick="buyEffect('${effectId}')" style="width: 100%; padding: 8px; border-radius: 8px; background: #9333ea; color: white; font-weight: bold; cursor: pointer; border: none;">Buy Effect</button>` : 
            (isCurrent ? '<button disabled style="width: 100%; padding: 8px; border-radius: 8px; background: #6b7280; color: white; font-weight: bold; cursor: not-allowed; border: none;">Currently Equipped</button>' :
            `<button onclick="equipEffect('${effectId}')" style="width: 100%; padding: 8px; border-radius: 8px; background: #3b82f6; color: white; font-weight: bold; cursor: pointer; border: none;">Equip Effect</button>`)}
        `;
        container.appendChild(item);
      });
    }
    
    function renderSoundPacksShop() {
      const container = document.getElementById('soundpacks-container');
      container.innerHTML = '';
      
      Object.keys(soundPacks).forEach(soundPackId => {
        const soundPack = soundPacks[soundPackId];
        const isUnlocked = gameState.unlockedSoundPacks && gameState.unlockedSoundPacks.includes(soundPackId);
        const isCurrent = gameState.currentSoundPack === soundPackId;
        
        const item = document.createElement('div');
        item.style.cssText = `
          background: rgba(255,255,255,0.1); 
          padding: 16px; 
          border-radius: 12px; 
          backdrop-filter: blur(10px);
          border: 2px solid rgba(255,255,255,0.2);
        `;
        
        item.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
            <div>
              <div style="font-weight: bold; color: #f1f5f9; font-size: 18px;">${soundPack.name}</div>
              <div style="color: #cbd5e1; font-size: 14px;">${soundPack.description}</div>
            </div>
            <div style="color: #f1f5f9; font-weight: bold; font-size: 16px;">ü™ô ${soundPack.cost}</div>
          </div>
          ${!isUnlocked ? `<button onclick="buySoundPack('${soundPackId}')" style="width: 100%; padding: 8px; border-radius: 8px; background: #f59e0b; color: white; font-weight: bold; cursor: pointer; border: none;">Buy Sound Pack</button>` : 
            (isCurrent ? '<button disabled style="width: 100%; padding: 8px; border-radius: 8px; background: #6b7280; color: white; font-weight: bold; cursor: not-allowed; border: none;">Currently Equipped</button>' :
            `<button onclick="equipSoundPack('${soundPackId}')" style="width: 100%; padding: 8px; border-radius: 8px; background: #3b82f6; color: white; font-weight: bold; cursor: pointer; border: none;">Equip Sound Pack</button>`)}
        `;
        
        container.appendChild(item);
      });
    }
    
    // Shop purchase functions
    function buyPowerUp(powerupId) {
      playBuySound();
      const powerup = powerUpsData[powerupId];
      const currentCoins = getCurrentCoins();
      const currentPowerUps = gameState.currentPlayer === 'white' ? gameState.whitePowerUps : gameState.blackPowerUps;
      
      if (currentCoins >= powerup.cost) {
        // Check if player already has max 2 of this power-up
        if (currentPowerUps[powerupId] >= 2) {
          playErrorSound();
          safeAlert('Maximum of 2 power-ups per game reached!');
          return;
        }
        
        if (gameState.currentPlayer === 'white') {
          gameState.whiteCoins -= powerup.cost;
          gameState.whitePowerUps[powerupId]++;
        } else {
          gameState.blackCoins -= powerup.cost;
          gameState.blackPowerUps[powerupId]++;
        }
        document.getElementById('shop-coin-count').textContent = getCurrentCoins();
        renderShopItems();
        updatePowerUpButtons();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      } else {
        playErrorSound();
        safeAlert('Not enough coins!');
      }
    }
    
    function buySkin(skinId) {
      playBuySound();
      const skin = skins[skinId];
      const currentCoins = getCurrentCoins();
      
      if (currentCoins >= skin.cost) {
        if (gameState.currentPlayer === 'white') {
          if (!gameState.whiteUnlockedSkins.includes(skinId)) {
            gameState.whiteCoins -= skin.cost;
            gameState.whiteUnlockedSkins.push(skinId);
          }
        } else {
          if (!gameState.blackUnlockedSkins.includes(skinId)) {
            gameState.blackCoins -= skin.cost;
            gameState.blackUnlockedSkins.push(skinId);
          }
        }
        document.getElementById('shop-coin-count').textContent = getCurrentCoins();
        renderShopItems();
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      } else {
        playErrorSound();
        safeAlert('Not enough coins!');
      }
    }
    
    function buyTheme(themeId) {
      playBuySound();
      const theme = boardThemes[themeId];
      const currentCoins = getCurrentCoins();
      
      if (currentCoins >= theme.cost) {
        if (!gameState.unlockedThemes.includes(themeId)) {
          if (gameState.currentPlayer === 'white') {
            gameState.whiteCoins -= theme.cost;
          } else {
            gameState.blackCoins -= theme.cost;
          }
          gameState.unlockedThemes.push(themeId);
        }
        document.getElementById('shop-coin-count').textContent = getCurrentCoins();
        renderShopItems();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      } else {
        playErrorSound();
        safeAlert('Not enough coins!');
      }
    }
    
    function buyEffect(effectId) {
      playBuySound();
      const effect = effects[effectId];
      const currentCoins = getCurrentCoins();
      
      if (currentCoins >= effect.cost) {
        if (!effect.purchased) {
          if (gameState.currentPlayer === 'white') {
            gameState.whiteCoins -= effect.cost;
          } else {
            gameState.blackCoins -= effect.cost;
          }
          effect.purchased = true;
        }
        document.getElementById('shop-coin-count').textContent = getCurrentCoins();
        renderShopItems();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      } else {
        playErrorSound();
        safeAlert('Not enough coins!');
      }
    }
    
    function equipTheme(themeId) {
      gameState.currentTheme = themeId;
      renderBoard();
      renderShopItems();
      
      // Celebration for equipping new theme
      console.log('üé® Theme equipped confetti triggered:', themeId);
      createConfetti(document.body);
      showNotification(`üé® Theme "${boardThemes[themeId].name}" equipped!`);
      
      if (gameState.mode === 'online') {
        updateGameStateOnServer();
      }
    }
    
    function equipSkin(skinId) {
      if (gameState.currentPlayer === 'white') {
        gameState.whiteCurrentSkin = skinId;
      } else {
        gameState.blackCurrentSkin = skinId;
      }
      renderBoard();
      renderShopItems();
      
      // Celebration for equipping new skin
      console.log('üé≠ Skin equipped confetti triggered:', skinId);
      createConfetti(document.body);
      showNotification(`üé≠ Skin "${skins[skinId].name}" equipped!`);
      
      if (gameState.mode === 'online') {
        updateGameStateOnServer();
      }
    }
    
    function equipEffect(effectId) {
      gameState.currentEffect = effectId;
      renderBoard();
      renderShopItems();
      
      // Celebration for equipping new effect
      console.log('‚ú® Effect equipped confetti triggered:', effectId);
      createConfetti(document.body);
      showNotification(`‚ú® Effect "${effects[effectId].name}" equipped!`);
      
      if (gameState.mode === 'online') {
        updateGameStateOnServer();
      }
    }
    
    function buyEffect(effectId) {
      const effect = effects[effectId];
      const currentCoins = getCurrentCoins();
      
      if (currentCoins >= effect.cost && !effect.purchased) {
        if (gameState.currentPlayer === 'white') {
          gameState.whiteCoins -= effect.cost;
        } else {
          gameState.blackCoins -= effect.cost;
        }
        effect.purchased = true;
        
        document.getElementById('coin-count').textContent = getCurrentCoins();
        document.getElementById('shop-coin-count').textContent = getCurrentCoins();
        renderShopItems();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      } else {
        playErrorSound();
        alert('Not enough coins or already purchased!');
      }
    }
    
    function buyPowerUp(powerupId) {
      playBuySound();
      const powerUp = powerUpsData[powerupId];
      const currentCoins = getCurrentCoins();
      
      if (currentCoins >= powerUp.cost) {
        if (gameState.currentPlayer === 'white') {
          gameState.whiteCoins -= powerUp.cost;
          if (!gameState.whitePowerUps[powerupId]) {
            gameState.whitePowerUps[powerupId] = 0;
          }
          gameState.whitePowerUps[powerupId]++;
        } else {
          gameState.blackCoins -= powerUp.cost;
          if (!gameState.blackPowerUps[powerupId]) {
            gameState.blackPowerUps[powerupId] = 0;
          }
          gameState.blackPowerUps[powerupId]++;
        }
        document.getElementById('coin-count').textContent = getCurrentCoins();
        document.getElementById('shop-coin-count').textContent = getCurrentCoins();
        renderShopItems();
        updatePowerUpButtons();
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      } else {
        playErrorSound();
        alert('Not enough coins!');
      }
    }
    
    window.buySoundPack = function(soundPackId) {
      playBuySound();
      const soundPack = soundPacks[soundPackId];
      const currentCoins = getCurrentCoins();
      
      if (currentCoins >= soundPack.cost) {
        if (!gameState.unlockedSoundPacks.includes(soundPackId)) {
          if (gameState.currentPlayer === 'white') {
            gameState.whiteCoins -= soundPack.cost;
          } else {
            gameState.blackCoins -= soundPack.cost;
          }
          gameState.unlockedSoundPacks.push(soundPackId);
        }
        document.getElementById('shop-coin-count').textContent = getCurrentCoins();
        renderShopItems();
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
      } else {
        playErrorSound();
        safeAlert('Not enough coins!');
      }
    }
    
    window.equipSoundPack = function(soundPackId) {
      gameState.currentSoundPack = soundPackId;
      renderShopItems();
      
      // Celebration for equipping new sound pack
      console.log('üîä Sound pack equipped:', soundPackId);
      showNotification(`üîä Sound pack "${soundPacks[soundPackId].name}" equipped!`);
      
      if (gameState.mode === 'online') {
        updateGameStateOnServer();
      }
    }
    
    function closeShop() {
      document.getElementById('shop-modal').style.display = 'none';
    }
    
    function openHelp() {
      const modal = document.getElementById('help-modal');
      modal.style.display = 'block';
      modal.style.position = 'fixed';
      modal.style.top = '0';
      modal.style.left = '0';
      modal.style.width = '100%';
      modal.style.height = '100%';
      modal.style.zIndex = '2000';
      
      // Generate comprehensive skin key display
      generateSkinKeyDisplay();
      
      // Generate power-ups guide
      generatePowerUpsGuide();
    }
    
    function closeHelp() {
      document.getElementById('help-modal').style.display = 'none';
    }
    
    function toggleFullscreen() {
      // Check if we're in an iframe (Google Sites embedding)
      if (window.self !== window.top) {
        // We're in an iframe, use maximized mode instead
        toggleMaximizedMode();
      } else {
        // We're not in an iframe, use real fullscreen
        if (!document.fullscreenElement) {
          // Enter fullscreen
          const elem = document.documentElement;
          if (elem.requestFullscreen) {
            elem.requestFullscreen();
          } else if (elem.webkitRequestFullscreen) { /* Safari */
            elem.webkitRequestFullscreen();
          } else if (elem.msRequestFullscreen) { /* IE11 */
            elem.msRequestFullscreen();
          }
          
          // Update button text
          document.getElementById('fullscreen-btn').innerHTML = ' üñ•Ô∏è Exit Fullscreen';
        } else {
          // Exit fullscreen
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) { /* Safari */
            document.webkitExitFullscreen();
          } else if (document.msExitFullscreen) { /* IE11 */
            document.msExitFullscreen();
          }
          
          // Update button text
          document.getElementById('fullscreen-btn').innerHTML = ' üñ•Ô∏è Fullscreen';
        }
      }
    }
    
    function toggleMaximizedMode() {
      const appWrapper = document.getElementById('app-wrapper');
      const isMaximized = appWrapper.classList.contains('maximized-mode');
      
      if (!isMaximized) {
        // Enter maximized mode
        appWrapper.classList.add('maximized-mode');
        document.body.style.margin = '0';
        document.body.style.padding = '0';
        document.body.style.overflow = 'hidden';
        appWrapper.style.position = 'fixed';
        appWrapper.style.top = '0';
        appWrapper.style.left = '0';
        appWrapper.style.width = '100vw';
        appWrapper.style.height = '100vh';
        appWrapper.style.zIndex = '9999';
        
        // Update button text
        document.getElementById('fullscreen-btn').innerHTML = ' üñ•Ô∏è Exit Maximized';
        
        // Show notification
        showNotification('üñ•Ô∏è Maximized mode activated! Scroll to see all content.');
      } else {
        // Exit maximized mode
        appWrapper.classList.remove('maximized-mode');
        document.body.style.margin = '';
        document.body.style.padding = '';
        document.body.style.overflow = '';
        appWrapper.style.position = '';
        appWrapper.style.top = '';
        appWrapper.style.left = '';
        appWrapper.style.width = '';
        appWrapper.style.height = '';
        appWrapper.style.zIndex = '';
        
        // Update button text
        document.getElementById('fullscreen-btn').innerHTML = ' üñ•Ô∏è Maximize';
        
        // Show notification
        showNotification('üñ•Ô∏è Exited maximized mode');
      }
    }
    
    function showNotification(message) {
      // Create notification element
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #10b981;
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        font-weight: bold;
        z-index: 10000;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        animation: slideIn 0.3s ease;
      `;
      notification.textContent = message;
      
      // Add to page
      document.body.appendChild(notification);
      
      // Remove after 3 seconds
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 3000);
    }
    
    function generateSkinKeyDisplay() {
      const container = document.getElementById('skin-key-display');
      container.innerHTML = '';
      
      const pieceNames = ['King', 'Queen', 'Rook', 'Bishop', 'Knight', 'Pawn'];
      
      Object.keys(skins).forEach(skinId => {
        const skin = skins[skinId];
        const isWhiteCurrent = gameState.whiteCurrentSkin === skinId;
        const isBlackCurrent = gameState.blackCurrentSkin === skinId;
        
        const skinCard = document.createElement('div');
        skinCard.style.cssText = 'background: rgba(255,255,255,0.1); padding: 16px; border-radius: 12px; backdrop-filter: blur(10px);';
        
        let skinHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
            <div style="font-weight: bold; color: #f1f5f9; font-size: 18px;">${skin.name}</div>
            <div style="font-size: 12px; color: #cbd5e1;">
              ${isWhiteCurrent ? '‚ö™ White' : ''}${isBlackCurrent ? '‚ö´ Black' : ''}
            </div>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
            <div>
              <div style="font-weight: bold; color: #f1f5f9; margin-bottom: 8px; text-align: center;">‚ö™ White Pieces</div>
              <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 4px; text-align: center;">
        `;
        
        // Add white pieces
        skin.white.forEach((piece, index) => {
          skinHTML += `<div style="font-size: 24px; padding: 4px; border-radius: 4px; background: rgba(255,255,255,0.1);">${piece}</div>`;
        });
        
        skinHTML += `
              </div>
              <div style="font-size: 10px; color: #94a3b8; text-align: center; margin-top: 4px;">
                ${pieceNames.join(' ‚Ä¢ ')}
              </div>
            </div>
            <div>
              <div style="font-weight: bold; color: #f1f5f9; margin-bottom: 8px; text-align: center;">‚ö´ Black Pieces</div>
              <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 4px; text-align: center;">
        `;
        
        // Add black pieces
        skin.black.forEach((piece, index) => {
          skinHTML += `<div style="font-size: 24px; padding: 4px; border-radius: 4px; background: rgba(0,0,0,0.2);">${piece}</div>`;
        });
        
        skinHTML += `
              </div>
              <div style="font-size: 10px; color: #94a3b8; text-align: center; margin-top: 4px;">
                ${pieceNames.join(' ‚Ä¢ ')}
              </div>
            </div>
          </div>
        `;
        
        skinCard.innerHTML = skinHTML;
        container.appendChild(skinCard);
      });
    }
    
    function generatePowerUpsGuide() {
      const container = document.getElementById('powerups-guide');
      container.innerHTML = '';
      
      Object.keys(powerUpsData).forEach(powerupId => {
        const powerup = powerUpsData[powerupId];
        
        const guideItem = document.createElement('div');
        guideItem.style.cssText = 'background: rgba(255,255,255,0.05); padding: 12px; border-radius: 8px; border-left: 4px solid #3b82f6;';
        
        guideItem.innerHTML = `
          <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
            <span style="font-size: 24px;">${powerup.icon}</span>
            <div>
              <div style="font-weight: bold; color: #f1f5f9; font-size: 14px;">${powerup.name}</div>
              <div style="color: #cbd5e1; font-size: 12px; margin-top: 2px;">${powerup.description}</div>
            </div>
          </div>
          <div style="font-size: 12px; color: #10b981; font-weight: bold;">ü™ô Cost: ${powerup.cost}</div>
        `;
        
        container.appendChild(guideItem);
      });
    }
    
    function openAdminLogin() {
      const modal = document.getElementById('admin-login-modal');
      modal.style.display = 'block';
      modal.style.position = 'fixed';
      modal.style.top = '0';
      modal.style.left = '0';
      modal.style.width = '100%';
      modal.style.height = '100%';
      modal.style.zIndex = '2000';
      document.getElementById('admin-password').value = '';
      document.getElementById('login-error').style.display = 'none';
    }
    
    function closeAdminLogin() {
      document.getElementById('admin-login-modal').style.display = 'none';
    }
    
    function openAdminPanel() {
      document.getElementById('admin-panel-modal').style.display = 'block';
      document.getElementById('admin-panel-modal').style.position = 'fixed';
      document.getElementById('admin-panel-modal').style.top = '0';
      document.getElementById('admin-panel-modal').style.left = '0';
      document.getElementById('admin-panel-modal').style.width = '100%';
      document.getElementById('admin-panel-modal').style.height = '100%';
      document.getElementById('admin-panel-modal').style.zIndex = '2000';
      
      // Reset previous data to ensure first render works
      previousGamesData = null;
      
      // Start auto-sync for real-time updates
      startAdminSync();
      
      // Load current config into admin panel
      document.getElementById('storage-provider').value = ONLINE_STORAGE_CONFIG.provider || 'jsonbin';
      document.getElementById('admin-jsonbin-key').value = ONLINE_STORAGE_CONFIG.jsonbinApiKey || '';
      document.getElementById('admin-spreadsheet-id').value = ONLINE_STORAGE_CONFIG.googlesheets.spreadsheetId || '';
      document.getElementById('admin-api-key').value = ONLINE_STORAGE_CONFIG.googlesheets.apiKey || '';
      document.getElementById('admin-config-status').textContent = '';
      
      // Load public games into admin panel
      loadAdminPublicGames();
      
      // Show/hide appropriate config sections
      const jsonbinConfig = document.getElementById('jsonbin-config');
      const googlesheetsConfig = document.getElementById('googlesheets-config');
      
      if (ONLINE_STORAGE_CONFIG.provider === 'jsonbin') {
        jsonbinConfig.style.display = 'grid';
        googlesheetsConfig.style.display = 'none';
      } else if (ONLINE_STORAGE_CONFIG.provider === 'googlesheets') {
        jsonbinConfig.style.display = 'none';
        googlesheetsConfig.style.display = 'grid';
      }
      
      renderActiveGames();
    }
    
    function closeAdminPanel() {
      // Stop auto-sync when panel closes
      stopAdminSync();
      document.getElementById('admin-panel-modal').style.display = 'none';
    }
    
    // Store previous games data to prevent unnecessary re-renders
    let previousGamesData = null;
    
    function renderActiveGames() {
      const container = document.getElementById('active-games-list');
      
      // Fetch latest games
      onlineStorageHandler.getAll().then(games => {
        // Create a hash of the current games data to compare with previous
        const currentGamesHash = JSON.stringify(games.map(g => ({
          room_code: g.room_code,
          game_over: g.game_over,
          guest_player: g.guest_player,
          current_player: g.current_player,
          last_update: g.last_update
        })));
        
        // If data hasn't changed, don't re-render
        if (previousGamesData === currentGamesHash) {
          return;
        }
        
        previousGamesData = currentGamesHash;
        
        container.innerHTML = '';
        
        if (games.length === 0) {
          container.innerHTML = '<div style="text-align: center; color: #94a3b8; padding: 20px;">No active games</div>';
          return;
        }
        
        const now = Date.now();
        const fiveMinutesMs = 5 * 60 * 1000; // 5 minutes in milliseconds
        
        games.forEach(game => {
          // Auto-cleanup finished games older than 5 minutes
          if ((game.game_over === 'true' || game.game_over === true) && 
              (now - new Date(game.last_update).getTime()) > fiveMinutesMs) {
            console.log(`Auto-cleaning up old finished game: ${game.room_code}`);
            
            // Delete the old game
            onlineStorageHandler.delete(game.room_code).then(deleteResult => {
              if (deleteResult.isOk) {
                console.log(`Successfully cleaned up game: ${game.room_code}`);
                // Refresh the games list after cleanup
                setTimeout(() => renderActiveGames(), 1000);
              } else {
                console.error(`Failed to clean up game ${game.room_code}:`, deleteResult.error);
              }
            }).catch(error => {
              console.error(`Error cleaning up game ${game.room_code}:`, error);
            });
            
            // Don't render this game since it's being cleaned up
            return;
          }
          
          const gameCard = document.createElement('div');
          gameCard.style.cssText = 'background: rgba(255,255,255,0.05); padding: 16px; border-radius: 8px; margin-bottom: 12px;';
          
          const header = document.createElement('div');
          header.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;';
          
          const roomCode = document.createElement('div');
          roomCode.style.cssText = 'font-size: 18px; font-weight: bold; color: #f1f5f9; font-family: monospace;';
          roomCode.textContent = game.room_code;
          
          const status = document.createElement('div');
          status.style.cssText = 'padding: 4px 12px; border-radius: 6px; font-size: 12px; font-weight: bold;';
          if (game.game_over === 'true' || game.game_over === true) {
            status.textContent = 'Finished';
            status.style.background = '#ef4444';
            status.style.color = '#ffffff';
          } else if (game.guest_player) {
            status.textContent = 'In Progress';
            status.style.background = '#10b981';
            status.style.color = '#ffffff';
          } else {
            status.textContent = 'Waiting';
            status.style.background = '#f59e0b';
            status.style.color = '#ffffff';
          }
          
          header.appendChild(roomCode);
          header.appendChild(status);
          
          const players = document.createElement('div');
          players.style.cssText = 'color: #cbd5e1; font-size: 14px; margin-bottom: 8px;';
          players.textContent = `‚ö™ ${game.host_player} vs ${game.guest_player || 'Waiting...'} ‚ö´`;
          
          const turn = document.createElement('div');
          turn.style.cssText = 'color: #94a3b8; font-size: 12px;';
          const turnEmoji = game.current_player === 'white' ? '‚ö™' : '‚ö´';
          turn.textContent = `${turnEmoji} ${game.current_player}'s turn`;
          
          const lastUpdate = document.createElement('div');
          lastUpdate.style.cssText = 'color: #64748b; font-size: 11px; margin-top: 4px;';
          const updateTime = new Date(game.last_update).toLocaleString();
          lastUpdate.textContent = `Last updated: ${updateTime}`;
          
          // Add End Game button for active games
          if (game.game_over !== 'true' && game.game_over !== true) {
            const endGameBtn = document.createElement('button');
            endGameBtn.textContent = 'üî¥ End Game';
            endGameBtn.style.cssText = 'width: 100%; padding: 8px; border-radius: 6px; background: #ef4444; color: white; font-weight: bold; cursor: pointer; border: none; margin-top: 8px; font-size: 12px;';
            endGameBtn.onclick = () => endAdminGame(game.room_code);
            gameCard.appendChild(endGameBtn);
          }
          
          gameCard.appendChild(header);
          gameCard.appendChild(players);
          gameCard.appendChild(turn);
          gameCard.appendChild(lastUpdate);
          container.appendChild(gameCard);
        });
      }).catch(error => {
        console.error('Error fetching games:', error);
        container.innerHTML = '<div style="text-align: center; color: #ef4444; padding: 20px;">Error loading games</div>';
      });
    }
    
    function endAdminGame(roomCode) {
      if (confirm(`üî¥ End Game ${roomCode}? This will force-end the game and disconnect all players.`)) {
        console.log(`Admin ending game: ${roomCode}`);
        
        // Mark game as over and add admin termination flag
        onlineStorageHandler.update(roomCode, { 
          game_over: true,
          admin_terminated: true,
          termination_message: 'Game terminated by administrator',
          terminated_at: Date.now()
        }).then(result => {
          if (result.isOk) {
            alert(`‚úÖ Game ${roomCode} has been ended and all players have been kicked.`);
            // Refresh the games list
            renderActiveGames();
            
            // If admin is currently in this game, kick them out too
            if (gameState.roomCode === roomCode) {
              console.log('Admin was in the game being ended, kicking them out...');
              gameState.gameOver = true;
              gameState.mode = null;
              gameState.roomCode = null;
              gameState.playerName = null;
              gameState.opponentName = null;
              gameState.currentGameRecord = null;
              
              // Show game over screen
              document.getElementById('game-area').style.display = 'none';
              document.getElementById('mode-selection').style.display = 'flex';
              document.getElementById('multiplayer-status').style.display = 'none';
              
              // Show notification
              alert(`üî¥ Game ${roomCode} has been terminated by administrator.`);
              
              // Reset game state
              resetGame();
            }
          } else {
            alert(`‚ùå Failed to end game: ${result.error}`);
          }
        }).catch(error => {
          console.error('Error ending game:', error);
          alert(`‚ùå Error ending game: ${error.message}`);
        });
      }
    }
    
    // Auto-sync for admin panel
    let adminSyncInterval = null;
    
    function startAdminSync() {
      if (adminSyncInterval) {
        clearInterval(adminSyncInterval);
      }
      // Sync every 2 seconds
      adminSyncInterval = setInterval(() => {
        if (document.getElementById('admin-panel-modal').style.display === 'block') {
          renderActiveGames();
        }
      }, 2000);
    }
    
    function stopAdminSync() {
      if (adminSyncInterval) {
        clearInterval(adminSyncInterval);
        adminSyncInterval = null;
      }
    }
    
    // Admin Public Games Management Functions
    function loadAdminPublicGames() {
      console.log('üîç Loading public games for admin panel...');
      
      // Load games from localStorage for consistency with public lobby
      try {
        const storedGames = localStorage.getItem('publicGames');
        if (storedGames) {
          publicGames = JSON.parse(storedGames);
          console.log('üîç Admin loaded', publicGames.length, 'games from localStorage');
        } else {
          publicGames = [];
          console.log('üîç No games in localStorage for admin panel');
        }
      } catch (error) {
        console.error('üîç Admin panel error loading games from localStorage:', error);
        publicGames = [];
      }
      
      renderAdminPublicGames();
    }
    
    function renderAdminPublicGames() {
      const gamesList = document.getElementById('admin-public-games-list');
      
      if (publicGames.length === 0) {
        gamesList.innerHTML = '<div style="text-align: center; color: #94a3b8; padding: 20px;">No public games available</div>';
        return;
      }
      
      gamesList.innerHTML = '';
      publicGames.forEach(game => {
        const gameDiv = document.createElement('div');
        gameDiv.style.cssText = 'background: rgba(255,255,255,0.1); padding: 12px; border-radius: 8px; margin-bottom: 8px;';
        gameDiv.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
              <div style="color: white; font-weight: bold;">${game.name}</div>
              <div style="color: rgba(255,255,255,0.7); font-size: 12px;">ID: ${game.id} ‚Ä¢ Host: ${game.host} ‚Ä¢ ${game.powerups ? '‚ö° Power-ups' : '‚ôüÔ∏è Classic'} ‚Ä¢ ${game.players}</div>
            </div>
            <button onclick="closePublicGame('${game.id}')" style="padding: 6px 12px; border-radius: 4px; border: none; background: #ef4444; color: white; font-weight: bold; cursor: pointer; font-size: 12px;">‚ùå Close</button>
          </div>
        `;
        gamesList.appendChild(gameDiv);
      });
    }
    
    function closePublicGame(gameId) {
      const gameIndex = publicGames.findIndex(g => g.id === gameId);
      if (gameIndex !== -1) {
        const gameName = publicGames[gameIndex].name;
        publicGames.splice(gameIndex, 1);
        
        // Save to localStorage to keep admin panel and public lobby in sync
        savePublicGamesToStorage();
        
        renderAdminPublicGames();
        renderPublicGames(); // Also update the public lobby
        console.log(`üîí Closed public game: ${gameName}`);
        alert(`Public game "${gameName}" has been closed and removed from the lobby.`);
      }
    }
    
    function closeAllPublicGames() {
      if (publicGames.length === 0) {
        alert('No public games to close.');
        return;
      }
      
      if (confirm(`Are you sure you want to close ALL ${publicGames.length} public games? This will remove them from the lobby.`)) {
        const gameCount = publicGames.length;
        publicGames = [];
        
        // Save to localStorage to keep admin panel and public lobby in sync
        savePublicGamesToStorage();
        
        renderAdminPublicGames();
        renderPublicGames(); // Also update the public lobby
        console.log(`üîí Closed all ${gameCount} public games`);
        alert(`All ${gameCount} public games have been closed and removed from the lobby.`);
      }
    }
    
    function clearEmptyPublicGames() {
      const emptyGames = publicGames.filter(g => g.players === '0/2');
      if (emptyGames.length === 0) {
        alert('No empty games to clear.');
        return;
      }
      
      const count = emptyGames.length;
      publicGames = publicGames.filter(g => g.players !== '0/2');
      
      // Save to localStorage to keep admin panel and public lobby in sync
      savePublicGamesToStorage();
      
      renderAdminPublicGames();
      renderPublicGames(); // Also update the public lobby
      console.log(`üßπ Cleared ${count} empty public games`);
      alert(`${count} empty public games have been removed from the lobby.`);
    }
    
    // Make functions globally available
    window.closePublicGame = closePublicGame;
    window.closeAllPublicGames = closeAllPublicGames;
    window.clearEmptyPublicGames = clearEmptyPublicGames;
    
    // Manual Save Functions
    function showSaveStatus(message, isSuccess = true) {
      const statusDiv = document.getElementById('save-status');
      statusDiv.textContent = message;
      statusDiv.style.display = 'block';
      statusDiv.style.background = isSuccess ? 'rgba(16, 185, 129, 0.2)' : 'rgba(239, 68, 68, 0.2)';
      statusDiv.style.color = isSuccess ? '#10b981' : '#ef4444';
      
      setTimeout(() => {
        statusDiv.style.display = 'none';
      }, 3000);
    }
    
    function forceSaveAllData() {
      console.log('=== FORCE SAVE INITIATED ===');
      
      try {
        // Create comprehensive save data
        const completeSaveData = {
          // Game state
          whiteCoins: gameState.whiteCoins,
          blackCoins: gameState.blackCoins,
          whiteUnlockedSkins: gameState.whiteUnlockedSkins,
          blackUnlockedSkins: gameState.blackUnlockedSkins,
          whiteCurrentSkin: gameState.whiteCurrentSkin,
          blackCurrentSkin: gameState.blackCurrentSkin,
          unlockedThemes: gameState.unlockedThemes,
          currentTheme: gameState.currentTheme,
          currentEffect: gameState.currentEffect,
          purchasedEffects: Object.keys(effects).filter(effectId => effects[effectId].purchased),
          whitePowerUps: gameState.whitePowerUps,
          blackPowerUps: gameState.blackPowerUps,
          totalGamesPlayed: gameState.totalGamesPlayed || 0,
          totalWins: gameState.totalWins || 0,
          
          // Sound packs data
          unlockedSoundPacks: gameState.unlockedSoundPacks || ['classic'],
          currentSoundPack: gameState.currentSoundPack || 'classic',
          
          // Metadata
          saveTimestamp: new Date().toISOString(),
          saveVersion: '2.0',
          forceSave: true
        };
        
        // Save to localStorage
        localStorage.setItem('chessPlayerProgress', JSON.stringify(completeSaveData));
        
        // Also save a backup
        localStorage.setItem('chessPlayerProgress_Backup', JSON.stringify(completeSaveData));
        
        console.log('Force save data:', completeSaveData);
        console.log('Data saved to localStorage and backup');
        
        showSaveStatus('‚úÖ All data saved successfully!', true);
        
      } catch (error) {
        console.error('Force save failed:', error);
        showSaveStatus('‚ùå Save failed: ' + error.message, false);
      }
      
      console.log('=== FORCE SAVE COMPLETE ===');
    }
    
    function forceLoadAllData() {
      console.log('=== FORCE LOAD INITIATED ===');
      
      try {
        // Try to load from main storage first
        let savedData = localStorage.getItem('chessPlayerProgress');
        
        // If main storage fails, try backup
        if (!savedData) {
          savedData = localStorage.getItem('chessPlayerProgress_Backup');
          console.log('Loading from backup storage');
        }
        
        if (!savedData) {
          showSaveStatus('‚ùå No saved data found', false);
          console.log('No saved data found');
          return;
        }
        
        const playerData = JSON.parse(savedData);
        console.log('Loaded data:', playerData);
        
        // Load all data
        gameState.whiteCoins = playerData.whiteCoins || 0;
        gameState.blackCoins = playerData.blackCoins || 0;
        gameState.whiteUnlockedSkins = playerData.whiteUnlockedSkins || ['default'];
        gameState.blackUnlockedSkins = playerData.blackUnlockedSkins || ['default'];
        gameState.whiteCurrentSkin = playerData.whiteCurrentSkin || 'default';
        gameState.blackCurrentSkin = playerData.blackCurrentSkin || 'default';
        gameState.unlockedThemes = playerData.unlockedThemes || ['classic'];
        gameState.currentTheme = playerData.currentTheme || 'classic';
        gameState.currentEffect = playerData.currentEffect || null;
        gameState.totalGamesPlayed = playerData.totalGamesPlayed || 0;
        gameState.totalWins = playerData.totalWins || 0;
        
        // Load sound packs data
        gameState.unlockedSoundPacks = playerData.unlockedSoundPacks || ['classic'];
        gameState.currentSoundPack = playerData.currentSoundPack || 'classic';
        
        // Load effects
        if (playerData.purchasedEffects) {
          playerData.purchasedEffects.forEach(effectId => {
            if (effects[effectId]) {
              effects[effectId].purchased = true;
            }
          });
        }
        
        // Load power-ups with all 29 power-ups
        const defaultPowerUps = {
          undo: 0, hint: 0, shield: 0, double_coins: 0, freeze: 0,
          knight_boost: 0, vision: 0, swap: 0, bomb: 0, time_warp: 0,
          lightning: 0, heal: 0, clone: 0, magnet: 0, poison: 0,
          shield_wall: 0, speed_boost: 0, invisibility: 0, earthquake: 0,
          blizzard: 0, laser: 0, mirror: 0, tornado: 0, gravity: 0,
          phoenix: 0, time_freeze: 0, coin_rain: 0, power_steal: 0,
          mega_bomb: 0, royal_guard: 0, lucky_charm: 0, chaos: 0
        };
        
        gameState.whitePowerUps = playerData.whitePowerUps || defaultPowerUps;
        gameState.blackPowerUps = playerData.blackPowerUps || defaultPowerUps;
        
        // Ensure all power-ups exist
        Object.keys(defaultPowerUps).forEach(powerupId => {
          if (gameState.whitePowerUps[powerupId] === undefined) {
            gameState.whitePowerUps[powerupId] = defaultPowerUps[powerupId];
          }
          if (gameState.blackPowerUps[powerupId] === undefined) {
            gameState.blackPowerUps[powerupId] = defaultPowerUps[powerupId];
          }
        });
        
        // Apply 2-max limit
        Object.keys(gameState.whitePowerUps).forEach(powerupId => {
          if (gameState.whitePowerUps[powerupId] > 2) {
            gameState.whitePowerUps[powerupId] = 2;
          }
        });
        
        Object.keys(gameState.blackPowerUps).forEach(powerupId => {
          if (gameState.blackPowerUps[powerupId] > 2) {
            gameState.blackPowerUps[powerupId] = 2;
          }
        });
        
        // Update UI
        updatePowerUpButtons();
        document.getElementById('coin-count').textContent = getCurrentCoins();
        renderBoard();
        
        console.log('Force load completed');
        showSaveStatus('‚úÖ All data loaded successfully!', true);
        
      } catch (error) {
        console.error('Force load failed:', error);
        showSaveStatus('‚ùå Load failed: ' + error.message, false);
      }
      
      console.log('=== FORCE LOAD COMPLETE ===');
    }
    
    function clearAllLocalData() {
      if (confirm('‚ö†Ô∏è Are you sure you want to delete ALL local data? This cannot be undone!')) {
        console.log('=== CLEARING ALL LOCAL DATA ===');
        
        try {
          // Clear all game-related localStorage items
          const itemsToClear = [
            'chessPlayerProgress',
            'chessPlayerProgress_Backup',
            'storageProvider',
            'firebaseApiKey',
            'firebaseDatabaseURL',
            'jsonbinApiKey',
            'spreadsheetId',
            'apiKey',
            'setupCompleted'
          ];
          
          itemsToClear.forEach(item => {
            localStorage.removeItem(item);
            console.log('Cleared:', item);
          });
          
          // Reset game state to defaults
          gameState.whiteCoins = 0;
          gameState.blackCoins = 0;
          gameState.whiteUnlockedSkins = ['default'];
          gameState.blackUnlockedSkins = ['default'];
          gameState.whiteCurrentSkin = 'default';
          gameState.blackCurrentSkin = 'default';
          gameState.unlockedThemes = ['classic'];
          gameState.currentTheme = 'classic';
          gameState.currentEffect = null;
          
          // Reset power-ups to defaults
          const defaultPowerUps = {
            undo: 0, hint: 0, shield: 0, double_coins: 0, freeze: 0,
            knight_boost: 0, vision: 0, swap: 0, bomb: 0, time_warp: 0,
            lightning: 0, heal: 0, clone: 0, magnet: 0, poison: 0,
            shield_wall: 0, speed_boost: 0, invisibility: 0, earthquake: 0,
            blizzard: 0, laser: 0, mirror: 0, tornado: 0, gravity: 0,
            phoenix: 0, time_freeze: 0, coin_rain: 0, power_steal: 0,
            mega_bomb: 0, royal_guard: 0, lucky_charm: 0, chaos: 0
          };
          
          gameState.whitePowerUps = {...defaultPowerUps};
          gameState.blackPowerUps = {...defaultPowerUps};
          
          // Update UI
          updatePowerUpButtons();
          document.getElementById('coin-count').textContent = getCurrentCoins();
          renderBoard();
          
          console.log('All local data cleared');
          showSaveStatus('‚úÖ All local data cleared successfully!', true);
          
        } catch (error) {
          console.error('Clear data failed:', error);
          showSaveStatus('‚ùå Clear failed: ' + error.message, false);
        }
        
        console.log('=== CLEAR DATA COMPLETE ===');
      }
    }
    document.getElementById('clear-storage-btn').addEventListener('click', () => {
      playButtonSound();
      clearAllLocalData();
    });
    
    document.getElementById('force-save-btn').addEventListener('click', () => {
      playButtonSound();
      forceSaveAllData();
    });
    
    document.getElementById('force-load-btn').addEventListener('click', () => {
      playButtonSound();
      forceLoadAllData();
    });
    
    // Admin Panel Public Games Management Event Listeners
    document.getElementById('admin-refresh-public-games-btn').addEventListener('click', () => {
      playButtonSound();
      loadAdminPublicGames();
    });
    
    document.getElementById('admin-close-all-games-btn').addEventListener('click', () => {
      playButtonSound();
      if (confirm('Are you sure you want to close ALL public games? This will remove them from the lobby.')) {
        closeAllPublicGames();
      }
    });
    
    document.getElementById('admin-clear-empty-games-btn').addEventListener('click', () => {
      playButtonSound();
      clearEmptyPublicGames();
    });
    
    // Sound functions
    function playGameStartSound() {
      // Simple sound effect for game start
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
      oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
      oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G5
      
      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.5);
    }
    
    function playRoomCreatedSound() {
      // Sound effect for room creation - ascending tone
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // A4
      oscillator.frequency.setValueAtTime(554.37, audioContext.currentTime + 0.1); // C#5
      oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.2); // E5
      
      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.4);
    }
    
    function playRoomJoinedSound() {
      // Sound effect for joining room - welcoming tone
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
      oscillator.frequency.setValueAtTime(587.33, audioContext.currentTime + 0.1); // D5
      oscillator.frequency.setValueAtTime(698.46, audioContext.currentTime + 0.2); // F5
      
      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.4);
    }
    
    function generateDynamicSound(settings) {
      try {
        const audioContext = initializeAudioContext();
        if (!audioContext) {
          console.log('Audio context not available, skipping sound');
          return;
        }
        
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.type = settings.type || 'sine';
        oscillator.frequency.setValueAtTime(settings.frequency || 440, audioContext.currentTime);
        
        gainNode.gain.setValueAtTime(settings.volume || 0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + (settings.duration || 0.1));
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + (settings.duration || 0.1));
      } catch (e) {
        console.log('Dynamic sound generation error:', e);
      }
    }
    
    function initializeAudioContext() {
      if (!window.audioContext) {
        try {
          window.audioContext = new (window.AudioContext || window.webkitAudioContext());
        } catch (e) {
          console.log('Audio context not supported');
          return null;
        }
      }
      
      // Resume context if suspended (for Chrome autoplay policy)
      if (window.audioContext.state === 'suspended') {
        window.audioContext.resume();
      }
      
      // Load saved audio settings
      loadAudioSettings();
      
      return window.audioContext;
    }
    
    function loadAudioSettings() {
      try {
        const savedSettings = localStorage.getItem('audioSettings');
        if (savedSettings) {
          const settings = JSON.parse(savedSettings);
          window.audioSettings = { ...window.audioSettings, ...settings };
          console.log('Loaded audio settings:', settings);
        }
      } catch (e) {
        console.log('Failed to load audio settings:', e);
      }
    }
    
    function saveAudioSettings() {
      try {
        if (window.audioSettings) {
          localStorage.setItem('audioSettings', JSON.stringify(window.audioSettings));
          console.log('Saved audio settings:', window.audioSettings);
        }
      } catch (e) {
        console.log('Failed to save audio settings:', e);
      }
    }
    
    function playButtonSound() {
      // Simple click sound for buttons
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.05);
      
      gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.1);
    }
    
    function playModalCloseSound() {
      // Soft closing sound for modals
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.1);
      
      gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.15);
    }
    
    function playMoveSound() {
      // Soft piece movement sound
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // A4
      oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime + 0.05); // C5
      
      gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.2);
    }
    
    function playCaptureSound() {
      // Sharp capture sound
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.setValueAtTime(300, audioContext.currentTime); // D4
      oscillator.frequency.setValueAtTime(200, audioContext.currentTime + 0.05); // G3
      
      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.3);
    }
    
    function playPromotionSound() {
      // Celebratory promotion sound
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
      oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
      oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G5
      oscillator.frequency.setValueAtTime(1046.50, audioContext.currentTime + 0.3); // C6
      
      gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.6);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.6);
    }
    
    function playGameOverSound() {
      // Dramatic game over sound
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // A4
      oscillator.frequency.exponentialRampToValueAtTime(220, audioContext.currentTime + 0.5); // A3
      
      gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 1);
    }
    
    function playErrorSound() {
      // Error buzz sound
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.setValueAtTime(150, audioContext.currentTime); // D3
      oscillator.frequency.setValueAtTime(100, audioContext.currentTime + 0.1); // G2
      
      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.2);
    }
    
    function playIntroSound() {
      // Epic intro sound - majestic chord progression
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      // Create multiple oscillators for a rich chord
      const oscillators = [];
      const gainNode = audioContext.createGain();
      
      // Root chord frequencies (C major 7th)
      const frequencies = [130.81, 164.81, 196.00, 246.94]; // C3, E3, G3, B3
      
      frequencies.forEach((freq, index) => {
        const osc = audioContext.createOscillator();
        const oscGain = audioContext.createGain();
        
        osc.connect(oscGain);
        oscGain.connect(gainNode);
        
        osc.frequency.setValueAtTime(freq, audioContext.currentTime);
        oscGain.gain.setValueAtTime(0.15, audioContext.currentTime);
        oscGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 2);
        
        // Stagger the start times for a dramatic effect
        osc.start(audioContext.currentTime + index * 0.1);
        osc.stop(audioContext.currentTime + 2);
        
        oscillators.push(osc);
      });
      
      // Add a majestic sweep
      const sweepOsc = audioContext.createOscillator();
      const sweepGain = audioContext.createGain();
      
      sweepOsc.connect(sweepGain);
      sweepGain.connect(gainNode);
      
      sweepOsc.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
      sweepOsc.frequency.exponentialRampToValueAtTime(261.63, audioContext.currentTime + 1.5); // C4
      
      sweepGain.gain.setValueAtTime(0, audioContext.currentTime);
      sweepGain.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.2);
      sweepGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1.8);
      
      sweepOsc.start(audioContext.currentTime);
      sweepOsc.stop(audioContext.currentTime + 2);
      
      gainNode.connect(audioContext.destination);
    }
    
    // Quick setup event listeners
    document.getElementById('use-firebase-btn').addEventListener('click', () => {
      playButtonSound();
      // Use your Firebase configuration
      localStorage.setItem('storageProvider', 'firebase');
      localStorage.setItem('firebaseApiKey', 'AIzaSyDxajp6LvXTbYZn6RW0k7nx3z0Ua4MjK7o');
      localStorage.setItem('firebaseDatabaseURL', 'https://my-chess-game-105dd-default-rtdb.firebaseio.com/');
      
      closeQuickSetup();
      localStorage.setItem('setupCompleted', 'true');
      alert('‚úÖ Setup complete! You can now play online multiplayer with your Firebase.');
    });
    
    document.getElementById('skip-setup-btn').addEventListener('click', () => {
      playButtonSound();
      closeQuickSetup();
      localStorage.setItem('setupCompleted', 'true');
      alert('‚úÖ You can play offline. For online multiplayer, click the Admin button to configure storage later.');
    });
    
    // Check if setup is needed on first load
    function checkSetupNeeded() {
      const hasConfig = (ONLINE_STORAGE_CONFIG.provider === 'jsonbin' && ONLINE_STORAGE_CONFIG.jsonbinApiKey && ONLINE_STORAGE_CONFIG.jsonbinApiKey !== '$2a$10$81lmfosn./Fikva0/TALFeSEvtW0fJir1ftqZpP.x3CVHnF01aaNW') ||
                       (ONLINE_STORAGE_CONFIG.provider === 'googlesheets' && ONLINE_STORAGE_CONFIG.googlesheets.spreadsheetId && ONLINE_STORAGE_CONFIG.googlesheets.apiKey);
      
      if (!hasConfig && !localStorage.getItem('setupCompleted')) {
        setTimeout(() => {
          showQuickSetup();
        }, 1000);
      }
    }
    
    // Update All Games function
    document.getElementById('update-all-games-btn').addEventListener('click', async () => {
      const newVersion = document.getElementById('update-version').value.trim();
      const statusDiv = document.getElementById('update-status');
      
      if (!newVersion) {
        statusDiv.textContent = '‚ùå Please enter a version number';
        statusDiv.style.color = '#ef4444';
        return;
      }
      
      statusDiv.textContent = 'üîÑ Updating all games...';
      statusDiv.style.color = '#f59e0b';
      
      try {
        // Update Firebase with new version
        if (firebaseDatabase) {
          await firebaseDatabase.ref('gameVersion').set(newVersion);
          console.log('‚úÖ Updated Firebase version to:', newVersion);
        }
        
        // Send update notification to all active games
        if (allGameRecords && allGameRecords.length > 0) {
          let updatedCount = 0;
          
          for (const game of allGameRecords) {
            try {
              // Add update notification to game state
              const updateNotification = {
                type: 'system_update',
                version: newVersion,
                timestamp: Date.now(),
                message: `üîÑ Game update available! Version ${newVersion} is ready.`
              };
              
              // Update the game record with update notification
              await onlineStorageHandler.update(game.id, {
                ...game,
                system_update: updateNotification,
                last_update: Date.now()
              });
              
              updatedCount++;
            } catch (error) {
              console.error('Failed to update game:', game.id, error);
            }
          }
          
          statusDiv.textContent = `‚úÖ Successfully updated ${updatedCount} games to version ${newVersion}`;
          statusDiv.style.color = '#10b981';
          
          // Show success notification
          showNotification(`üéâ Updated ${updatedCount} games to version ${newVersion}!`);
        } else {
          statusDiv.textContent = `‚úÖ Version updated to ${newVersion}. No active games to notify.`;
          statusDiv.style.color = '#10b981';
        }
        
        // Update local version as well
        localStorage.setItem('chessGameVersion', newVersion);
        
      } catch (error) {
        console.error('Error updating games:', error);
        statusDiv.textContent = `‚ùå Error: ${error.message}`;
        statusDiv.style.color = '#ef4444';
      }
    });
    
    // Admin panel config save
    document.getElementById('admin-save-config-btn').addEventListener('click', async () => {
      const provider = document.getElementById('storage-provider').value;
      const firebaseApiKey = document.getElementById('admin-firebase-api-key').value.trim();
      const firebaseDatabaseURL = document.getElementById('admin-firebase-database-url').value.trim();
      const jsonbinKey = document.getElementById('admin-jsonbin-key').value.trim();
      const spreadsheetId = document.getElementById('admin-spreadsheet-id').value.trim();
      const apiKey = document.getElementById('admin-api-key').value.trim();
      
      // Validate based on provider
      if (provider === 'firebase' && (!firebaseApiKey || !firebaseDatabaseURL)) {
        document.getElementById('admin-config-status').textContent = 'Please fill in all Firebase fields';
        document.getElementById('admin-config-status').style.color = '#ef4444';
        return;
      }
      
      if (provider === 'jsonbin' && !jsonbinKey) {
        document.getElementById('admin-config-status').textContent = 'Please enter JSONBin API key';
        document.getElementById('admin-config-status').style.color = '#ef4444';
        return;
      }
      
      if (provider === 'googlesheets' && (!spreadsheetId || !apiKey)) {
        document.getElementById('admin-config-status').textContent = 'Please fill in all Google Sheets fields';
        document.getElementById('admin-config-status').style.color = '#ef4444';
        return;
      }
      
      // Save configuration
      ONLINE_STORAGE_CONFIG.provider = provider;
      localStorage.setItem('storageProvider', provider);
      
      if (provider === 'firebase') {
        console.log('Saving Firebase configuration...');
        console.log('API Key:', firebaseApiKey);
        console.log('Database URL:', firebaseDatabaseURL);
        
        ONLINE_STORAGE_CONFIG.firebase.apiKey = firebaseApiKey;
        ONLINE_STORAGE_CONFIG.firebase.databaseURL = firebaseDatabaseURL;
        
        localStorage.setItem('firebaseApiKey', firebaseApiKey);
        localStorage.setItem('firebaseDatabaseURL', firebaseDatabaseURL);
        
        console.log('Firebase config saved:', ONLINE_STORAGE_CONFIG.firebase);
        
        // Test Firebase connection
        document.getElementById('admin-config-status').textContent = 'Testing Firebase connection...';
        document.getElementById('admin-config-status').style.color = '#f59e0b';
        
        try {
          const success = await initOnlineStorage();
          if (success) {
            document.getElementById('admin-config-status').textContent = '‚úì Firebase configuration saved and verified!';
            document.getElementById('admin-config-status').style.color = '#10b981';
            // Update the global provider setting
            ONLINE_STORAGE_CONFIG.provider = 'firebase';
          } else {
            document.getElementById('admin-config-status').textContent = '‚ö† Saved but verification failed. Check Firebase settings.';
            document.getElementById('admin-config-status').style.color = '#f59e0b';
          }
        } catch (error) {
          document.getElementById('admin-config-status').textContent = '‚úó Firebase connection failed. Check API key and URL.';
          document.getElementById('admin-config-status').style.color = '#ef4444';
          console.error('Firebase configuration error:', error);
        }
      } else if (provider === 'jsonbin') {
        ONLINE_STORAGE_CONFIG.jsonbinApiKey = jsonbinKey;
        localStorage.setItem('jsonbinApiKey', jsonbinKey);
        
        // Test JSONBin connection
        document.getElementById('admin-config-status').textContent = 'Testing JSONBin connection...';
        document.getElementById('admin-config-status').style.color = '#f59e0b';
        
        try {
          const success = await initOnlineStorage();
          if (success) {
            document.getElementById('admin-config-status').textContent = '‚úì JSONBin configuration saved and verified!';
            document.getElementById('admin-config-status').style.color = '#10b981';
          } else {
            document.getElementById('admin-config-status').textContent = '‚ö† Saved but verification failed. Check API key.';
            document.getElementById('admin-config-status').style.color = '#f59e0b';
          }
        } catch (error) {
          document.getElementById('admin-config-status').textContent = '‚úó JSONBin connection failed. Check API key.';
          document.getElementById('admin-config-status').style.color = '#ef4444';
          console.error('JSONBin configuration error:', error);
        }
      } else if (provider === 'googlesheets') {
        ONLINE_STORAGE_CONFIG.googlesheets.spreadsheetId = spreadsheetId;
        ONLINE_STORAGE_CONFIG.googlesheets.apiKey = apiKey;
        
        localStorage.setItem('spreadsheetId', spreadsheetId);
        localStorage.setItem('apiKey', apiKey);
        
        // Test Google Sheets connection
        document.getElementById('admin-config-status').textContent = 'Testing Google Sheets connection...';
        document.getElementById('admin-config-status').style.color = '#f59e0b';
        
        try {
          const success = await initOnlineStorage();
          if (success) {
            document.getElementById('admin-config-status').textContent = '‚úì Google Sheets configuration saved and verified!';
            document.getElementById('admin-config-status').style.color = '#10b981';
          } else {
            document.getElementById('admin-config-status').textContent = '‚ö† Saved but verification failed. Check console for details.';
            document.getElementById('admin-config-status').style.color = '#f59e0b';
          }
        } catch (error) {
          let errorMsg = error.message || 'Unknown error';
          
          if (errorMsg.includes('Sheet "ChessGames" not found')) {
            errorMsg = '‚ö† Sheet "ChessGames" not found. Please create it manually (see instructions).';
            document.getElementById('admin-config-status').style.color = '#f59e0b';
          } else if (errorMsg.includes('Spreadsheet not found')) {
            errorMsg = '‚úó Spreadsheet not found. Check ID and sharing settings.';
            document.getElementById('admin-config-status').style.color = '#ef4444';
          } else if (errorMsg.includes('Access denied')) {
            errorMsg = '‚úó Access denied. Share spreadsheet with "Anyone with link" can EDIT.';
            document.getElementById('admin-config-status').style.color = '#ef4444';
          } else if (errorMsg.includes('CREDENTIALS_MISSING') || errorMsg.includes('credentials missing') || errorMsg.includes('Authentication failed') || errorMsg.includes('UNAUTHENTICATED')) {
            errorMsg = '‚úó Credentials missing or invalid. Make sure:\n1. API key is correct and Google Sheets API is enabled\n2. Spreadsheet is shared with "Anyone with link" can EDIT\n3. Check console for details';
            document.getElementById('admin-config-status').style.color = '#ef4444';
          } else {
            document.getElementById('admin-config-status').style.color = '#ef4444';
          }
          
          document.getElementById('admin-config-status').textContent = errorMsg;
          console.error('Google Sheets configuration error:', error);
        }
      }
    });
    
    // Storage provider change handler
    document.getElementById('storage-provider').addEventListener('change', (e) => {
      const provider = e.target.value;
      const firebaseConfig = document.getElementById('firebase-config');
      const jsonbinConfig = document.getElementById('jsonbin-config');
      const googlesheetsConfig = document.getElementById('googlesheets-config');
      
      if (provider === 'firebase') {
        firebaseConfig.style.display = 'grid';
        jsonbinConfig.style.display = 'none';
        googlesheetsConfig.style.display = 'none';
      } else if (provider === 'jsonbin') {
        firebaseConfig.style.display = 'none';
        jsonbinConfig.style.display = 'grid';
        googlesheetsConfig.style.display = 'none';
      } else if (provider === 'googlesheets') {
        firebaseConfig.style.display = 'none';
        jsonbinConfig.style.display = 'none';
        googlesheetsConfig.style.display = 'grid';
      }
    });
    
    document.getElementById('admin-setup-instructions-btn').addEventListener('click', () => {
      playButtonSound();
      createNewSheet();
    });
    
    document.getElementById('add-coins-btn').addEventListener('click', () => {
      playButtonSound();
      const amount = parseInt(document.getElementById('coin-amount').value) || 100;
      if (gameState.currentPlayer === 'white') {
        gameState.whiteCoins += amount;
      } else {
        gameState.blackCoins += amount;
      }
      document.getElementById('coin-count').textContent = getCurrentCoins();
      
      // Save progress locally
      savePlayerProgress();
      
      if (gameState.mode === 'online') {
        updateGameStateOnServer();
      }
    });
    
    document.getElementById('reset-coins-btn').addEventListener('click', () => {
      playButtonSound();
      gameState.whiteCoins = 0;
      gameState.blackCoins = 0;
      document.getElementById('coin-count').textContent = getCurrentCoins();
      
      // Save progress locally
      savePlayerProgress();
      
      if (gameState.mode === 'online') {
        updateGameStateOnServer();
      }
    });
    
    document.getElementById('unlock-skins-btn').addEventListener('click', () => {
      playButtonSound();
      Object.keys(skins).forEach(skinId => {
        if (!gameState.whiteUnlockedSkins.includes(skinId)) {
          gameState.whiteUnlockedSkins.push(skinId);
        }
        if (!gameState.blackUnlockedSkins.includes(skinId)) {
          gameState.blackUnlockedSkins.push(skinId);
        }
      });
      renderBoard();
      
      // Save progress locally
      savePlayerProgress();
      
      if (gameState.mode === 'online') {
        updateGameStateOnServer();
      }
    });
    
    document.getElementById('unlock-themes-btn').addEventListener('click', () => {
      playButtonSound();
      Object.keys(boardThemes).forEach(themeId => {
        if (!gameState.unlockedThemes.includes(themeId)) {
          gameState.unlockedThemes.push(themeId);
        }
      });
      renderBoard();
      
      // Save progress locally
      savePlayerProgress();
      
      if (gameState.mode === 'online') {
        updateGameStateOnServer();
      }
    });
    
    document.getElementById('unlock-effects-btn').addEventListener('click', () => {
      playButtonSound();
      Object.keys(effects).forEach(effectId => {
        effects[effectId].purchased = true;
      });
      
      // Save progress locally
      savePlayerProgress();
      
      if (gameState.mode === 'online') {
        updateGameStateOnServer();
      }
    });
    
    document.getElementById('unlock-all-btn').addEventListener('click', () => {
      playButtonSound();
      // Unlock all skins
      Object.keys(skins).forEach(skinId => {
        if (!gameState.whiteUnlockedSkins.includes(skinId)) {
          gameState.whiteUnlockedSkins.push(skinId);
        }
        if (!gameState.blackUnlockedSkins.includes(skinId)) {
          gameState.blackUnlockedSkins.push(skinId);
        }
      });
      
      // Unlock all themes
      Object.keys(boardThemes).forEach(themeId => {
        if (!gameState.unlockedThemes.includes(themeId)) {
          gameState.unlockedThemes.push(themeId);
        }
      });
      
      // Unlock all effects
      Object.keys(effects).forEach(effectId => {
        effects[effectId].purchased = true;
      });
      
      // Unlock all sound packs
      Object.keys(soundPacks).forEach(soundPackId => {
        if (!gameState.unlockedSoundPacks.includes(soundPackId)) {
          gameState.unlockedSoundPacks.push(soundPackId);
        }
      });
      
      // Unlock all bundles
      Object.keys(bundlePacks).forEach(bundleId => {
        if (!gameState.unlockedBundles.includes(bundleId)) {
          gameState.unlockedBundles.push(bundleId);
        }
      });
      
      // Add lots of coins
      gameState.whiteCoins = 9999;
      gameState.blackCoins = 9999;
      document.getElementById('coin-count').textContent = getCurrentCoins();
      
      // Add power-ups
      Object.keys(powerUpsData).forEach(powerupId => {
        gameState.whitePowerUps[powerupId] = 5;
        gameState.blackPowerUps[powerupId] = 5;
      });
      
      updatePowerUpButtons();
      renderShopItems(); // Update shop to show unlocked sound packs
      
      // Save progress locally
      savePlayerProgress();
      
      safeAlert('EVERYTHING UNLOCKED! üéâüéäüéà');
    });
    
    document.getElementById('reset-btn').addEventListener('click', () => {
      playButtonSound();
      playIntroSoundOnce(); // Play intro sound on first interaction
      resetGame();
    });
    
    document.getElementById('back-home-btn').addEventListener('click', () => {
      playButtonSound();
      // Return to mode selection
      document.getElementById('game-area').style.display = 'none';
      document.getElementById('mode-selection').style.display = 'flex';
      
      // Clear game state
      gameState.mode = 'local';
      gameState.roomCode = null;
      gameState.playerRole = null;
      gameState.playerName = null;
      gameState.opponentName = null;
      gameState.currentGameRecord = null;
      
      // Show power-ups section and toggle button again
      const powerupsSection = document.getElementById('powerups-section');
      if (powerupsSection) {
        powerupsSection.style.display = 'flex';
      }
      const toggleBtn = document.getElementById('toggle-powerups-btn');
      if (toggleBtn) {
        toggleBtn.style.display = 'block';
        // Reset toggle button state
        toggleBtn.textContent = '‚öîÔ∏è Hide Power-ups';
        toggleBtn.style.background = '#ef4444';
        powerupsVisible = true;
      }
      
      // Hide multiplayer status
      document.getElementById('multiplayer-status').style.display = 'none';
    });
    
    document.getElementById('end-game-btn').addEventListener('click', () => {
      playButtonSound();
      safeConfirm('üî¥ End Game? This will disconnect you from the online game and return to the main menu.', (confirmed) => {
        if (confirmed) {
          // Stop data sync and clean up Firebase listeners
          stopDataSync();
          
          // Reset game state
          resetGame();
          
          // Hide End Game button
          document.getElementById('end-game-btn').style.display = 'none';
          
          // Return to mode selection
          document.getElementById('game-area').style.display = 'none';
          document.getElementById('mode-selection').style.display = 'flex';
          
          // Clear online game state
          gameState.mode = 'local';
          gameState.roomCode = null;
          gameState.playerRole = null;
          gameState.playerName = null;
          gameState.opponentName = null;
          gameState.currentGameRecord = null;
          
          // Remove from global lobby if it's a public game
          if (gameState.game_mode === 'public' && gameState.roomCode) {
            console.log('üî• Ending public game, removing from lobby:', gameState.roomCode);
            removeGlobalGame(gameState.roomCode).then(result => {
              if (result.isOk) {
                console.log('‚úÖ Public game successfully removed from lobby');
              } else {
                console.error('‚ùå Failed to remove public game from lobby:', result.error);
              }
            });
          }
          
          // Reset game mode
          gameState.game_mode = null;
          
          // Show power-ups section and toggle button again
          const powerupsSection = document.getElementById('powerups-section');
          if (powerupsSection) {
            powerupsSection.style.display = 'flex';
          }
          const toggleBtn = document.getElementById('toggle-powerups-btn');
          if (toggleBtn) {
            toggleBtn.style.display = 'block';
            // Reset toggle button state
            toggleBtn.textContent = '‚öîÔ∏è Hide Power-ups';
            toggleBtn.style.background = '#ef4444';
            powerupsVisible = true;
          }
          
          // Hide multiplayer status
          document.getElementById('multiplayer-status').style.display = 'none';
          
          console.log('Online game ended and cleaned up');
        }
      });
    });
    
    document.getElementById('shop-btn').addEventListener('click', () => {
      playButtonSound();
      openShop();
    });
    document.getElementById('close-shop').addEventListener('click', () => {
      playModalCloseSound();
      closeShop();
    });
    document.getElementById('undo-btn').addEventListener('click', useUndo);
    document.getElementById('hint-btn').addEventListener('click', useHint);
    document.getElementById('shield-btn').addEventListener('click', useShield);
    document.getElementById('double-coins-btn').addEventListener('click', useDoubleCoins);
    document.getElementById('freeze-btn').addEventListener('click', useFreeze);
    document.getElementById('knight-boost-btn').addEventListener('click', useKnightBoost);
    document.getElementById('vision-btn').addEventListener('click', useVision);
    document.getElementById('swap-btn').addEventListener('click', useSwap);
    document.getElementById('bomb-btn').addEventListener('click', useBomb);
    document.getElementById('time-warp-btn').addEventListener('click', useTimeWarp);
    
    // NEW POWER-UP EVENT LISTENERS
    document.getElementById('lightning-btn').addEventListener('click', useLightning);
    document.getElementById('heal-btn').addEventListener('click', useHeal);
    document.getElementById('clone-btn').addEventListener('click', useClone);
    document.getElementById('magnet-btn').addEventListener('click', useMagnet);
    document.getElementById('poison-btn').addEventListener('click', usePoison);
    document.getElementById('shield-wall-btn').addEventListener('click', useShieldWall);
    document.getElementById('speed-boost-btn').addEventListener('click', useSpeedBoost);
    document.getElementById('invisibility-btn').addEventListener('click', useInvisibility);
    document.getElementById('earthquake-btn').addEventListener('click', useEarthquake);
    document.getElementById('blizzard-btn').addEventListener('click', useBlizzard);
    document.getElementById('laser-btn').addEventListener('click', useLaser);
    document.getElementById('mirror-btn').addEventListener('click', useMirror);
    document.getElementById('tornado-btn').addEventListener('click', useTornado);
    document.getElementById('gravity-btn').addEventListener('click', useGravity);
    document.getElementById('phoenix-btn').addEventListener('click', usePhoenix);
    document.getElementById('time-freeze-btn').addEventListener('click', useFreeze);
    document.getElementById('coin-rain-btn').addEventListener('click', useCoinRain);
    document.getElementById('power-steal-btn').addEventListener('click', usePowerSteal);
    document.getElementById('mega-bomb-btn').addEventListener('click', useMegaBomb);
    document.getElementById('royal-guard-btn').addEventListener('click', useRoyalGuard);
    document.getElementById('lucky-charm-btn').addEventListener('click', useLuckyCharm);
    document.getElementById('chaos-btn').addEventListener('click', useChaos);
    
    // Timer event listeners
    document.getElementById('start-timer-btn').addEventListener('click', () => {
      playButtonSound();
      startTimer();
    });
    document.getElementById('pause-timer-btn').addEventListener('click', () => {
      playButtonSound();
      pauseTimer();
    });
    document.getElementById('reset-timer-btn').addEventListener('click', () => {
      playButtonSound();
      resetTimer();
    });
    
    // Chat event listeners
    document.getElementById('send-chat-btn').addEventListener('click', () => {
      sendChatMessage();
    });
    document.getElementById('chat-input').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        sendChatMessage();
      }
    });
    document.getElementById('toggle-chat-btn').addEventListener('click', () => {
      playButtonSound();
      toggleChatSize();
    });
    
    document.getElementById('help-btn').addEventListener('click', () => {
      playButtonSound();
      openHelp();
    });
    document.getElementById('close-help').addEventListener('click', () => {
      playModalCloseSound();
      closeHelp();
    });
    
    document.getElementById('fullscreen-btn').addEventListener('click', () => {
      playButtonSound();
      toggleFullscreen();
    });
    
    document.getElementById('admin-btn').addEventListener('click', () => {
      playButtonSound();
      openAdminLogin();
    });
    document.getElementById('close-admin-login').addEventListener('click', () => {
      playModalCloseSound();
      closeAdminLogin();
    });
    document.getElementById('close-admin-panel').addEventListener('click', () => {
      playModalCloseSound();
      closeAdminPanel();
    });
    
    document.getElementById('admin-login-form').addEventListener('submit', (e) => {
      e.preventDefault();
      const password = document.getElementById('admin-password').value;
      
      if (password === ADMIN_PASSWORD) {
        closeAdminLogin();
        openAdminPanel();
      } else {
        const errorDiv = document.getElementById('login-error');
        errorDiv.style.display = 'block';
        const passwordInput = document.getElementById('admin-password');
        passwordInput.classList.add('shake-animation');
        setTimeout(() => passwordInput.classList.remove('shake-animation'), 500);
      }
    });
    
    document.getElementById('refresh-games-btn').addEventListener('click', () => {
      loadPublicGames();
      renderPublicGames();
    });
    
    // Public lobby modal event listeners
    document.getElementById('close-public-lobby-btn').addEventListener('click', () => {
      playModalCloseSound();
      document.getElementById('public-lobby-modal').style.display = 'none';
    });
    
    // Power-ups toggle buttons for public game creation
    document.getElementById('create-powerups-on-btn').addEventListener('click', () => {
      document.getElementById('create-powerups-on-btn').style.background = '#10b981';
      document.getElementById('create-powerups-off-btn').style.background = '#ef4444';
    });
    
    document.getElementById('create-powerups-off-btn').addEventListener('click', () => {
      document.getElementById('create-powerups-off-btn').style.background = '#10b981';
      document.getElementById('create-powerups-on-btn').style.background = '#ef4444';
    });
    
    // Chat functionality
    document.getElementById('send-chat-btn').addEventListener('click', sendChatMessage);
    document.getElementById('chat-input').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        sendChatMessage();
      }
    });
    
    function sendChatMessage() {
      const chatInput = document.getElementById('chat-input');
      const message = chatInput.value.trim();
      
      if (!message) return;
      
      const playerName = gameState.playerName || 'Player';
      const timestamp = new Date().toLocaleTimeString();
      
      // Add message to local chat
      const chatMessage = {
        player: playerName,
        message: message,
        timestamp: timestamp
      };
      
      if (!gameState.chatMessages) {
        gameState.chatMessages = [];
      }
      
      gameState.chatMessages.push(chatMessage);
      
      // Keep only last 50 messages
      if (gameState.chatMessages.length > 50) {
        gameState.chatMessages = gameState.chatMessages.slice(-50);
      }
      
      // Render chat messages
      renderChatMessages();
      
      // Clear input
      chatInput.value = '';
      
      // Send to server if in online game
      if (gameState.mode === 'online' && gameState.roomCode) {
        updateGameStateOnServer();
      }
      
      playButtonSound();
    }
    
    function renderChatMessages() {
      const chatMessagesDiv = document.getElementById('chat-messages');
      
      if (!gameState.chatMessages || gameState.chatMessages.length === 0) {
        chatMessagesDiv.innerHTML = '<div style="color: #64748b; font-style: italic;">Chat messages will appear here...</div>';
        return;
      }
      
      const messagesHtml = gameState.chatMessages.map(msg => {
        const isCurrentPlayer = msg.player === gameState.playerName;
        const playerColor = isCurrentPlayer ? '#3b82f6' : '#10b981';
        
        return `
          <div style="margin-bottom: 8px; padding: 6px 8px; border-radius: 6px; background: rgba(255,255,255,0.05);">
            <span style="color: ${playerColor}; font-weight: bold; font-size: 12px;">${msg.player}:</span>
            <span style="color: #f1f5f9; font-size: 14px; margin-left: 4px;">${msg.message}</span>
            <span style="color: #64748b; font-size: 10px; margin-left: 8px;">${msg.timestamp}</span>
          </div>
        `;
      }).join('');
      
      chatMessagesDiv.innerHTML = messagesHtml;
      
      // Scroll to bottom
      const chatContainer = document.getElementById('chat-container');
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }
    
    // Start button event listener with cool animation
    document.getElementById('start-btn').addEventListener('click', () => {
      // Play welcome sound
      playWelcomeSound();
      
      // Create cool animation
      createStartAnimation();
      
      // Show mode selection after animation
      setTimeout(() => {
        document.getElementById('welcome-screen').style.display = 'none';
        document.getElementById('app-wrapper').style.display = 'block';
        document.getElementById('mode-selection').style.display = 'flex';
      }, 1500);
    });

    function createStartAnimation() {
      const startBtn = document.getElementById('start-btn');
      
      // Add explosion effect
      createExplosionEffect(startBtn);
      
      // Add screen shake
      document.body.style.animation = 'shake 0.5s';
      setTimeout(() => {
        document.body.style.animation = '';
      }, 500);
      
      // Add flash effect
      const flash = document.createElement('div');
      flash.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(circle, rgba(102, 126, 234, 0.8) 0%, transparent 70%);
        z-index: 9999;
        pointer-events: none;
        animation: flash 1s ease-out forwards;
      `;
      document.body.appendChild(flash);
      setTimeout(() => flash.remove(), 1000);
      
      // Add floating chess pieces
      createFloatingPieces();
    }

    function createExplosionEffect(element) {
      const rect = element.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      
      // Create explosion particles
      for (let i = 0; i < 20; i++) {
        const particle = document.createElement('div');
        particle.textContent = ['‚ö°', 'üí•', '‚ú®', 'üåü', 'üéÜ', 'üí´', 'üî•', '‚≠ê'][Math.floor(Math.random() * 8)];
        particle.style.cssText = `
          position: fixed;
          left: ${centerX}px;
          top: ${centerY}px;
          font-size: ${20 + Math.random() * 20}px;
          z-index: 9998;
          pointer-events: none;
          animation: explode ${0.8 + Math.random() * 0.4}s ease-out forwards;
          --tx: ${(Math.random() - 0.5) * 300}px;
          --ty: ${(Math.random() - 0.5) * 300}px;
        `;
        document.body.appendChild(particle);
        setTimeout(() => particle.remove(), 1200);
      }
    }

    function createFloatingPieces() {
      const pieces = ['‚ôî', '‚ôï', '‚ôñ', '‚ôó', '‚ôò', '‚ôô', '‚ôö', '‚ôõ', '‚ôú', '‚ôù', '‚ôû', '‚ôü'];
      
      for (let i = 0; i < 12; i++) {
        const piece = document.createElement('div');
        piece.textContent = pieces[i];
        piece.style.cssText = `
          position: fixed;
          left: ${Math.random() * window.innerWidth}px;
          top: ${window.innerHeight + 50}px;
          font-size: ${30 + Math.random() * 20}px;
          z-index: 9997;
          pointer-events: none;
          animation: float ${3 + Math.random() * 2}s ease-in-out;
          opacity: 0.8;
        `;
        document.body.appendChild(piece);
        setTimeout(() => piece.remove(), 5000);
      }
    }

    // CSS animations for start button effects and power-ups
    const style = document.createElement('style');
    style.textContent = `
      @keyframes explode {
        0% {
          transform: translate(0, 0) scale(1);
          opacity: 1;
        }
        100% {
          transform: translate(var(--tx), var(--ty)) scale(0);
          opacity: 0;
        }
      }
      
      @keyframes flash {
        0% {
          opacity: 0;
        }
        50% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }
      
      @keyframes float {
        0% {
          transform: translateY(0) rotate(0deg);
        }
        50% {
          transform: translateY(-200px) rotate(180deg);
        }
        100% {
          transform: translateY(-400px) rotate(360deg);
          opacity: 0;
        }
      }
      
      // Power-up animations
      @keyframes lightningStrike {
        0% {
          transform: scale(0) rotate(0deg);
          opacity: 0;
          filter: brightness(0);
        }
        50% {
          transform: scale(1.5) rotate(180deg);
          opacity: 1;
          filter: brightness(2) hue-rotate(180deg);
        }
        100% {
          transform: scale(0) rotate(360deg);
          opacity: 0;
          filter: brightness(0);
        }
      }
      
      @keyframes lightningFlash {
        0% {
          opacity: 0;
          filter: brightness(1);
        }
        10% {
          opacity: 1;
          filter: brightness(2);
        }
        20% {
          opacity: 0.8;
          filter: brightness(1.5);
        }
        30% {
          opacity: 1;
          filter: brightness(3);
        }
        40% {
          opacity: 0.6;
          filter: brightness(1.2);
        }
        50% {
          opacity: 1;
          filter: brightness(2.5);
        }
        60% {
          opacity: 0.4;
          filter: brightness(1.1);
        }
        70% {
          opacity: 0.8;
          filter: brightness(1.8);
        }
        80% {
          opacity: 0.3;
          filter: brightness(1.1);
        }
        90% {
          opacity: 0.6;
          filter: brightness(1.4);
        }
        100% {
          opacity: 0;
          filter: brightness(1);
        }
      }
      
      @keyframes megaBombExplosion {
        0% {
          transform: scale(0);
          opacity: 1;
          box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7);
        }
        50% {
          transform: scale(2);
          opacity: 0.8;
          box-shadow: 0 0 20px 10px rgba(255, 0, 0, 0);
        }
        100% {
          transform: scale(3);
          opacity: 0;
          box-shadow: 0 0 40px 20px rgba(255, 0, 0, 0);
        }
      }
      
      @keyframes laserBeam {
        0% {
          transform: scaleX(0);
          opacity: 0;
          background: linear-gradient(90deg, transparent, #ff0000, transparent);
        }
        20% {
          transform: scaleX(1);
          opacity: 1;
        }
        80% {
          transform: scaleX(1);
          opacity: 1;
        }
        100% {
          transform: scaleX(0);
          opacity: 0;
        }
      }
      
      @keyframes tornadoSpin {
        0% {
          transform: rotate(0deg) scale(0.5);
          opacity: 0;
        }
        25% {
          transform: rotate(180deg) scale(0.8) translateX(-10px) translateY(-10px);
          opacity: 0.8;
          filter: brightness(1.2) hue-rotate(30deg);
        }
        50% {
          transform: rotate(360deg) scale(1.2) translateX(-20px) translateY(-20px);
          opacity: 1;
          filter: brightness(1.5) hue-rotate(60deg);
        }
        75% {
          transform: rotate(540deg) scale(0.8) translateX(10px) translateY(-30px);
          opacity: 0.6;
          filter: brightness(1.3) hue-rotate(90deg);
        }
        100% {
          transform: rotate(720deg) scale(0.2) translateX(0) translateY(-40px);
          opacity: 0;
          filter: brightness(1) hue-rotate(120deg);
        }
      }
      
      @keyframes bombDrop {
        0% {
          transform: translateY(-100px) scale(0.5);
          opacity: 0;
        }
        50% {
          transform: translateY(0) scale(1.2);
          opacity: 1;
        }
        100% {
          transform: translateY(10px) scale(0.8);
          opacity: 0;
        }
      }
      
      @keyframes fuseSpark {
        0%, 100% {
          transform: translateX(-50%) scale(1);
          opacity: 1;
          filter: brightness(1);
        }
        25% {
          transform: translateX(-50%) scale(1.3);
          opacity: 0.8;
          filter: brightness(1.5);
        }
        50% {
          transform: translateX(-50%) scale(0.8);
          opacity: 1;
          filter: brightness(2);
        }
        75% {
          transform: translateX(-50%) scale(1.2);
          opacity: 0.9;
          filter: brightness(1.3);
        }
      }
      
      @keyframes shockwaveExpand {
        0% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 1;
        }
        100% {
          transform: translate(-50%, -50%) scale(8);
          opacity: 0;
        }
      }
      
      @keyframes shieldActivate {
        0% {
          transform: scale(0);
          opacity: 0;
          border: 0px solid rgba(0, 255, 255, 0);
        }
        50% {
          transform: scale(1.2);
          opacity: 1;
          border: 5px solid rgba(0, 255, 255, 0.8);
        }
        100% {
          transform: scale(1);
          opacity: 0.5;
          border: 2px solid rgba(0, 255, 255, 0.4);
        }
      }
      
      @keyframes freezeEffect {
        0% {
          filter: hue-rotate(0deg) brightness(1);
          transform: scale(1);
        }
        50% {
          filter: hue-rotate(180deg) brightness(1.5);
          transform: scale(1.05);
        }
        100% {
          filter: hue-rotate(240deg) brightness(0.8);
          transform: scale(1);
        }
      }
      
      @keyframes healPulse {
        0% {
          transform: scale(0);
          opacity: 0;
          box-shadow: 0 0 0 0 rgba(0, 255, 0, 0.7);
        }
        50% {
          transform: scale(1.2);
          opacity: 1;
          box-shadow: 0 0 20px 10px rgba(0, 255, 0, 0);
        }
        100% {
          transform: scale(1);
          opacity: 0;
          box-shadow: 0 0 30px 15px rgba(0, 255, 0, 0);
        }
      }
      
      @keyframes cloneEffect {
        0% {
          transform: scale(0) rotate(0deg);
          opacity: 0;
        }
        50% {
          transform: scale(1.1) rotate(180deg);
          opacity: 0.7;
        }
        100% {
          transform: scale(1) rotate(360deg);
          opacity: 1;
        }
      }
      
      @keyframes magnetPull {
        0% {
          transform: translate(0, 0);
          opacity: 1;
        }
        25% {
          transform: translate(-10px, -10px);
        }
        50% {
          transform: translate(10px, 10px);
        }
        75% {
          transform: translate(-5px, -5px);
        }
        100% {
          transform: translate(0, 0);
        }
      }
      
      @keyframes poisonSpread {
        0% {
          transform: scale(0);
          opacity: 0;
          filter: hue-rotate(0deg);
        }
        50% {
          transform: scale(1.5);
          opacity: 1;
          filter: hue-rotate(120deg) brightness(0.7);
        }
        100% {
          transform: scale(2);
          opacity: 0;
          filter: hue-rotate(240deg) brightness(0.5);
        }
      }
      
      @keyframes timeWarp {
        0% {
          transform: scale(1) rotate(0deg);
          opacity: 1;
          filter: hue-rotate(0deg);
        }
        25% {
          transform: scale(0.8) rotate(90deg);
          filter: hue-rotate(90deg);
        }
        50% {
          transform: scale(1.2) rotate(180deg);
          filter: hue-rotate(180deg);
        }
        75% {
          transform: scale(0.9) rotate(270deg);
          filter: hue-rotate(270deg);
        }
        100% {
          transform: scale(1) rotate(360deg);
          opacity: 1;
          filter: hue-rotate(360deg);
        }
      }
      
      @keyframes swapEffect {
        0% {
          transform: rotate(0deg) scale(1);
          opacity: 1;
        }
        50% {
          transform: rotate(180deg) scale(0.8);
          opacity: 0.5;
        }
        100% {
          transform: rotate(360deg) scale(1);
          opacity: 1;
        }
      }
      
      @keyframes teleportEffect {
        0% {
          transform: scale(1) opacity: 1;
          filter: brightness(1);
        }
        50% {
          transform: scale(0) opacity: 0;
          filter: brightness(3) hue-rotate(180deg);
        }
        100% {
          transform: scale(1) opacity: 1;
          filter: brightness(1);
        }
      }
      
      @keyframes visionPulse {
        0% {
          transform: scale(0);
          opacity: 0;
          box-shadow: 0 0 0 0 rgba(255, 255, 0, 0.7);
        }
        50% {
          transform: scale(2);
          opacity: 0.5;
          box-shadow: 0 0 30px 15px rgba(255, 255, 0, 0);
        }
        100% {
          transform: scale(3);
          opacity: 0;
          box-shadow: 0 0 50px 25px rgba(255, 255, 0, 0);
        }
      }
      
      @keyframes earthquakeShake {
        0%, 100% {
          transform: translateX(0);
        }
        10%, 30%, 50%, 70%, 90% {
          transform: translateX(-10px);
        }
        20%, 40%, 60%, 80% {
          transform: translateX(10px);
        }
      }
      
      @keyframes blizzardSwirl {
        0% {
          transform: rotate(0deg) translateX(0);
          opacity: 0;
        }
        50% {
          transform: rotate(720deg) translateX(20px);
          opacity: 1;
        }
        100% {
          transform: rotate(1440deg) translateX(0);
          opacity: 0;
        }
      }
      
      @keyframes gravityFall {
        0% {
          transform: translateY(-20px);
          opacity: 0;
        }
        50% {
          transform: translateY(0);
          opacity: 1;
        }
        100% {
          transform: translateY(10px);
          opacity: 1;
        }
      }
      
      @keyframes phoenixRise {
        0% {
          transform: scale(0) rotate(0deg);
          opacity: 0;
          filter: brightness(0) hue-rotate(0deg);
        }
        50% {
          transform: scale(1.5) rotate(180deg);
          opacity: 1;
          filter: brightness(2) hue-rotate(30deg);
        }
        100% {
          transform: scale(1) rotate(360deg);
          opacity: 1;
          filter: brightness(1.5) hue-rotate(60deg);
        }
      }
      
      @keyframes coinRain {
        0% {
          transform: translateY(-100px) rotate(0deg);
          opacity: 0;
        }
        10% {
          opacity: 1;
        }
        90% {
          opacity: 1;
        }
        100% {
          transform: translateY(100vh) rotate(720deg);
          opacity: 0;
        }
      }
      
      @keyframes powerSteal {
        0% {
          transform: scale(1) rotate(0deg);
          opacity: 1;
          filter: hue-rotate(0deg);
        }
        50% {
          transform: scale(0.5) rotate(180deg);
          opacity: 0.5;
          filter: hue-rotate(180deg) brightness(2);
        }
        100% {
          transform: scale(1) rotate(360deg);
          opacity: 1;
          filter: hue-rotate(360deg);
        }
      }
      
      @keyframes royalGuard {
        0% {
          transform: scale(0);
          opacity: 0;
          box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7);
        }
        50% {
          transform: scale(1.2);
          opacity: 1;
          box-shadow: 0 0 20px 10px rgba(255, 215, 0, 0.5);
        }
        100% {
          transform: scale(1);
          opacity: 0.7;
          box-shadow: 0 0 10px 5px rgba(255, 215, 0, 0.3);
        }
      }
      
      @keyframes luckyCharm {
        0% {
          transform: scale(0) rotate(0deg);
          opacity: 0;
        }
        25% {
          transform: scale(1.2) rotate(90deg);
          opacity: 1;
        }
        50% {
          transform: scale(0.8) rotate(180deg);
          opacity: 0.8;
        }
        75% {
          transform: scale(1.1) rotate(270deg);
          opacity: 1;
        }
        100% {
          transform: scale(1) rotate(360deg);
          opacity: 1;
        }
      }
      
      @keyframes chaosRoll {
        0% {
          transform: rotate(0deg) scale(1);
          opacity: 1;
          filter: hue-rotate(0deg);
        }
        25% {
          transform: rotate(90deg) scale(1.2);
          filter: hue-rotate(90deg);
        }
        50% {
          transform: rotate(180deg) scale(0.8);
          filter: hue-rotate(180deg);
        }
        75% {
          transform: rotate(270deg) scale(1.1);
          filter: hue-rotate(270deg);
        }
        100% {
          transform: rotate(360deg) scale(1);
          opacity: 1;
          filter: hue-rotate(360deg);
        }
      }
      
      @keyframes doubleCoins {
        0% {
          transform: scale(1);
          opacity: 1;
        }
        50% {
          transform: scale(1.3);
          opacity: 0.8;
          filter: brightness(1.5) hue-rotate(45deg);
        }
        100% {
          transform: scale(1);
          opacity: 1;
          filter: brightness(1) hue-rotate(0deg);
        }
      }
      
      @keyframes knightBoost {
        0% {
          transform: translateX(0) translateY(0);
          opacity: 1;
        }
        25% {
          transform: translateX(-20px) translateY(-10px);
        }
        50% {
          transform: translateX(20px) translateY(-20px);
        }
        75% {
          transform: translateX(-10px) translateY(-10px);
        }
        100% {
          transform: translateX(0) translateY(0);
          opacity: 1;
        }
      }
      
      @keyframes invisibilityFade {
        0% {
          opacity: 1;
          transform: scale(1);
        }
        50% {
          opacity: 0.3;
          transform: scale(0.95);
          filter: blur(2px);
        }
        100% {
          opacity: 0.6;
          transform: scale(1);
          filter: blur(1px);
        }
      }
      
      @keyframes mirrorReflect {
        0% {
          transform: scaleX(1);
          opacity: 1;
        }
        50% {
          transform: scaleX(-1);
          opacity: 0.7;
          filter: hue-rotate(180deg);
        }
        100% {
          transform: scaleX(1);
          opacity: 1;
          filter: hue-rotate(360deg);
        }
      }
      
      @keyframes shieldWall {
        0% {
          transform: scaleY(0);
          opacity: 0;
          background: linear-gradient(180deg, transparent, rgba(0, 255, 255, 0.8), transparent);
        }
        50% {
          transform: scaleY(1);
          opacity: 1;
        }
        100% {
          transform: scaleY(1);
          opacity: 0.7;
        }
      }
      
      @keyframes speedBoost {
        0% {
          transform: translateX(0);
          opacity: 1;
          filter: blur(0px);
        }
        50% {
          transform: translateX(30px);
          opacity: 0.8;
          filter: blur(1px) hue-rotate(120deg);
        }
        100% {
          transform: translateX(0);
          opacity: 1;
          filter: blur(0px);
        }
      }
      
      @keyframes timeFreeze {
        0% {
          transform: scale(1);
          opacity: 1;
          filter: hue-rotate(0deg) brightness(1);
        }
        50% {
          transform: scale(0.95);
          opacity: 0.8;
          filter: hue-rotate(200deg) brightness(0.7);
        }
        100% {
          transform: scale(1);
          opacity: 1;
          filter: hue-rotate(200deg) brightness(0.9);
        }
      }
      
      // Power-up button animations
      @keyframes powerUpGlow {
        0%, 100% {
          box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }
        50% {
          box-shadow: 0 0 20px rgba(255, 255, 255, 0.8), 0 0 30px rgba(255, 255, 255, 0.6);
        }
      }
      
      @keyframes powerUpPulse {
        0%, 100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
      }
      
      .power-up-active {
        animation: powerUpGlow 2s infinite, powerUpPulse 1s infinite;
      }
      
      // Premium UI Element Animations
      @keyframes buttonHover {
        0% {
          transform: scale(1) translateY(0);
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
          filter: brightness(1);
        }
        50% {
          transform: scale(1.08) translateY(-2px);
          box-shadow: 0 12px 20px rgba(0, 0, 0, 0.25);
          filter: brightness(1.1);
        }
        100% {
          transform: scale(1.05) translateY(-1px);
          box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
          filter: brightness(1.05);
        }
      }
      
      @keyframes buttonPress {
        0% {
          transform: scale(1) translateY(0);
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        25% {
          transform: scale(0.96) translateY(1px);
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
        }
        50% {
          transform: scale(0.94) translateY(2px);
          box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }
        75% {
          transform: scale(0.97) translateY(1px);
          box-shadow: 0 3px 5px rgba(0, 0, 0, 0.12);
        }
        100% {
          transform: scale(1) translateY(0);
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
      }
      
      @keyframes slideInFromTop {
        0% {
          transform: translateY(-100%) scale(0.8);
          opacity: 0;
          filter: blur(10px);
        }
        50% {
          transform: translateY(-25%) scale(0.95);
          opacity: 0.8;
          filter: blur(2px);
        }
        100% {
          transform: translateY(0) scale(1);
          opacity: 1;
          filter: blur(0px);
        }
      }
      
      @keyframes slideInFromBottom {
        0% {
          transform: translateY(100%) scale(0.8);
          opacity: 0;
          filter: blur(10px);
        }
        50% {
          transform: translateY(25%) scale(0.95);
          opacity: 0.8;
          filter: blur(2px);
        }
        100% {
          transform: translateY(0) scale(1);
          opacity: 1;
          filter: blur(0px);
        }
      }
      
      @keyframes slideInFromLeft {
        0% {
          transform: translateX(-100%) scale(0.8) rotate(-5deg);
          opacity: 0;
          filter: blur(10px);
        }
        50% {
          transform: translateX(-25%) scale(0.95) rotate(-1deg);
          opacity: 0.8;
          filter: blur(2px);
        }
        100% {
          transform: translateX(0) scale(1) rotate(0deg);
          opacity: 1;
          filter: blur(0px);
        }
      }
      
      @keyframes slideInFromRight {
        0% {
          transform: translateX(100%) scale(0.8) rotate(5deg);
          opacity: 0;
          filter: blur(10px);
        }
        50% {
          transform: translateX(25%) scale(0.95) rotate(1deg);
          opacity: 0.8;
          filter: blur(2px);
        }
        100% {
          transform: translateX(0) scale(1) rotate(0deg);
          opacity: 1;
          filter: blur(0px);
        }
      }
      
      @keyframes fadeIn {
        0% {
          opacity: 0;
          transform: scale(0.95);
          filter: blur(2px);
        }
        50% {
          opacity: 0.7;
          transform: scale(0.98);
          filter: blur(1px);
        }
        100% {
          opacity: 1;
          transform: scale(1);
          filter: blur(0px);
        }
      }
      
      @keyframes fadeOut {
        0% {
          opacity: 1;
          transform: scale(1);
          filter: blur(0px);
        }
        50% {
          opacity: 0.5;
          transform: scale(0.98);
          filter: blur(1px);
        }
        100% {
          opacity: 0;
          transform: scale(0.95);
          filter: blur(2px);
        }
      }
      
      @keyframes scaleIn {
        0% {
          transform: scale(0) rotate(180deg);
          opacity: 0;
          filter: blur(10px) brightness(0.5);
        }
        25% {
          transform: scale(0.3) rotate(135deg);
          opacity: 0.3;
          filter: blur(8px) brightness(0.7);
        }
        50% {
          transform: scale(0.6) rotate(90deg);
          opacity: 0.6;
          filter: blur(4px) brightness(0.9);
        }
        75% {
          transform: scale(0.9) rotate(45deg);
          opacity: 0.9;
          filter: blur(1px) brightness(1.1);
        }
        100% {
          transform: scale(1) rotate(0deg);
          opacity: 1;
          filter: blur(0px) brightness(1);
        }
      }
      
      @keyframes scaleOut {
        0% {
          transform: scale(1) rotate(0deg);
          opacity: 1;
          filter: blur(0px) brightness(1);
        }
        25% {
          transform: scale(0.9) rotate(45deg);
          opacity: 0.9;
          filter: blur(1px) brightness(1.1);
        }
        50% {
          transform: scale(0.6) rotate(90deg);
          opacity: 0.6;
          filter: blur(4px) brightness(0.9);
        }
        75% {
          transform: scale(0.3) rotate(135deg);
          opacity: 0.3;
          filter: blur(8px) brightness(0.7);
        }
        100% {
          transform: scale(0) rotate(180deg);
          opacity: 0;
          filter: blur(10px) brightness(0.5);
        }
      }
      
      @keyframes bounce {
        0%, 20%, 53%, 80%, 100% {
          transform: translateY(0) scale(1);
          animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
        }
        40%, 43% {
          transform: translateY(-30px) scale(1.05);
          animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
        }
        70% {
          transform: translateY(-15px) scale(1.02);
          animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
        }
        90% {
          transform: translateY(-4px) scale(1.01);
          animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
        }
      }
      
      @keyframes shake {
        0%, 100% {
          transform: translateX(0) rotate(0deg);
        }
        10%, 30%, 50%, 70%, 90% {
          transform: translateX(-12px) rotate(-1deg);
        }
        20%, 40%, 60%, 80% {
          transform: translateX(12px) rotate(1deg);
        }
      }
      
      @keyframes pulse {
        0% {
          transform: scale(1);
          box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.7);
        }
        25% {
          transform: scale(1.05);
          box-shadow: 0 0 10px 5px rgba(255, 255, 255, 0.3);
        }
        50% {
          transform: scale(1.1);
          box-shadow: 0 0 20px 10px rgba(255, 255, 255, 0.1);
        }
        75% {
          transform: scale(1.05);
          box-shadow: 0 0 10px 5px rgba(255, 255, 255, 0.3);
        }
        100% {
          transform: scale(1);
          box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.7);
        }
      }
      
      @keyframes rotate {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      
      @keyframes glow {
        0%, 100% {
          box-shadow: 0 0 5px rgba(255, 255, 255, 0.5),
                      0 0 10px rgba(255, 255, 255, 0.3),
                      0 0 15px rgba(255, 255, 255, 0.1);
          filter: brightness(1);
        }
        25% {
          box-shadow: 0 0 10px rgba(255, 255, 255, 0.6),
                      0 0 20px rgba(255, 255, 255, 0.4),
                      0 0 30px rgba(255, 255, 255, 0.2);
          filter: brightness(1.1);
        }
        50% {
          box-shadow: 0 0 20px rgba(255, 255, 255, 0.8),
                      0 0 40px rgba(255, 255, 255, 0.6),
                      0 0 60px rgba(255, 255, 255, 0.4);
          filter: brightness(1.2);
        }
        75% {
          box-shadow: 0 0 10px rgba(255, 255, 255, 0.6),
                      0 0 20px rgba(255, 255, 255, 0.4),
                      0 0 30px rgba(255, 255, 255, 0.2);
          filter: brightness(1.1);
        }
      }
      
      @keyframes typewriter {
        0% {
          width: 0;
        }
        100% {
          width: 100%;
        }
      }
      
      @keyframes loading {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      
      @keyframes heartbeat {
        0% {
          transform: scale(1);
        }
        14% {
          transform: scale(1.3);
        }
        28% {
          transform: scale(1);
        }
        42% {
          transform: scale(1.3);
        }
        70% {
          transform: scale(1);
        }
      }
      
      @keyframes rainbow {
        0% {
          background-position: 0% 50%;
        }
        50% {
          background-position: 100% 50%;
        }
        100% {
          background-position: 0% 50%;
        }
      }
      
      @keyframes wave {
        0% {
          transform: translateY(0);
        }
        25% {
          transform: translateY(-10px);
        }
        50% {
          transform: translateY(0);
        }
        75% {
          transform: translateY(-10px);
        }
        100% {
          transform: translateY(0);
        }
      }
      
      @keyframes flip {
        0% {
          transform: perspective(400px) rotateY(0);
        }
        100% {
          transform: perspective(400px) rotateY(360deg);
        }
      }
      
      @keyframes cardFlip {
        0% {
          transform: perspective(400px) rotateY(0);
        }
        100% {
          transform: perspective(400px) rotateY(180deg);
        }
      }
      
      @keyframes slideDown {
        0% {
          transform: translateY(-100%);
          opacity: 0;
        }
        100% {
          transform: translateY(0);
          opacity: 1;
        }
      }
      
      @keyframes slideUp {
        0% {
          transform: translateY(100%);
          opacity: 0;
        }
        100% {
          transform: translateY(0);
          opacity: 1;
        }
      }
      
      @keyframes zoomIn {
        0% {
          transform: scale(0);
          opacity: 0;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      
      @keyframes zoomOut {
        0% {
          transform: scale(1);
          opacity: 1;
        }
        100% {
          transform: scale(0);
          opacity: 0;
        }
      }
      
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      
      @keyframes wiggle {
        0%, 7% {
          transform: rotateZ(0);
        }
        15% {
          transform: rotateZ(-15deg);
        }
        20% {
          transform: rotateZ(10deg);
        }
        25% {
          transform: rotateZ(-10deg);
        }
        30% {
          transform: rotateZ(6deg);
        }
        35% {
          transform: rotateZ(-4deg);
        }
        40%, 100% {
          transform: rotateZ(0);
        }
      }
      
      @keyframes swing {
        20%, 40%, 60%, 80%, 100% {
          transform: rotate(15deg);
        }
        0% {
          transform: rotate(15deg);
        }
        10% {
          transform: rotate(-10deg);
        }
        30% {
          transform: rotate(20deg);
        }
        50% {
          transform: rotate(-20deg);
        }
        70% {
          transform: rotate(10deg);
        }
        90% {
          transform: rotate(-5deg);
        }
      }
      
      @keyframes tada {
        0% {
          transform: scale(1) rotate(0deg);
        }
        10%, 20% {
          transform: scale(0.9) rotate(-3deg);
        }
        30%, 50%, 70%, 90% {
          transform: scale(1.1) rotate(3deg);
        }
        40%, 60%, 80% {
          transform: scale(1.1) rotate(-3deg);
        }
        100% {
          transform: scale(1) rotate(0deg);
        }
      }
      
      @keyframes rubberBand {
        0% {
          transform: scale(1);
        }
        30% {
          transform: scaleX(1.25) scaleY(0.75);
        }
        40% {
          transform: scaleX(0.75) scaleY(1.25);
        }
        60% {
          transform: scaleX(1.15) scaleY(0.85);
        }
        100% {
          transform: scale(1);
        }
      }
      
      @keyframes hinge {
        0% {
          transform: rotate(0);
          transform-origin: top left;
          animation-timing-function: ease-in-out;
        }
        20%, 60% {
          transform: rotate(80deg);
          transform-origin: top left;
          animation-timing-function: ease-in-out;
        }
        40% {
          transform: rotate(60deg);
          transform-origin: top left;
          animation-timing-function: ease-in-out;
        }
        80% {
          transform: rotate(60deg) translateY(0);
          transform-origin: top left;
          animation-timing-function: ease-in-out;
        }
        100% {
          transform: translateY(700px);
        }
      }
      
      @keyframes rollIn {
        0% {
          opacity: 0;
          transform: translateX(-100%) rotate(-120deg);
        }
        100% {
          opacity: 1;
          transform: translateX(0) rotate(0deg);
        }
      }
      
      @keyframes rollOut {
        0% {
          opacity: 1;
          transform: translateX(0) rotate(0deg);
        }
        100% {
          opacity: 0;
          transform: translateX(100%) rotate(120deg);
        }
      }
      
      // Premium Chess piece specific animations
      @keyframes pieceMove {
        0% {
          transform: scale(1) translateY(0);
          filter: brightness(1) hue-rotate(0deg);
          box-shadow: 0 0 0 rgba(255, 255, 255, 0);
        }
        25% {
          transform: scale(1.1) translateY(-5px);
          filter: brightness(1.2) hue-rotate(10deg);
          box-shadow: 0 5px 15px rgba(255, 255, 255, 0.3);
        }
        50% {
          transform: scale(1.2) translateY(-10px);
          filter: brightness(1.5) hue-rotate(20deg);
          box-shadow: 0 10px 25px rgba(255, 255, 255, 0.5);
        }
        75% {
          transform: scale(1.1) translateY(-5px);
          filter: brightness(1.2) hue-rotate(10deg);
          box-shadow: 0 5px 15px rgba(255, 255, 255, 0.3);
        }
        100% {
          transform: scale(1) translateY(0);
          filter: brightness(1) hue-rotate(0deg);
          box-shadow: 0 0 0 rgba(255, 255, 255, 0);
        }
      }
      
      @keyframes pieceCapture {
        0% {
          transform: scale(1) rotate(0deg);
          opacity: 1;
          filter: brightness(1) hue-rotate(0deg);
          box-shadow: 0 0 0 rgba(255, 0, 0, 0);
        }
        25% {
          transform: scale(1.3) rotate(90deg);
          opacity: 0.8;
          filter: brightness(1.5) hue-rotate(30deg);
          box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
        }
        50% {
          transform: scale(1.5) rotate(180deg);
          opacity: 0.5;
          filter: brightness(2) hue-rotate(60deg);
          box-shadow: 0 0 40px rgba(255, 0, 0, 0.8);
        }
        75% {
          transform: scale(0.8) rotate(270deg);
          opacity: 0.2;
          filter: brightness(1.5) hue-rotate(30deg);
          box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);
        }
        100% {
          transform: scale(0) rotate(360deg);
          opacity: 0;
          filter: brightness(1) hue-rotate(0deg);
          box-shadow: 0 0 0 rgba(255, 0, 0, 0);
        }
      }
      
      @keyframes pieceSelect {
        0% {
          transform: scale(1);
          box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.7);
          filter: brightness(1);
        }
        25% {
          transform: scale(1.05);
          box-shadow: 0 0 15px 5px rgba(255, 255, 255, 0.5);
          filter: brightness(1.1);
        }
        50% {
          transform: scale(1.1);
          box-shadow: 0 0 30px 15px rgba(255, 255, 255, 0.3);
          filter: brightness(1.2);
        }
        75% {
          transform: scale(1.05);
          box-shadow: 0 0 15px 5px rgba(255, 255, 255, 0.2);
          filter: brightness(1.1);
        }
        100% {
          transform: scale(1);
          box-shadow: 0 0 0 0 rgba(255, 255, 255, 0);
          filter: brightness(1);
        }
      }
      
      @keyframes checkWarning {
        0%, 100% {
          background-color: rgba(255, 0, 0, 0.3);
          transform: scale(1);
        }
        50% {
          background-color: rgba(255, 0, 0, 0.6);
          transform: scale(1.05);
        }
      }
      
      @keyframes checkmate {
        0% {
          transform: scale(1) rotate(0deg);
        }
        50% {
          transform: scale(1.2) rotate(180deg);
        }
        100% {
          transform: scale(1) rotate(360deg);
        }
      }
      
      @keyframes coinCollect {
        0% {
          transform: translateY(0) scale(1);
          opacity: 1;
        }
        50% {
          transform: translateY(-20px) scale(1.5);
          opacity: 0.8;
        }
        100% {
          transform: translateY(-40px) scale(0.5);
          opacity: 0;
        }
      }
      
      @keyframes levelUp {
        0% {
          transform: scale(0) rotate(0deg);
          opacity: 0;
        }
        50% {
          transform: scale(1.5) rotate(180deg);
          opacity: 1;
        }
        100% {
          transform: scale(1) rotate(360deg);
          opacity: 1;
        }
      }
      
      @keyframes achievement {
        0% {
          transform: scale(0) rotate(0deg);
          opacity: 0;
        }
        50% {
          transform: scale(1.2) rotate(180deg);
          opacity: 1;
        }
        100% {
          transform: scale(1) rotate(360deg);
          opacity: 1;
        }
      }
      
      @keyframes notification {
        0% {
          transform: translateY(-100%);
          opacity: 0;
        }
        10% {
          transform: translateY(0);
          opacity: 1;
        }
        90% {
          transform: translateY(0);
          opacity: 1;
        }
        100% {
          transform: translateY(-100%);
          opacity: 0;
        }
      }
      
      @keyframes modalOpen {
        0% {
          transform: scale(0.8);
          opacity: 0;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      
      @keyframes modalClose {
        0% {
          transform: scale(1);
          opacity: 1;
        }
        100% {
          transform: scale(0.8);
          opacity: 0;
        }
      }
      
      @keyframes tabSwitch {
        0% {
          transform: translateY(10px);
          opacity: 0;
        }
        100% {
          transform: translateY(0);
          opacity: 1;
        }
      }
      
      @keyframes progressBar {
        0% {
          width: 0%;
        }
        100% {
          width: 100%;
        }
      }
      
      @keyframes healthBar {
        0% {
          width: 100%;
          background-color: #4caf50;
        }
        50% {
          width: 50%;
          background-color: #ff9800;
        }
        100% {
          width: 25%;
          background-color: #f44336;
        }
      }
      
      @keyframes experienceBar {
        0% {
          width: 0%;
        }
        100% {
          width: 100%;
        }
      }
      
      @keyframes combo {
        0% {
          transform: scale(1) rotate(0deg);
        }
        25% {
          transform: scale(1.2) rotate(90deg);
        }
        50% {
          transform: scale(1.4) rotate(180deg);
        }
        75% {
          transform: scale(1.2) rotate(270deg);
        }
        100% {
          transform: scale(1) rotate(360deg);
        }
      }
      
      @keyframes streak {
        0% {
          transform: scale(1);
          opacity: 1;
        }
        50% {
          transform: scale(1.3);
          opacity: 0.8;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      
      @keyframes multiplayer {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
        100% {
          transform: scale(1);
        }
      }
      
      @keyframes connection {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      
      @keyframes disconnect {
        0% {
          transform: scale(1);
          opacity: 1;
        }
        100% {
          transform: scale(0);
          opacity: 0;
        }
      }
      
      @keyframes chat {
        0% {
          transform: translateY(20px);
          opacity: 0;
        }
        100% {
          transform: translateY(0);
          opacity: 1;
        }
      }
      
      @keyframes typing {
        0% {
          opacity: 0.3;
        }
        50% {
          opacity: 1;
        }
        100% {
          opacity: 0.3;
        }
      }
      
      @keyframes sound {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.2);
        }
        100% {
          transform: scale(1);
        }
      }
      
      @keyframes music {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      
      @keyframes volume {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
        100% {
          transform: scale(1);
        }
      }
      
      @keyframes settings {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      
      @keyframes help {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
        100% {
          transform: scale(1);
        }
      }
      
      @keyframes info {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
        100% {
          transform: scale(1);
        }
      }
      
      @keyframes warning {
        0% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-10px);
        }
        50% {
          transform: translateX(10px);
        }
        75% {
          transform: translateX(-10px);
        }
        100% {
          transform: translateX(0);
        }
      }
      
      @keyframes error {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
        100% {
          transform: scale(1);
        }
      }
      
      @keyframes success {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
        100% {
          transform: scale(1);
        }
      }
      
      @keyframes loading {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      
      @keyframes spinner {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      
      @keyframes dots {
        0%, 20% {
          color: rgba(0, 0, 0, 0);
          text-shadow: 0.25em 0 0 rgba(0, 0, 0, 0), 0.5em 0 0 rgba(0, 0, 0, 0);
        }
        40% {
          color: black;
          text-shadow: 0.25em 0 0 rgba(0, 0, 0, 0), 0.5em 0 0 rgba(0, 0, 0, 0);
        }
        60% {
          text-shadow: 0.25em 0 0 black, 0.5em 0 0 rgba(0, 0, 0, 0);
        }
        80%, 100% {
          text-shadow: 0.25em 0 0 black, 0.5em 0 0 black;
        }
      }
      
      // Animation classes
      .animate-hover:hover {
        animation: buttonHover 0.3s ease-out;
      }
      
      .animate-press:active {
        animation: buttonPress 0.1s ease-out;
      }
      
      .animate-fade-in {
        animation: fadeIn 0.5s ease-out;
      }
      
      .animate-fade-out {
        animation: fadeOut 0.5s ease-out;
      }
      
      .animate-scale-in {
        animation: scaleIn 0.3s ease-out;
      }
      
      .animate-scale-out {
        animation: scaleOut 0.3s ease-out;
      }
      
      .animate-bounce {
        animation: bounce 1s ease-out;
      }
      
      .animate-shake {
        animation: shake 0.5s ease-out;
      }
      
      .animate-pulse {
        animation: pulse 1s ease-in-out infinite;
      }
      
      .animate-glow {
        animation: glow 2s ease-in-out infinite;
      }
      
      .animate-rotate {
        animation: rotate 2s linear infinite;
      }
      
      .animate-wiggle {
        animation: wiggle 1s ease-out;
      }
      
      .animate-tada {
        animation: tada 1s ease-out;
      }
      
      .animate-rubber-band {
        animation: rubberBand 1s ease-out;
      }
      
      .animate-swing {
        animation: swing 1s ease-out;
      }
      
      .animate-flip {
        animation: flip 1s ease-out;
      }
      
      .animate-zoom-in {
        animation: zoomIn 0.3s ease-out;
      }
      
      .animate-zoom-out {
        animation: zoomOut 0.3s ease-out;
      }
      
      .animate-slide-in-top {
        animation: slideInFromTop 0.5s ease-out;
      }
      
      .animate-slide-in-bottom {
        animation: slideInFromBottom 0.5s ease-out;
      }
      
      .animate-slide-in-left {
        animation: slideInFromLeft 0.5s ease-out;
      }
      
      .animate-slide-in-right {
        animation: slideInFromRight 0.5s ease-out;
      }
      
      .animate-heartbeat {
        animation: heartbeat 1.5s ease-in-out infinite;
      }
      
      .animate-wave {
        animation: wave 1s ease-in-out infinite;
      }
      
      .animate-rainbow {
        background: linear-gradient(to right, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3);
        background-size: 100% 100%;
        animation: rainbow 3s ease-in-out infinite;
      }
      
      .animate-loading {
        animation: loading 1s linear infinite;
      }
      
      .animate-spinner {
        animation: spinner 1s linear infinite;
      }
      
      .animate-dots {
        animation: dots 1.5s ease-in-out infinite;
      }
      
      // Chess specific animation classes
      .animate-piece-move {
        animation: pieceMove 0.3s ease-out;
      }
      
      .animate-piece-capture {
        animation: pieceCapture 0.5s ease-out;
      }
      
      .animate-piece-select {
        animation: pieceSelect 0.3s ease-out;
      }
      
      .animate-check-warning {
        animation: checkWarning 1s ease-in-out infinite;
      }
      
      .animate-checkmate {
        animation: checkmate 2s ease-out;
      }
      
      .animate-coin-collect {
        animation: coinCollect 0.5s ease-out;
      }
      
      .animate-level-up {
        animation: levelUp 1s ease-out;
      }
      
      .animate-achievement {
        animation: achievement 1s ease-out;
      }
      
      .animate-notification {
        animation: notification 3s ease-out;
      }
      
      .animate-modal-open {
        animation: modalOpen 0.3s ease-out;
      }
      
      .animate-modal-close {
        animation: modalClose 0.3s ease-out;
      }
      
      .animate-tab-switch {
        animation: tabSwitch 0.3s ease-out;
      }
      
      .animate-combo {
        animation: combo 1s ease-out;
      }
      
      .animate-streak {
        animation: streak 1s ease-out;
      }
      
      .animate-multiplayer {
        animation: multiplayer 1s ease-out;
      }
      
      .animate-connection {
        animation: connection 2s linear infinite;
      }
      
      .animate-disconnect {
        animation: disconnect 0.5s ease-out;
      }
      
      .animate-chat {
        animation: chat 0.3s ease-out;
      }
      
      .animate-typing {
        animation: typing 1.5s ease-in-out infinite;
      }
      
      .animate-sound {
        animation: sound 0.3s ease-out;
      }
      
      .animate-music {
        animation: music 2s linear infinite;
      }
      
      .animate-volume {
        animation: volume 0.3s ease-out;
      }
      
      .animate-settings {
        animation: settings 2s linear infinite;
      }
      
      .animate-help {
        animation: help 0.3s ease-out;
      }
      
      .animate-info {
        animation: info 0.3s ease-out;
      }
      
      .animate-warning {
        animation: warning 0.5s ease-out;
      }
      
      .animate-error {
        animation: error 0.5s ease-out;
      }
      
      .animate-success {
        animation: success 0.5s ease-out;
      }
    `;
    document.head.appendChild(style);
    
    // Power-up animation functions
    function playPowerUpAnimation(powerUpType, targetElement = null) {
      if (!targetElement) {
        targetElement = document.body;
      }
      
      const animations = {
        lightning: () => createLightningAnimation(targetElement),
        mega_bomb: () => createMegaBombAnimation(targetElement),
        laser: () => createLaserAnimation(targetElement),
        tornado: () => createTornadoAnimation(targetElement),
        bomb: () => createBombAnimation(targetElement),
        shield: () => createShieldAnimation(targetElement),
        freeze: () => createFreezeAnimation(targetElement),
        heal: () => createHealAnimation(targetElement),
        clone: () => createCloneAnimation(targetElement),
        magnet: () => createMagnetAnimation(targetElement),
        poison: () => createPoisonAnimation(targetElement),
        time_warp: () => createTimeWarpAnimation(targetElement),
        swap: () => createSwapAnimation(targetElement),
        teleport: () => createTeleportAnimation(targetElement),
        vision: () => createVisionAnimation(targetElement),
        earthquake: () => createEarthquakeAnimation(targetElement),
        blizzard: () => createBlizzardAnimation(targetElement),
        gravity: () => createGravityAnimation(targetElement),
        phoenix: () => createPhoenixAnimation(targetElement),
        coin_rain: () => createCoinRainAnimation(targetElement),
        power_steal: () => createPowerStealAnimation(targetElement),
        royal_guard: () => createRoyalGuardAnimation(targetElement),
        lucky_charm: () => createLuckyCharmAnimation(targetElement),
        chaos: () => createChaosAnimation(targetElement),
        double_coins: () => createDoubleCoinsAnimation(targetElement),
        knight_boost: () => createKnightBoostAnimation(targetElement),
        invisibility: () => createInvisibilityAnimation(targetElement),
        mirror: () => createMirrorAnimation(targetElement),
        shield_wall: () => createShieldWallAnimation(targetElement),
        speed_boost: () => createSpeedBoostAnimation(targetElement),
        time_freeze: () => createTimeFreezeAnimation(targetElement)
      };
      
      if (animations[powerUpType]) {
        animations[powerUpType]();
      }
    }
    
    function createLightningAnimation(targetElement) {
      // Optimized lightning with fewer elements and simpler paths
      const lightning = document.createElement('div');
      const startX = window.innerWidth * 0.3 + Math.random() * window.innerWidth * 0.4;
      const startY = 0;
      const endX = startX + (Math.random() - 0.5) * 150;
      const endY = window.innerHeight;
      
      // Simple lightning path with fewer points
      const midX = startX + (Math.random() - 0.5) * 80;
      const midY = window.innerHeight * 0.5;
      
      lightning.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 9999;
      `;
      
      // Simplified SVG without filters for performance
      lightning.innerHTML = `
        <svg width="100%" height="100%" style="position: absolute; top: 0; left: 0;">
          <path d="M ${startX} ${startY} L ${midX} ${midY} L ${endX} ${endY}" 
                stroke="#ffff00" 
                stroke-width="2" 
                fill="none" 
                style="animation: lightningFlash 0.3s ease-out;"/>
        </svg>
      `;
      
      document.body.appendChild(lightning);
      
      // Simple flash effect
      const flash = document.createElement('div');
      flash.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 0, 0.2);
        pointer-events: none;
        z-index: 9998;
        animation: lightningFlash 0.2s ease-out;
      `;
      document.body.appendChild(flash);
      
      // Quick cleanup
      setTimeout(() => {
        if (lightning.parentNode) lightning.remove();
        if (flash.parentNode) flash.remove();
      }, 300);
      
      // Play lightning sound
      playLightningSound();
      
      // Send to online opponent via server
      if (gameState.mode === 'online') {
        sendAnimationToServer('lightning');
      }
    }
    
    function createMegaBombAnimation(targetElement) {
      // Optimized explosion with fewer particles
      const particleCount = 8; // Reduced from 20
      
      for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        const angle = (Math.PI * 2 * i) / particleCount;
        const velocity = 8 + Math.random() * 4; // Simplified velocity
        const size = 12 + Math.random() * 8; // Simplified size
        
        particle.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          width: ${size}px;
          height: ${size}px;
          background: radial-gradient(circle, #ff6600, #ff0000);
          border-radius: 50%;
          pointer-events: none;
          z-index: 9999;
        `;
        
        document.body.appendChild(particle);
        
        // CSS animation instead of requestAnimationFrame for performance
        const distance = velocity * 30;
        const x = Math.cos(angle) * distance;
        const y = Math.sin(angle) * distance;
        
        particle.style.transition = 'all 0.6s ease-out';
        particle.style.transform = `translate(calc(-50% + ${x}px), calc(-50% + ${y}px)) scale(0)`;
        particle.style.opacity = '0';
        
        setTimeout(() => {
          if (particle.parentNode) particle.remove();
        }, 600);
      }
      
      // Simple shockwave with CSS animation
      const shockwave = document.createElement('div');
      shockwave.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 50px;
        height: 50px;
        border: 3px solid rgba(255, 100, 0, 0.8);
        border-radius: 50%;
        pointer-events: none;
        z-index: 9998;
        animation: shockwaveExpand 0.6s ease-out;
      `;
      
      document.body.appendChild(shockwave);
      
      setTimeout(() => {
        if (shockwave.parentNode) shockwave.remove();
      }, 600);
      
      // Quick screen shake
      document.body.style.animation = 'earthquakeShake 0.3s ease-out';
      setTimeout(() => {
        document.body.style.animation = '';
      }, 300);
      
      // Send to online opponent via server
      if (gameState.mode === 'online') {
        sendAnimationToServer('megaBomb');
      }
    }
    
    function createLaserAnimation(targetElement) {
      const laser = document.createElement('div');
      laser.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 300px;
        height: 10px;
        background: linear-gradient(90deg, transparent, #ff0000, transparent);
        animation: laserBeam 1s ease-out;
        z-index: 9999;
        pointer-events: none;
      `;
      document.body.appendChild(laser);
      setTimeout(() => laser.remove(), 1000);
    }
    
    function createTornadoAnimation(targetElement) {
      // Optimized tornado with fewer layers
      const tornado = document.createElement('div');
      tornado.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 150px;
        height: 200px;
        pointer-events: none;
        z-index: 9999;
      `;
      
      // Reduced number of layers from 8 to 4
      for (let i = 0; i < 4; i++) {
        const layer = document.createElement('div');
        const size = 120 - (i * 20);
        
        layer.style.cssText = `
          position: absolute;
          top: 50%;
          left: 50%;
          width: ${size}px;
          height: ${size}px;
          border: 2px solid rgba(150, 150, 150, ${0.7 - i * 0.15});
          border-radius: 50%;
          transform: translate(-50%, -50%) rotateX(60deg);
          animation: tornadoSpin ${1.5 - i * 0.2}s linear infinite;
          box-shadow: 0 0 10px rgba(200, 200, 200, 0.2);
        `;
        
        tornado.appendChild(layer);
      }
      
      // Reduced debris from 15 to 6
      for (let i = 0; i < 6; i++) {
        const debris = document.createElement('div');
        const size = 6 + Math.random() * 6;
        const color = ['#888888', '#aaaaaa', '#cccccc'][Math.floor(Math.random() * 3)];
        
        debris.style.cssText = `
          position: absolute;
          width: ${size}px;
          height: ${size}px;
          background: ${color};
          border-radius: 50%;
          top: ${Math.random() * 100}%;
          left: ${Math.random() * 100}%;
          animation: tornadoDebris ${1 + Math.random() * 0.5}s linear infinite;
        `;
        
        tornado.appendChild(debris);
      }
      
      document.body.appendChild(tornado);
      
      // Shorter screen shake
      document.body.style.animation = 'earthquakeShake 1s ease-out';
      setTimeout(() => {
        document.body.style.animation = '';
      }, 1000);
      
      // Shorter duration
      setTimeout(() => tornado.remove(), 1500);
      
      // Send to online opponent via server
      if (gameState.mode === 'online') {
        sendAnimationToServer('tornado');
      }
    }
    
    function createBombAnimation(targetElement) {
      // Simplified bomb animation
      const bomb = document.createElement('div');
      bomb.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
        z-index: 9999;
      `;
      
      // Simple bomb body
      const bombBody = document.createElement('div');
      bombBody.style.cssText = `
        width: 50px;
        height: 50px;
        background: radial-gradient(circle, #666666, #333333);
        border-radius: 50%;
        position: relative;
        animation: bombDrop 0.8s ease-out;
      `;
      
      // Simple fuse
      const fuse = document.createElement('div');
      fuse.style.cssText = `
        position: absolute;
        top: -10px;
        left: 50%;
        transform: translateX(-50%);
        width: 2px;
        height: 15px;
        background: #8B4513;
      `;
      
      bombBody.appendChild(fuse);
      bomb.appendChild(bombBody);
      document.body.appendChild(bomb);
      
      // Simple explosion
      setTimeout(() => {
        if (bomb.parentNode) {
          // Create 6 particles instead of 10
          for (let i = 0; i < 6; i++) {
            const particle = document.createElement('div');
            const angle = (Math.PI * 2 * i) / 6;
            const distance = 80;
            const x = Math.cos(angle) * distance;
            const y = Math.sin(angle) * distance;
            
            particle.style.cssText = `
              position: fixed;
              top: 50%;
              left: 50%;
              width: 6px;
              height: 6px;
              background: #ff6600;
              border-radius: 50%;
              pointer-events: none;
              z-index: 9999;
              transition: all 0.4s ease-out;
            `;
            
            document.body.appendChild(particle);
            
            // Use CSS transition for performance
            setTimeout(() => {
              particle.style.transform = `translate(calc(-50% + ${x}px), calc(-50% + ${y}px)) scale(0)`;
              particle.style.opacity = '0';
            }, 10);
            
            setTimeout(() => {
              if (particle.parentNode) particle.remove();
            }, 400);
          }
        }
      }, 700);
      
      setTimeout(() => {
        if (bomb.parentNode) bomb.remove();
      }, 800);
      
      // Send to online opponent via server
      if (gameState.mode === 'online') {
        sendAnimationToServer('bomb');
      }
    }
    
    function createShieldAnimation(targetElement) {
      const shield = document.createElement('div');
      shield.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 200px;
        height: 200px;
        border: 5px solid rgba(0, 255, 255, 0.8);
        border-radius: 50%;
        animation: shieldActivate 1.5s ease-out;
        z-index: 9999;
        pointer-events: none;
      `;
      document.body.appendChild(shield);
      setTimeout(() => shield.remove(), 1500);
    }
    
    function createFreezeAnimation(targetElement) {
      const freeze = document.createElement('div');
      freeze.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(circle, rgba(0, 255, 255, 0.3), transparent);
        animation: freezeEffect 2s ease-out;
        z-index: 9998;
        pointer-events: none;
      `;
      document.body.appendChild(freeze);
      setTimeout(() => freeze.remove(), 2000);
    }
    
    function createHealAnimation(targetElement) {
      const heal = document.createElement('div');
      heal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 150px;
        height: 150px;
        background: radial-gradient(circle, #00ff00, #00aa00);
        border-radius: 50%;
        animation: healPulse 1.5s ease-out;
        z-index: 9999;
        pointer-events: none;
      `;
      document.body.appendChild(heal);
      setTimeout(() => heal.remove(), 1500);
    }
    
    function createCloneAnimation(targetElement) {
      const clone = document.createElement('div');
      clone.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 100px;
        height: 100px;
        background: radial-gradient(circle, #ff00ff, #aa00aa);
        border-radius: 50%;
        animation: cloneEffect 1s ease-out;
        z-index: 9999;
        pointer-events: none;
      `;
      document.body.appendChild(clone);
      setTimeout(() => clone.remove(), 1000);
    }
    
    function createMagnetAnimation(targetElement) {
      const magnet = document.createElement('div');
      magnet.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 120px;
        height: 120px;
        background: radial-gradient(circle, #ff0000, #aa0000);
        border-radius: 50%;
        animation: magnetPull 1.5s ease-out;
        z-index: 9999;
        pointer-events: none;
      `;
      document.body.appendChild(magnet);
      setTimeout(() => magnet.remove(), 1500);
    }
    
    function createPoisonAnimation(targetElement) {
      const poison = document.createElement('div');
      poison.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 100px;
        height: 100px;
        background: radial-gradient(circle, #00ff00, #008800);
        border-radius: 50%;
        animation: poisonSpread 2s ease-out;
        z-index: 9999;
        pointer-events: none;
      `;
      document.body.appendChild(poison);
      setTimeout(() => poison.remove(), 2000);
    }
    
    function createTimeWarpAnimation(targetElement) {
      const warp = document.createElement('div');
      warp.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 150px;
        height: 150px;
        background: radial-gradient(circle, #ff00ff, #8800ff);
        border-radius: 50%;
        animation: timeWarp 2s ease-out;
        z-index: 9999;
        pointer-events: none;
      `;
      document.body.appendChild(warp);
      setTimeout(() => warp.remove(), 2000);
    }
    
    function createSwapAnimation(targetElement) {
      const swap = document.createElement('div');
      swap.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 100px;
        height: 100px;
        background: radial-gradient(circle, #ffff00, #aaaa00);
        border-radius: 50%;
        animation: swapEffect 1s ease-out;
        z-index: 9999;
        pointer-events: none;
      `;
      document.body.appendChild(swap);
      setTimeout(() => swap.remove(), 1000);
    }
    
    function createTeleportAnimation(targetElement) {
      const teleport = document.createElement('div');
      teleport.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 120px;
        height: 120px;
        background: radial-gradient(circle, #00ffff, #0088ff);
        border-radius: 50%;
        animation: teleportEffect 1s ease-out;
        z-index: 9999;
        pointer-events: none;
      `;
      document.body.appendChild(teleport);
      setTimeout(() => teleport.remove(), 1000);
    }
    
    function createVisionAnimation(targetElement) {
      const vision = document.createElement('div');
      vision.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 200px;
        height: 200px;
        background: radial-gradient(circle, #ffff00, transparent);
        border-radius: 50%;
        animation: visionPulse 2s ease-out;
        z-index: 9999;
        pointer-events: none;
      `;
      document.body.appendChild(vision);
      setTimeout(() => vision.remove(), 2000);
    }
    
    function createEarthquakeAnimation(targetElement) {
      const board = document.getElementById('board');
      if (board) {
        board.style.animation = 'earthquakeShake 0.5s ease-in-out';
        setTimeout(() => {
          board.style.animation = '';
        }, 500);
      }
    }
    
    function createBlizzardAnimation(targetElement) {
      const blizzard = document.createElement('div');
      blizzard.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 150px;
        height: 150px;
        background: radial-gradient(circle, #ffffff, #cccccc);
        border-radius: 50%;
        animation: blizzardSwirl 2s ease-out;
        z-index: 9999;
        pointer-events: none;
      `;
      document.body.appendChild(blizzard);
      setTimeout(() => blizzard.remove(), 2000);
    }
    
    function createGravityAnimation(targetElement) {
      const board = document.getElementById('board');
      if (board) {
        board.style.animation = 'gravityFall 1s ease-in-out';
        setTimeout(() => {
          board.style.animation = '';
        }, 1000);
      }
    }
    
    function createPhoenixAnimation(targetElement) {
      const phoenix = document.createElement('div');
      phoenix.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 120px;
        height: 120px;
        background: radial-gradient(circle, #ff6600, #ff0000);
        border-radius: 50%;
        animation: phoenixRise 2s ease-out;
        z-index: 9999;
        pointer-events: none;
      `;
      document.body.appendChild(phoenix);
      setTimeout(() => phoenix.remove(), 2000);
    }
    
    function createCoinRainAnimation(targetElement) {
      for (let i = 0; i < 20; i++) {
        setTimeout(() => {
          const coin = document.createElement('div');
          coin.textContent = 'ü™ô';
          coin.style.cssText = `
            position: fixed;
            left: ${Math.random() * window.innerWidth}px;
            top: -50px;
            font-size: 20px;
            z-index: 9999;
            pointer-events: none;
            animation: coinRain 2s ease-in;
          `;
          document.body.appendChild(coin);
          setTimeout(() => coin.remove(), 2000);
        }, i * 100);
      }
    }
    
    function createPowerStealAnimation(targetElement) {
      const steal = document.createElement('div');
      steal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 100px;
        height: 100px;
        background: radial-gradient(circle, #ff00ff, #8800ff);
        border-radius: 50%;
        animation: powerSteal 1.5s ease-out;
        z-index: 9999;
        pointer-events: none;
      `;
      document.body.appendChild(steal);
      setTimeout(() => steal.remove(), 1500);
    }
    
    function createRoyalGuardAnimation(targetElement) {
      const guard = document.createElement('div');
      guard.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 150px;
        height: 150px;
        background: radial-gradient(circle, #ffd700, #ffaa00);
        border-radius: 50%;
        animation: royalGuard 2s ease-out;
        z-index: 9999;
        pointer-events: none;
      `;
      document.body.appendChild(guard);
      setTimeout(() => guard.remove(), 2000);
    }
    
    function createLuckyCharmAnimation(targetElement) {
      const charm = document.createElement('div');
      charm.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80px;
        height: 80px;
        background: radial-gradient(circle, #00ff00, #00aa00);
        border-radius: 50%;
        animation: luckyCharm 1.5s ease-out;
        z-index: 9999;
        pointer-events: none;
      `;
      document.body.appendChild(charm);
      setTimeout(() => charm.remove(), 1500);
    }
    
    function createChaosAnimation(targetElement) {
      const chaos = document.createElement('div');
      chaos.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 120px;
        height: 120px;
        background: radial-gradient(circle, #ff00ff, #00ffff);
        border-radius: 50%;
        animation: chaosRoll 2s ease-out;
        z-index: 9999;
        pointer-events: none;
      `;
      document.body.appendChild(chaos);
      setTimeout(() => chaos.remove(), 2000);
    }
    
    function createDoubleCoinsAnimation(targetElement) {
      const coins = document.createElement('div');
      coins.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 100px;
        height: 100px;
        background: radial-gradient(circle, #ffd700, #ffaa00);
        border-radius: 50%;
        animation: doubleCoins 1s ease-out;
        z-index: 9999;
        pointer-events: none;
      `;
      document.body.appendChild(coins);
      setTimeout(() => coins.remove(), 1000);
    }
    
    function createKnightBoostAnimation(targetElement) {
      const knight = document.createElement('div');
      knight.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80px;
        height: 80px;
        background: radial-gradient(circle, #ffffff, #aaaaaa);
        border-radius: 50%;
        animation: knightBoost 1s ease-out;
        z-index: 9999;
        pointer-events: none;
      `;
      document.body.appendChild(knight);
      setTimeout(() => knight.remove(), 1000);
    }
    
    function createInvisibilityAnimation(targetElement) {
      const invisibility = document.createElement('div');
      invisibility.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 100px;
        height: 100px;
        background: radial-gradient(circle, rgba(128, 128, 128, 0.5), transparent);
        border-radius: 50%;
        animation: invisibilityFade 1.5s ease-out;
        z-index: 9999;
        pointer-events: none;
      `;
      document.body.appendChild(invisibility);
      setTimeout(() => invisibility.remove(), 1500);
    }
    
    function createMirrorAnimation(targetElement) {
      const mirror = document.createElement('div');
      mirror.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 100px;
        height: 100px;
        background: radial-gradient(circle, #00ffff, #0088ff);
        border-radius: 50%;
        animation: mirrorReflect 1s ease-out;
        z-index: 9999;
        pointer-events: none;
      `;
      document.body.appendChild(mirror);
      setTimeout(() => mirror.remove(), 1000);
    }
    
    function createShieldWallAnimation(targetElement) {
      const wall = document.createElement('div');
      wall.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 200px;
        height: 100px;
        background: linear-gradient(180deg, transparent, rgba(0, 255, 255, 0.8), transparent);
        animation: shieldWall 1.5s ease-out;
        z-index: 9999;
        pointer-events: none;
      `;
      document.body.appendChild(wall);
      setTimeout(() => wall.remove(), 1500);
    }
    
    function createSpeedBoostAnimation(targetElement) {
      const speed = document.createElement('div');
      speed.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 120px;
        height: 120px;
        background: radial-gradient(circle, #00ff00, #00aa00);
        border-radius: 50%;
        animation: speedBoost 1s ease-out;
        z-index: 9999;
        pointer-events: none;
      `;
      document.body.appendChild(speed);
      setTimeout(() => speed.remove(), 1000);
    }
    
    function createTimeFreezeAnimation(targetElement) {
      const freeze = document.createElement('div');
      freeze.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(circle, rgba(0, 100, 255, 0.3), transparent);
        animation: timeFreeze 2s ease-out;
        z-index: 9998;
        pointer-events: none;
      `;
      document.body.appendChild(freeze);
      setTimeout(() => freeze.remove(), 2000);
    }
    
    // Add power-up animation to button
    function animatePowerUpButton(buttonId, powerUpType) {
      const button = document.getElementById(buttonId);
      if (button) {
        button.classList.add('power-up-active');
        playPowerUpAnimation(powerUpType, button);
        setTimeout(() => {
          button.classList.remove('power-up-active');
        }, 2000);
      }
    }
    
    // Universal Animation Controller
    class AnimationController {
      constructor() {
        this.activeAnimations = new Map();
        this.animationQueue = [];
        this.isProcessing = false;
      }
      
      // Apply animation to any element
      animate(element, animationClass, options = {}) {
        if (!element) return;
        
        const {
          duration = null,
          delay = 0,
          onComplete = null,
          onStart = null,
          repeat = 1
        } = options;
        
        // Remove existing animation
        this.removeAnimation(element);
        
        // Add new animation
        setTimeout(() => {
          if (onStart) onStart();
          element.classList.add(animationClass);
          
          // Store animation info
          this.activeAnimations.set(element, {
            class: animationClass,
            onComplete,
            timeout: null
          });
          
          // Handle completion
          const animationDuration = this.getAnimationDuration(animationClass) || 1000;
          const totalDuration = duration || animationDuration;
          
          const timeout = setTimeout(() => {
            element.classList.remove(animationClass);
            this.activeAnimations.delete(element);
            if (onComplete) onComplete();
          }, totalDuration * repeat);
          
          this.activeAnimations.get(element).timeout = timeout;
        }, delay);
      }
      
      // Remove animation from element
      removeAnimation(element) {
        if (!element) return;
        
        const animInfo = this.activeAnimations.get(element);
        if (animInfo) {
          clearTimeout(animInfo.timeout);
          element.classList.remove(animInfo.class);
          this.activeAnimations.delete(element);
        }
      }
      
      // Get animation duration from CSS
      getAnimationDuration(animationClass) {
        const durations = {
          'animate-fade-in': 500,
          'animate-fade-out': 500,
          'animate-scale-in': 300,
          'animate-scale-out': 300,
          'animate-bounce': 1000,
          'animate-shake': 500,
          'animate-pulse': 1000,
          'animate-rotate': 2000,
          'animate-wiggle': 1000,
          'animate-tada': 1000,
          'animate-rubber-band': 1000,
          'animate-swing': 1000,
          'animate-flip': 1000,
          'animate-zoom-in': 300,
          'animate-zoom-out': 300,
          'animate-slide-in-top': 500,
          'animate-slide-in-bottom': 500,
          'animate-slide-in-left': 500,
          'animate-slide-in-right': 500,
          'animate-heartbeat': 1500,
          'animate-wave': 1000,
          'animate-loading': 1000,
          'animate-spinner': 1000,
          'animate-piece-move': 300,
          'animate-piece-capture': 500,
          'animate-piece-select': 300,
          'animate-check-warning': 1000,
          'animate-checkmate': 2000,
          'animate-coin-collect': 500,
          'animate-level-up': 1000,
          'animate-achievement': 1000,
          'animate-notification': 3000,
          'animate-modal-open': 300,
          'animate-modal-close': 300,
          'animate-tab-switch': 300,
          'animate-combo': 1000,
          'animate-streak': 1000,
          'animate-multiplayer': 1000,
          'animate-connection': 2000,
          'animate-disconnect': 500,
          'animate-chat': 300,
          'animate-typing': 1500,
          'animate-sound': 300,
          'animate-music': 2000,
          'animate-volume': 300,
          'animate-settings': 2000,
          'animate-help': 300,
          'animate-info': 300,
          'animate-warning': 500,
          'animate-error': 500,
          'animate-success': 500
        };
        
        return durations[animationClass] || 1000;
      }
      
      // Chain multiple animations
      chain(element, animations) {
        animations.forEach((anim, index) => {
          setTimeout(() => {
            this.animate(element, anim.class, anim.options);
          }, anim.delay || (index * 100));
        });
      }
      
      // Animate multiple elements with stagger
      stagger(elements, animationClass, staggerDelay = 100) {
        elements.forEach((element, index) => {
          setTimeout(() => {
            this.animate(element, animationClass);
          }, index * staggerDelay);
        });
      }
      
      // Clear all animations
      clearAll() {
        this.activeAnimations.forEach((animInfo, element) => {
          clearTimeout(animInfo.timeout);
          element.classList.remove(animInfo.class);
        });
        this.activeAnimations.clear();
      }
    }
    
    // Global animation controller instance
    const animationController = new AnimationController();
    
    // Enhanced animation functions for specific game elements
    function animateChessPiece(piece, square, type = 'move') {
      const pieceElement = square.querySelector('.piece');
      if (!pieceElement) return;
      
      switch(type) {
        case 'move':
          animationController.animate(pieceElement, 'animate-piece-move');
          break;
        case 'capture':
          animationController.animate(pieceElement, 'animate-piece-capture');
          break;
        case 'select':
          animationController.animate(pieceElement, 'animate-piece-select');
          break;
        case 'check':
          square.classList.add('animate-check-warning');
          break;
        case 'checkmate':
          animationController.animate(pieceElement, 'animate-checkmate');
          break;
      }
    }
    
    function animateBoard(action) {
      const board = document.getElementById('board');
      if (!board) return;
      
      switch(action) {
        case 'shake':
          animationController.animate(board, 'animate-shake');
          break;
        case 'bounce':
          animationController.animate(board, 'animate-bounce');
          break;
        case 'pulse':
          animationController.animate(board, 'animate-pulse');
          break;
        case 'flip':
          animationController.animate(board, 'animate-flip');
          break;
      }
    }
    
    function animateButton(button, type = 'hover') {
      if (!button) return;
      
      switch(type) {
        case 'hover':
          button.classList.add('animate-hover');
          break;
        case 'press':
          button.classList.add('animate-press');
          break;
        case 'success':
          animationController.animate(button, 'animate-success');
          break;
        case 'error':
          animationController.animate(button, 'animate-error');
          break;
        case 'warning':
          animationController.animate(button, 'animate-warning');
          break;
        case 'tada':
          animationController.animate(button, 'animate-tada');
          break;
        case 'bounce':
          animationController.animate(button, 'animate-bounce');
          break;
      }
    }
    
    function animateModal(modal, action = 'open') {
      if (!modal) return;
      
      switch(action) {
        case 'open':
          animationController.animate(modal, 'animate-modal-open');
          break;
        case 'close':
          animationController.animate(modal, 'animate-modal-close');
          break;
        case 'shake':
          animationController.animate(modal, 'animate-shake');
          break;
      }
    }
    
    function animateNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = `animate-notification animate-${type}`;
      notification.textContent = message;
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 15px 20px;
        border-radius: 8px;
        color: white;
        font-weight: bold;
        z-index: 10000;
        min-width: 200px;
        text-align: center;
      `;
      
      // Set background based on type
      const backgrounds = {
        info: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
        success: 'linear-gradient(135deg, #00b09b 0%, #96c93d 100%)',
        warning: 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
        error: 'linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%)'
      };
      
      notification.style.background = backgrounds[type] || backgrounds.info;
      document.body.appendChild(notification);
      
      // Auto-remove after animation
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 3000);
    }
    
    function animateCoins(element, count = 1) {
      for (let i = 0; i < count; i++) {
        setTimeout(() => {
          const coin = document.createElement('div');
          coin.textContent = 'ü™ô';
          coin.className = 'animate-coin-collect';
          coin.style.cssText = `
            position: fixed;
            left: ${element.offsetLeft + Math.random() * element.offsetWidth}px;
            top: ${element.offsetTop}px;
            font-size: 20px;
            z-index: 9999;
            pointer-events: none;
          `;
          document.body.appendChild(coin);
          
          setTimeout(() => {
            if (coin.parentNode) {
              coin.parentNode.removeChild(coin);
            }
          }, 500);
        }, i * 100);
      }
    }
    
    function animateCombo(multiplier) {
      const combo = document.createElement('div');
      combo.className = 'animate-combo';
      combo.textContent = `${multiplier}x COMBO!`;
      combo.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 48px;
        font-weight: bold;
        color: #ffd700;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        z-index: 10000;
        pointer-events: none;
      `;
      document.body.appendChild(combo);
      
      setTimeout(() => {
        if (combo.parentNode) {
          combo.parentNode.removeChild(combo);
        }
      }, 1000);
    }
    
    function animateLevelUp() {
      const levelUp = document.createElement('div');
      levelUp.className = 'animate-level-up';
      levelUp.innerHTML = `
        <div style="text-align: center;">
          <div style="font-size: 36px; margin-bottom: 10px;">‚¨ÜÔ∏è LEVEL UP! ‚¨ÜÔ∏è</div>
          <div style="font-size: 24px; color: #ffd700;">New Unlocks Available!</div>
        </div>
      `;
      levelUp.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #ffd700, #ff6b6b);
        padding: 30px;
        border-radius: 15px;
        color: white;
        font-weight: bold;
        z-index: 10000;
        pointer-events: none;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      `;
      document.body.appendChild(levelUp);
      
      setTimeout(() => {
        if (levelUp.parentNode) {
          levelUp.parentNode.removeChild(levelUp);
        }
      }, 2000);
    }
    
    function animateAchievement(title, description) {
      const achievement = document.createElement('div');
      achievement.className = 'animate-achievement';
      achievement.innerHTML = `
        <div style="display: flex; align-items: center; margin-bottom: 10px;">
          <span style="font-size: 24px; margin-right: 10px;">üèÜ</span>
          <div>
            <div style="font-size: 18px; font-weight: bold;">${title}</div>
            <div style="font-size: 14px; opacity: 0.9;">${description}</div>
          </div>
        </div>
      `;
      achievement.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #ffd700, #ff6b6b);
        padding: 20px;
        border-radius: 10px;
        color: white;
        z-index: 10000;
        min-width: 300px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      `;
      document.body.appendChild(achievement);
      
      setTimeout(() => {
        if (achievement.parentNode) {
          achievement.parentNode.removeChild(achievement);
        }
      }, 3000);
    }
    
    function animateConnection(status) {
      const indicator = document.getElementById('connection-indicator');
      if (!indicator) return;
      
      switch(status) {
        case 'connecting':
          indicator.className = 'animate-connection';
          indicator.textContent = 'üîÑ Connecting...';
          break;
        case 'connected':
          indicator.className = 'animate-success';
          indicator.textContent = '‚úÖ Connected';
          break;
        case 'disconnected':
          indicator.className = 'animate-disconnect';
          indicator.textContent = '‚ùå Disconnected';
          break;
      }
    }
    
    function animateChat(message) {
      const chatContainer = document.getElementById('chat-messages');
      if (!chatContainer) return;
      
      const messageElement = document.createElement('div');
      messageElement.className = 'animate-chat';
      messageElement.textContent = message;
      messageElement.style.cssText = `
        margin-bottom: 8px;
        padding: 8px 12px;
        border-radius: 8px;
        background: rgba(255,255,255,0.1);
        color: white;
      `;
      
      chatContainer.appendChild(messageElement);
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }
    
    function animateTypingIndicator() {
      const indicator = document.createElement('div');
      indicator.className = 'animate-typing';
      indicator.innerHTML = 'Someone is typing<span class="animate-dots">...</span>';
      indicator.style.cssText = `
        padding: 8px;
        color: #94a3b8;
        font-style: italic;
      `;
      
      return indicator;
    }
    
    // Apply animations to all UI elements automatically
    function initializeAnimations() {
      // Add hover animations to all buttons
      document.querySelectorAll('button').forEach(button => {
        button.classList.add('animate-hover');
        button.addEventListener('mouseenter', () => {
          animationController.animate(button, 'animate-hover');
        });
        button.addEventListener('mousedown', () => {
          animationController.animate(button, 'animate-press');
        });
      });
      
      // Add animations to all inputs
      document.querySelectorAll('input, textarea, select').forEach(input => {
        input.addEventListener('focus', () => {
          animationController.animate(input, 'animate-scale-in');
        });
        input.addEventListener('blur', () => {
          animationController.animate(input, 'animate-scale-out');
        });
      });
      
      // Add animations to all modals
      document.querySelectorAll('.modal').forEach(modal => {
        modal.classList.add('animate-modal-open');
      });
      
      // Add animations to all cards
      document.querySelectorAll('.card, .shop-item').forEach(card => {
        card.classList.add('animate-hover');
        card.addEventListener('mouseenter', () => {
          animationController.animate(card, 'animate-scale-in');
        });
      });
      
      // Add animations to all tabs
      document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
          animationController.animate(tab, 'animate-tab-switch');
        });
      });
      
      console.log('üé® Animation system initialized');
    }
    
    // Make animation functions globally available
    window.animationController = animationController;
    window.animateChessPiece = animateChessPiece;
    window.animateBoard = animateBoard;
    window.animateButton = animateButton;
    window.animateModal = animateModal;
    window.animateNotification = animateNotification;
    window.animateCoins = animateCoins;
    window.animateCombo = animateCombo;
    window.animateLevelUp = animateLevelUp;
    window.animateAchievement = animateAchievement;
    window.animateConnection = animateConnection;
    window.animateChat = animateChat;
    window.animateTypingIndicator = animateTypingIndicator;
    
    // Firebase-based update system only (GitHub system removed)
    
    function createVersionDisplay() {
      if (document.getElementById('version-display')) return;
      
      const versionDisplay = document.createElement('div');
      versionDisplay.id = 'version-display';
      versionDisplay.className = 'animate-fade-in';
      versionDisplay.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.6));
        color: white;
        padding: 10px 15px;
        border-radius: 8px;
        font-size: 12px;
        font-weight: bold;
        z-index: 9999;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        transition: all 0.3s ease;
      `;
      
      versionDisplay.innerHTML = `üéÆ Fun Chess v${GAME_VERSION}`;
      document.body.appendChild(versionDisplay);
      
      console.log('üìã Version display created:', GAME_VERSION);
    }
    
    function updateVersionDisplay(status = 'normal') {
      const versionDisplay = document.getElementById('version-display');
      if (!versionDisplay) {
        createVersionDisplay();
        return;
      }
      
      versionDisplay.className = 'animate-fade-in';
      
      switch(status) {
        case 'checking':
          versionDisplay.innerHTML = `üîÑ Checking for updates...`;
          versionDisplay.style.background = 'linear-gradient(135deg, #667eea, #764ba2)';
          break;
        case 'update-available':
          versionDisplay.innerHTML = `üöÄ Update Available!`;
          versionDisplay.style.background = 'linear-gradient(135deg, #00d4ff, #0099cc)';
          versionDisplay.classList.add('animate-pulse');
          break;
        case 'updated':
          versionDisplay.innerHTML = `‚úÖ Just Updated: v${GAME_VERSION}`;
          versionDisplay.style.background = 'linear-gradient(135deg, #00d4ff, #0099cc)';
          versionDisplay.classList.add('animate-success');
          break;
        case 'error':
          versionDisplay.innerHTML = `‚ö†Ô∏è Update Check Failed`;
          versionDisplay.style.background = 'linear-gradient(135deg, #ff6b6b, #ee5a24)';
          versionDisplay.classList.add('animate-error');
          break;
        default:
          versionDisplay.innerHTML = `üéÆ Fun Chess v${GAME_VERSION}`;
          versionDisplay.style.background = 'linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.6))';
      }
    }
    
    function showUpdateCompleteNotification(newVersion) {
      const notification = document.createElement('div');
      notification.className = 'animate-slide-in-top animate-bounce';
      notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #00d4ff, #0099cc);
        color: white;
        padding: 30px;
        border-radius: 16px;
        box-shadow: 0 20px 40px rgba(0, 212, 255, 0.4);
        z-index: 10001;
        max-width: 400px;
        text-align: center;
        backdrop-filter: blur(10px);
        border: 2px solid rgba(255, 255, 255, 0.2);
      `;
      
      notification.innerHTML = `
        <div style="font-size: 48px; margin-bottom: 15px; animation: animate-tada 1s ease-out;">üéâ</div>
        <h2 style="margin: 0 0 10px 0; font-size: 24px; font-weight: bold;">Update Complete!</h2>
        <p style="margin: 0 0 20px 0; font-size: 16px; opacity: 0.9;">
          Successfully updated to version ${newVersion}
        </p>
        <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
          <p style="margin: 0; font-size: 14px;">
            ‚ú® New features and improvements are now available!<br>
            üöÄ Enjoy the enhanced gaming experience!
          </p>
        </div>
        <button onclick="this.parentElement.remove()" class="animate-hover" style="
          padding: 12px 30px;
          background: rgba(255, 255, 255, 0.2);
          border: 1px solid rgba(255, 255, 255, 0.3);
          border-radius: 8px;
          color: white;
          cursor: pointer;
          font-weight: bold;
          font-size: 14px;
          transition: all 0.3s ease;
        ">üéÆ Let's Play!</button>
      `;
      
      document.body.appendChild(notification);
      updateVersionDisplay('updated');
      
      // Auto-remove after 5 seconds
      setTimeout(() => {
        if (notification.parentNode) {
          notification.classList.add('animate-fade-out');
          setTimeout(() => notification.remove(), 500);
        }
      }, 5000);
    }
    
    function downloadUpdate(downloadUrl) {
      // Create download link
      const link = document.createElement('a');
      link.href = downloadUrl;
      link.download = `fun-chess-${Date.now()}.html`;
      link.style.display = 'none';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      // Show download started message
      const message = document.createElement('div');
      message.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 20px;
        border-radius: 8px;
        z-index: 10001;
        text-align: center;
      `;
      message.innerHTML = `
        <h3>Download Started!</h3>
        <p>The new version is being downloaded.</p>
        <p>Replace this file with the downloaded one to update.</p>
      `;
      document.body.appendChild(message);
      
      setTimeout(() => {
        document.body.removeChild(message);
      }, 3000);
    }
    
    function dismissUpdate(button) {
      const notification = button.closest('div[style*="position: fixed"]');
      if (notification && notification.parentNode) {
        notification.style.animation = 'slideInRight 0.5s ease-out reverse';
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 500);
      }
    }
    
    // Auto-update checker for distributed files
    function setupAutoUpdate() {
      // Check if this is a distributed file (not localhost)
      if (window.location.hostname !== 'localhost' && 
          window.location.hostname !== '127.0.0.1') {
        
        // Use unprotected version for file:// users, protected version for web users
        if (window.location.protocol === 'file:') {
          checkForUpdatesUnprotected();
          setInterval(checkForUpdatesUnprotected, 60 * 60 * 1000);
        } else {
          checkForUpdates();
          setInterval(checkForUpdates, 60 * 60 * 1000);
        }
      }
    }
    
    // Version comparison function
    function isNewerVersion(version1, version2) {
      // Simple version comparison for format like "7.5.0"
      const v1Parts = version1.split('.').map(Number);
      const v2Parts = version2.split('.').map(Number);
      
      for (let i = 0; i < Math.max(v1Parts.length, v2Parts.length); i++) {
        const v1Part = v1Parts[i] || 0;
        const v2Part = v2Parts[i] || 0;
        
        if (v1Part > v2Part) return true;
        if (v1Part < v2Part) return false;
      }
      
      return false; // Versions are equal
    }
    
    // Version comparison and migration system
    function migrateGameData() {
      const storedVersion = localStorage.getItem('gameVersion');
      const currentVersion = GAME_VERSION;
      
      if (!storedVersion || isNewerVersion(currentVersion, storedVersion)) {
        console.log('Migrating game data from version', storedVersion, 'to', currentVersion);
        
        // Add migration logic here for different versions
        if (!storedVersion) {
          // First time setup
          initializeDefaultSettings();
        } else if (isNewerVersion(currentVersion, storedVersion)) {
          // Version-specific migrations
          performVersionMigration(storedVersion, currentVersion);
        }
        
        localStorage.setItem('gameVersion', currentVersion);
      }
    }
    
    function initializeDefaultSettings() {
      // Set up default settings for new players
      if (!localStorage.getItem('audioSettings')) {
        window.audioSettings = {
          enabled: true,
          volume: 0.7,
          soundPack: 'classic'
        };
        saveAudioSettings();
      }
    }
    
    function performVersionMigration(fromVersion, toVersion) {
      console.log('Performing migration from', fromVersion, 'to', toVersion);
      
      // Add version-specific migration logic here
      // Example: if migrating from 0.9.0 to 1.0.0
      if (isNewerVersion('1.0.0', fromVersion)) {
        // Migrate old power-up data structure
        migratePowerUpData();
      }
    }
    
    function migratePowerUpData() {
      // Ensure all power-ups exist in the data structure
      const defaultPowerUps = {
        undo: 0, hint: 0, shield: 0, double_coins: 0, freeze: 0,
        knight_boost: 0, vision: 0, swap: 0, bomb: 0, time_warp: 0,
        lightning: 0, heal: 0, clone: 0, magnet: 0, poison: 0,
        shield_wall: 0, speed_boost: 0, invisibility: 0, earthquake: 0,
        blizzard: 0, laser: 0, mirror: 0, tornado: 0, gravity: 0,
        phoenix: 0, time_freeze: 0, coin_rain: 0, power_steal: 0,
        mega_bomb: 0, royal_guard: 0, lucky_charm: 0, chaos: 0
      };
      
      if (gameState.whitePowerUps) {
        Object.keys(defaultPowerUps).forEach(powerUp => {
          if (gameState.whitePowerUps[powerUp] === undefined) {
            gameState.whitePowerUps[powerUp] = 0;
          }
        });
      }
      
      if (gameState.blackPowerUps) {
        Object.keys(defaultPowerUps).forEach(powerUp => {
          if (gameState.blackPowerUps[powerUp] === undefined) {
            gameState.blackPowerUps[powerUp] = 0;
          }
        });
      }
      
      savePlayerProgress();
    }
    
    // Update notification system
    function showUpdateStatus(message, type = 'info') {
      const status = document.createElement('div');
      status.style.cssText = `
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        padding: 12px 24px;
        border-radius: 8px;
        color: white;
        font-weight: bold;
        z-index: 10000;
        animation: slideUp 0.5s ease-out;
      `;
      
      const colors = {
        info: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
        success: 'linear-gradient(135deg, #00b09b 0%, #96c93d 100%)',
        warning: 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
        error: 'linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%)'
      };
      
      status.style.background = colors[type] || colors.info;
      status.textContent = message;
      
      document.body.appendChild(status);
      
      setTimeout(() => {
        status.style.animation = 'slideUp 0.5s ease-out reverse';
        setTimeout(() => {
          document.body.removeChild(status);
        }, 500);
      }, 3000);
    }
    
    // Add slide-up animation
    const slideUpStyle = document.createElement('style');
    slideUpStyle.textContent = `
      @keyframes slideUp {
        from {
          transform: translateX(-50%) translateY(100%);
          opacity: 0;
        }
        to {
          transform: translateX(-50%) translateY(0);
          opacity: 1;
        }
      }
    `;
    document.head.appendChild(slideUpStyle);
    
    // Render sound packs in shop
    function renderSoundPacksShop() {
      const container = document.getElementById('soundpacks-container');
      if (!container) {
        console.error('soundpacks-container not found!');
        return;
      }
      container.innerHTML = '';
      
      Object.keys(soundPacks).forEach(soundId => {
        const soundPack = soundPacks[soundId];
        const unlockedPacks = gameState.unlockedSoundPacks || ['classic'];
        const currentPack = gameState.currentSoundPack || 'classic';
        const isUnlocked = unlockedPacks.includes(soundId);
        const isCurrent = currentPack === soundId;
        
        const item = document.createElement('div');
        item.style.cssText = 'background: rgba(255,255,255,0.1); padding: 16px; border-radius: 12px; backdrop-filter: blur(10px);';
        item.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
            <div>
              <div style="font-weight: bold; color: #f1f5f9; font-size: 18px;">${soundPack.name}</div>
              <div style="color: #cbd5e1; font-size: 14px;">${soundPack.description}</div>
              <div style="color: #cbd5e1; font-size: 12px;">${isUnlocked ? (isCurrent ? 'Currently Equipped' : 'Owned') : 'Not Purchased'}</div>
            </div>
            <div style="color: #f1f5f9; font-weight: bold; font-size: 16px;">ü™ô ${soundPack.cost}</div>
          </div>
          ${!isUnlocked ? `<button onclick="buySoundPack('${soundId}')" style="width: 100%; padding: 8px; border-radius: 8px; background: #f59e0b; color: white; font-weight: bold; cursor: pointer; border: none;">Buy Sound Pack</button>` : 
            (isCurrent ? '<button disabled style="width: 100%; padding: 8px; border-radius: 8px; background: #6b7280; color: white; font-weight: bold; cursor: not-allowed; border: none;">Currently Equipped</button>' :
            `<button onclick="equipSoundPack('${soundId}')" style="width: 100%; padding: 8px; border-radius: 8px; background: #3b82f6; color: white; font-weight: bold; cursor: pointer; border: none;">Equip Sound Pack</button>`)}
          <button onclick="previewSoundPack('${soundId}')" style="width: 100%; padding: 6px; border-radius: 6px; background: #64748b; color: white; font-weight: bold; cursor: pointer; border: none; margin-top: 8px; font-size: 12px;">üîä Preview</button>
        `;
        container.appendChild(item);
      });
    }

    // Buy sound pack function
    function buySoundPack(soundId) {
      console.log('üéµ buySoundPack called for:', soundId);
      playBuySound();
      const soundPack = soundPacks[soundId];
      const currentCoins = getCurrentCoins();
      
      console.log('üéµ Sound pack data:', soundPack);
      console.log('üéµ Current coins:', currentCoins);
      console.log('üéµ Cost:', soundPack.cost);
      console.log('üéµ Unlocked packs:', gameState.unlockedSoundPacks);
      console.log('üéµ Already purchased:', gameState.unlockedSoundPacks.includes(soundId));
      
      if (!soundPack) {
        console.error('‚ùå Sound pack not found:', soundId);
        playErrorSound();
        alert('Sound pack not found!');
        return;
      }
      
      if (currentCoins >= soundPack.cost && !gameState.unlockedSoundPacks.includes(soundId)) {
        console.log('‚úÖ Purchase successful!');
        if (gameState.currentPlayer === 'white') {
          gameState.whiteCoins -= soundPack.cost;
        } else {
          gameState.blackCoins -= soundPack.cost;
        }
        gameState.unlockedSoundPacks.push(soundId);
        
        console.log('üéµ New coins balance:', getCurrentCoins());
        console.log('üéµ Updated unlocked packs:', gameState.unlockedSoundPacks);
        
        document.getElementById('coin-count').textContent = getCurrentCoins();
        document.getElementById('shop-coin-count').textContent = getCurrentCoins();
        renderShopItems();
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
        
        alert(`Successfully purchased ${soundPack.name}! üéµ`);
      } else {
        console.log('‚ùå Purchase failed - not enough coins or already purchased');
        playErrorSound();
        const reason = currentCoins < soundPack.cost ? 
          `Not enough coins! Need ${soundPack.cost} ü™ô, you have ${currentCoins} ü™ô` :
          'Already purchased!';
        alert(reason);
      }
    }

    // Equip sound pack function
    function equipSoundPack(soundId) {
      gameState.currentSoundPack = soundId;
      renderShopItems();
      
      // Play a sample sound to confirm equip
      playButtonSound();
      
      // Save progress locally
      savePlayerProgress();
      
      // Save audio settings
      saveAudioSettings();
      
      if (gameState.mode === 'online') {
        updateGameStateOnServer();
      }
    }

    // Preview sound pack function
    function previewSoundPack(soundId) {
      // Play preview sounds based on the specific sound pack
      const packSettings = soundPackSettings[soundId];
      if (packSettings) {
        // Play a sequence of sounds to showcase the pack
        generateDynamicSound(packSettings.button);   // Button click
        setTimeout(() => generateDynamicSound(packSettings.move), 200);    // Move sound
        setTimeout(() => generateDynamicSound(packSettings.coins), 400);   // Coin sound
        setTimeout(() => generateDynamicSound(packSettings.capture), 600); // Capture sound
      }
      
      // Show a brief notification
      safeAlert(`üîä Previewing ${soundPacks[soundId].name} sound pack!`);
    }

    // Render bundle packs in shop
    function renderBundlesShop() {
      const container = document.getElementById('bundles-container');
      if (!container) {
        console.error('bundles-container not found!');
        return;
      }
      container.innerHTML = '';
      
      Object.keys(bundlePacks).forEach(bundleId => {
        const bundle = bundlePacks[bundleId];
        const isPurchased = gameState.unlockedBundles && gameState.unlockedBundles.includes(bundleId);
        const isEquipped = gameState.currentBundle === bundleId;
        
        const item = document.createElement('div');
        item.style.cssText = `
          background: rgba(255,255,255,0.1); 
          padding: 20px; 
          border-radius: 16px; 
          backdrop-filter: blur(10px);
          border: 2px solid rgba(255,255,255,0.2);
          position: relative;
          overflow: hidden;
        `;
        
        item.innerHTML = `
          <div style="position: absolute; top: 5px; right: 5px; font-size: 24px; opacity: 0.7;">${bundle.icon}</div>
          <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 12px; padding-right: 40px;">
            <div style="flex: 1;">
              <div style="font-weight: bold; color: #f1f5f9; font-size: 20px;">${bundle.name}</div>
              <div style="color: #cbd5e1; font-size: 14px; margin-top: 4px;">${bundle.description}</div>
            </div>
            <div style="color: #f1f5f9; font-weight: bold; font-size: 18px; text-align: right; min-width: 80px;">
              ${bundle.cost === 0 ? 'üÜì FREE' : `ü™ô ${bundle.cost}`}
            </div>
          </div>
          
          <div style="margin-bottom: 12px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 8px;">
            <div style="font-size: 12px; color: #94a3b8; margin-bottom: 4px;">Includes:</div>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 4px; font-size: 11px; color: #cbd5e1;">
              <div>üé® Theme: ${bundle.theme}</div>
              <div>‚ôüÔ∏è White Skin: ${bundle.whiteSkin}</div>
              <div>‚ôö Black Skin: ${bundle.blackSkin}</div>
              <div>‚ú® Effect: ${bundle.effect || 'None'}</div>
              <div>üîä Sound: ${bundle.soundPack}</div>
              <div style="grid-column: span 2;">üí∞ Cost: ${bundle.cost} ü™ô (Save ${Math.max(0, calculateBundleValue(bundleId) - bundle.cost)} ü™ô)</div>
            </div>
          </div>
          
          ${!isPurchased ? 
            `<button onclick="console.log('Buy button clicked for:', '${bundleId}'); buyBundle('${bundleId}')" style="width: 100%; padding: 10px; border-radius: 8px; background: #10b981; color: white; font-weight: bold; cursor: pointer; border: none; font-size: 14px;">
              üéÅ Buy Bundle
            </button>` : 
            (isEquipped ? 
              '<button disabled style="width: 100%; padding: 10px; border-radius: 8px; background: #6b7280; color: white; font-weight: bold; cursor: not-allowed; border: none; font-size: 14px;">‚úÖ Equipped</button>' :
              `<button onclick="console.log('Equip button clicked for:', '${bundleId}'); equipBundle('${bundleId}')" style="width: 100%; padding: 10px; border-radius: 8px; background: #3b82f6; color: white; font-weight: bold; cursor: pointer; border: none; font-size: 14px;">üéØ Equip Bundle</button>`
            )
          }
        `;
        
        container.appendChild(item);
      });
    }

    // Calculate bundle value (savings compared to buying individually)
    function calculateBundleValue(bundleId) {
      const bundle = bundlePacks[bundleId];
      let totalValue = 0;
      
      // Add theme cost
      if (bundle.theme && boardThemes[bundle.theme]) {
        totalValue += boardThemes[bundle.theme].cost || 0;
      }
      
      // Add skin costs
      if (skins[bundle.whiteSkin]) {
        totalValue += skins[bundle.whiteSkin].cost || 0;
      }
      if (skins[bundle.blackSkin]) {
        totalValue += skins[bundle.blackSkin].cost || 0;
      }
      
      // Add effect cost
      if (bundle.effect && effects[bundle.effect]) {
        totalValue += effects[bundle.effect].cost || 0;
      }
      
      // Add sound pack cost
      if (soundPacks[bundle.soundPack]) {
        totalValue += soundPacks[bundle.soundPack].cost || 0;
      }
      
      return totalValue;
    }

    // Buy bundle function
    window.buyBundle = function(bundleId) {
      console.log('üéÅ buyBundle called for:', bundleId);
      console.log('üéÅ bundlePacks available:', Object.keys(bundlePacks));
      console.log('üéÅ bundle exists:', !!bundlePacks[bundleId]);
      playBuySound();
      const bundle = bundlePacks[bundleId];
      const currentCoins = getCurrentCoins();
      
      console.log('üéÅ Bundle data:', bundle);
      console.log('üéÅ Current coins:', currentCoins);
      console.log('üéÅ Cost:', bundle.cost);
      
      if (!bundle) {
        console.error('‚ùå Bundle not found:', bundleId);
        playErrorSound();
        alert('Bundle not found!');
        return;
      }
      
      if (currentCoins >= bundle.cost) {
        console.log('‚úÖ Bundle purchase successful!');
        
        // Deduct coins
        if (gameState.currentPlayer === 'white') {
          gameState.whiteCoins -= bundle.cost;
        } else {
          gameState.blackCoins -= bundle.cost;
        }
        
        // Initialize unlocked bundles array if needed
        if (!gameState.unlockedBundles) {
          gameState.unlockedBundles = [];
        }
        
        // Add to unlocked bundles
        if (!gameState.unlockedBundles.includes(bundleId)) {
          gameState.unlockedBundles.push(bundleId);
        }
        
        // Unlock all items in the bundle
        if (bundle.theme && !gameState.unlockedThemes.includes(bundle.theme)) {
          gameState.unlockedThemes.push(bundle.theme);
        }
        
        if (bundle.whiteSkin && !gameState.whiteUnlockedSkins.includes(bundle.whiteSkin)) {
          gameState.whiteUnlockedSkins.push(bundle.whiteSkin);
        }
        
        if (bundle.blackSkin && !gameState.blackUnlockedSkins.includes(bundle.blackSkin)) {
          gameState.blackUnlockedSkins.push(bundle.blackSkin);
        }
        
        if (bundle.effect && effects[bundle.effect] && !effects[bundle.effect].purchased) {
          effects[bundle.effect].purchased = true;
        }
        
        if (bundle.soundPack && !gameState.unlockedSoundPacks.includes(bundle.soundPack)) {
          gameState.unlockedSoundPacks.push(bundle.soundPack);
        }
        
        // Auto-equip the bundle
        equipBundle(bundleId);
        
        console.log('üéÅ New coins balance:', getCurrentCoins());
        console.log('üéÅ Updated unlocked bundles:', gameState.unlockedBundles);
        
        // Update UI
        document.getElementById('coin-count').textContent = getCurrentCoins();
        document.getElementById('shop-coin-count').textContent = getCurrentCoins();
        renderShopItems();
        
        // Save progress locally
        savePlayerProgress();
        
        if (gameState.mode === 'online') {
          updateGameStateOnServer();
        }
        
        // Show success message with celebration
        createConfetti(document.body);
        alert(`üéâ Successfully purchased ${bundle.name}! üéÅ\n\nAll items have been unlocked and equipped!`);
      } else {
        console.log('‚ùå Bundle purchase failed - not enough coins');
        playErrorSound();
        alert(`Not enough coins! Need ${bundle.cost} ü™ô, you have ${currentCoins} ü™ô`);
      }
    }

    // Equip bundle function
    window.equipBundle = function(bundleId) {
      console.log('üéØ equipBundle called for:', bundleId);
      console.log('üéØ bundlePacks available:', Object.keys(bundlePacks));
      console.log('üéØ bundle exists:', !!bundlePacks[bundleId]);
      const bundle = bundlePacks[bundleId];
      
      if (!bundle) {
        console.error('‚ùå Bundle not found:', bundleId);
        return;
      }
      
      // Set current bundle
      gameState.currentBundle = bundleId;
      
      // Apply all bundle settings
      if (bundle.theme) {
        gameState.currentTheme = bundle.theme;
      }
      
      // Only set skin for the current player
      if (gameState.currentPlayer === 'white') {
        if (bundle.whiteSkin) {
          gameState.whiteCurrentSkin = bundle.whiteSkin;
        }
      } else {
        if (bundle.blackSkin) {
          gameState.blackCurrentSkin = bundle.blackSkin;
        }
      }
      
      if (bundle.effect) {
        gameState.currentEffect = bundle.effect;
      }
      
      if (bundle.soundPack) {
        gameState.currentSoundPack = bundle.soundPack;
      }
      
      // Apply theme immediately
      applyTheme(bundle.theme);
      
      // Re-render board to show new skins
      renderBoard();
      
      // Update shop to show equipped status
      renderShopItems();
      
      // Play confirmation sound
      playButtonSound();
      
      // Save progress
      savePlayerProgress();
      
      console.log('‚úÖ Bundle equipped:', bundle.name);
    }

    // Apply theme function
    window.applyTheme = function(themeId) {
      console.log('üé® Applying theme:', themeId);
      gameState.currentTheme = themeId;
      renderBoard();
    }

    // Main shop rendering function
    function renderShopItems() {
      // Render all shop sections in new order
      renderBundlesShop();
      renderPowerUpsShop();
      renderSkinsShop();
      renderThemesShop();
      renderEffectsShop();
      renderSoundPacksShop();
      
      // Update coin display
      document.getElementById('shop-coin-count').textContent = getCurrentCoins();
    }
    
    // Initialize - ensure all modals are hidden
    console.log('üéÆ CHESS GAME INITIALIZING...');
    document.getElementById('host-modal').style.display = 'none';
    document.getElementById('join-modal').style.display = 'none';
    document.getElementById('help-modal').style.display = 'none';
    document.getElementById('admin-login-modal').style.display = 'none';
    document.getElementById('admin-panel-modal').style.display = 'none';
    document.getElementById('shop-modal').style.display = 'none';
    document.getElementById('game-area').style.display = 'none';
    document.getElementById('online-options').style.display = 'none';
    document.getElementById('multiplayer-status').style.display = 'none';
    document.getElementById('mode-selection').style.display = 'none';
    
    // Show welcome screen initially
    document.getElementById('welcome-screen').style.display = 'flex';
    
    loadConfig();
    
    // Initialize audio settings
    window.audioSettings = {
      enabled: true,
      volume: 0.5,
      soundPack: 'classic'
    };
    loadAudioSettings();
    
    // Load player progress from local storage
    console.log('=== INITIAL LOAD START ===');
    console.log('About to call loadPlayerProgress()');
    const loadResult = loadPlayerProgress();
    console.log('loadPlayerProgress() returned:', loadResult);
    
    // Update UI with loaded data
    console.log('About to call ensurePowerUpButtonsUpdated() after initial load');
    ensurePowerUpButtonsUpdated();
    document.getElementById('coin-count').textContent = getCurrentCoins();
    console.log('=== INITIAL LOAD COMPLETE ===');
    renderBoard();
    
    // Test if AI is working after load
    if (gameState.mode === 'ai') {
      console.log('ü§ñ AI MODE DETECTED AFTER LOAD - Testing AI system...');
      console.log('Current player:', gameState.currentPlayer);
      console.log('AI difficulty:', gameState.aiDifficulty);
      console.log('Game over:', gameState.gameOver);
      console.log('Mode check - gameState.mode === "ai":', gameState.mode === 'ai');
      console.log('Player check - gameState.currentPlayer === "black":', gameState.currentPlayer === 'black');
      console.log('Game over check - !gameState.gameOver:', !gameState.gameOver);
      
      // If it's AI's turn, trigger AI move
      if (gameState.currentPlayer === 'black' && !gameState.gameOver && !gameState.freezeActive) {
        console.log('üéØ AI should move now - triggering AI move...');
        setTimeout(() => {
          if (!aiThinking) {
            makeAIMoveOnBoard();
          }
        }, 1000);
      } else {
        console.log('üö´ AI NOT TRIGGERED - Conditions not met');
        console.log('  - Is AI mode?', gameState.mode === 'ai');
        console.log('  - Is black turn?', gameState.currentPlayer === 'black');
        console.log('  - Is game not over?', !gameState.gameOver);
        console.log('  - Is AI not frozen?', !gameState.freezeActive);
      }
    } else {
      console.log('üìù Not in AI mode - current mode:', gameState.mode);
    }
    
    // Check if setup is needed
    checkSetupNeeded();
    
    // Initialize online storage if configured
    // Force Firebase provider and clear any old JSONBin settings
    localStorage.removeItem('jsonbinApiKey');
    localStorage.removeItem('storageProvider');
    ONLINE_STORAGE_CONFIG.provider = 'firebase';
    
    if ((ONLINE_STORAGE_CONFIG.provider === 'firebase' && ONLINE_STORAGE_CONFIG.firebase.apiKey) ||
        (ONLINE_STORAGE_CONFIG.provider === 'jsonbin' && ONLINE_STORAGE_CONFIG.jsonbinApiKey && ONLINE_STORAGE_CONFIG.jsonbinApiKey !== '$2a$10$nTdaN2Ay.BW9ZwhXR5zNeOALYds3POdaX8zK5n3PUV4myZwYYhi/6') ||
        (ONLINE_STORAGE_CONFIG.provider === 'googlesheets' && ONLINE_STORAGE_CONFIG.googlesheets.spreadsheetId && ONLINE_STORAGE_CONFIG.googlesheets.apiKey)) {
      initOnlineStorage();
    }
    
    // Check for version changes immediately on load
    const storedVersion = localStorage.getItem('chessGameVersion');
    if (storedVersion && storedVersion !== CURRENT_VERSION) {
      console.log('üîÑ Version change detected on load! Stored:', storedVersion, 'Current:', CURRENT_VERSION);
      showUpdateNotification(CURRENT_VERSION);
      localStorage.setItem('chessGameVersion', CURRENT_VERSION);
    } else if (!storedVersion) {
      localStorage.setItem('chessGameVersion', CURRENT_VERSION);
    }
    
    // Initialize all systems
    migrateGameData();
    setupAutoUpdate();
    initializeAnimations();
    createVersionDisplay();
    
    // Start auto-update checker
    startUpdateChecker();
    
    // Update Server function for admin panel
    async function updateServer() {
      if (!checkAuthentication()) {
        showAdminAuthModal();
        window.pendingProtectedAction = updateServer;
        return;
      }
      
      try {
        console.log('üöÄ Updating server with current version:', CURRENT_VERSION);
        
        if (!firebaseDatabase) {
          showUpdateStatus('‚ùå Firebase not connected', 'error');
          return;
        }
        
        const versionRef = firebaseDatabase.ref('gameVersion');
        await versionRef.set(CURRENT_VERSION);
        
        console.log('‚úÖ Server updated successfully to:', CURRENT_VERSION);
        showUpdateStatus(`‚úÖ Server updated to ${CURRENT_VERSION}`, 'success');
        
        // Update the display
        const displayElement = document.getElementById('current-version-display');
        if (displayElement) {
          displayElement.textContent = CURRENT_VERSION;
        }
        
      } catch (error) {
        console.error('‚ùå Error updating server:', error);
        showUpdateStatus('‚ùå Failed to update server', 'error');
      }
    }
    
    // Add event listener for Update Server button
    document.addEventListener('DOMContentLoaded', function() {
      const updateServerBtn = document.getElementById('update-server-btn');
      if (updateServerBtn) {
        updateServerBtn.addEventListener('click', updateServer);
      }
      
      // Update current version display
      const displayElement = document.getElementById('current-version-display');
      if (displayElement) {
        displayElement.textContent = CURRENT_VERSION;
      }
    });
    
    // Make functions globally available
    window.downloadUpdate = downloadUpdate;
    window.dismissUpdate = dismissUpdate;
    window.checkForUpdates = checkForUpdates;
    window.createVersionDisplay = createVersionDisplay;
    window.updateVersionDisplay = updateVersionDisplay;
    window.showUpdateCompleteNotification = showUpdateCompleteNotification;
    window.updateServer = updateServer;
    
    console.log('üéÆ Fun Chess V' + GAME_VERSION + ' loaded successfully!');
    console.log('üîÑ Auto-update system initialized');
    console.log('üì¶ Migration system initialized');
    console.log('üé® Animation system initialized');
    console.log('üìã Version display system initialized');
    
    // Show welcome notification with version
    setTimeout(() => {
      animateNotification(`Welcome to Fun Chess v${GAME_VERSION}! üéÆ`, 'success');
    }, 1000);
  </script>
 </body>
</html>
